{"ast":null,"code":"/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { secp256k1 as _secp, schnorr } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { hex, base58check as _b58, bech32, bech32m } from '@scure/base';\nimport * as P from 'micro-packed';\nconst {\n  ProjectivePoint: ProjPoint,\n  sign: _signECDSA,\n  getPublicKey: _pubECDSA\n} = _secp;\nconst CURVE_ORDER = _secp.CURVE.n;\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nconst def = (value, def) => value === undefined ? def : value;\nconst isBytes = P.isBytes;\nconst hash160 = msg => ripemd160(sha256(msg));\nconst sha256x2 = (...msgs) => sha256(sha256(concat(...msgs)));\nconst concat = P.concatBytes;\n// Make base58check work\nexport const base58check = _b58(sha256);\nexport function cloneDeep(obj) {\n  if (Array.isArray(obj)) return obj.map(i => cloneDeep(i));\n  // slice of nodejs Buffer doesn't copy\n  else if (obj instanceof Uint8Array) return Uint8Array.from(obj);\n  // immutable\n  else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj)) return obj;\n  // null is object\n  else if (obj === null) return obj;\n  // should be last, so it won't catch other types\n  else if (typeof obj === 'object') {\n    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)]));\n  }\n  throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\nvar PubT;\n(function (PubT) {\n  PubT[PubT[\"ecdsa\"] = 0] = \"ecdsa\";\n  PubT[PubT[\"schnorr\"] = 1] = \"schnorr\";\n})(PubT || (PubT = {}));\nfunction validatePubkey(pub, type) {\n  const len = pub.length;\n  if (type === PubT.ecdsa) {\n    if (len === 32) throw new Error('Expected non-Schnorr key');\n    ProjPoint.fromHex(pub); // does assertValidity\n    return pub;\n  } else if (type === PubT.schnorr) {\n    if (len !== 32) throw new Error('Expected 32-byte Schnorr key');\n    schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n    return pub;\n  } else {\n    throw new Error('Unknown key type');\n  }\n}\nfunction isValidPubkey(pub, type) {\n  try {\n    validatePubkey(pub, type);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = sig => sig.r < CURVE_ORDER / 2n;\nfunction signECDSA(hash, privateKey, lowR = false) {\n  let sig = _signECDSA(hash, privateKey);\n  if (lowR && !hasLowR(sig)) {\n    const extraEntropy = new Uint8Array(32);\n    for (let cnt = 0; cnt < Number.MAX_SAFE_INTEGER; cnt++) {\n      extraEntropy.set(P.U32LE.encode(cnt));\n      sig = _signECDSA(hash, privateKey, {\n        extraEntropy\n      });\n      if (hasLowR(sig)) break;\n    }\n  }\n  return sig.toDERRawBytes();\n}\nfunction tapTweak(a, b) {\n  const u = schnorr.utils;\n  const t = u.taggedHash('TapTweak', a, b);\n  const tn = u.bytesToNumberBE(t);\n  if (tn >= CURVE_ORDER) throw new Error('tweak higher than curve order');\n  return tn;\n}\nexport function taprootTweakPrivKey(privKey, merkleRoot = new Uint8Array()) {\n  const u = schnorr.utils;\n  const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n  const P = ProjPoint.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n  // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n  const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n  const xP = u.pointToBytes(P);\n  // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n  const t = tapTweak(xP, merkleRoot);\n  // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n  return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\nexport function taprootTweakPubkey(pubKey, h) {\n  const u = schnorr.utils;\n  const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n  const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n  const Q = P.add(ProjPoint.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n  const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n  return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n// Can be 33 or 64 bytes\nconst PubKeyECDSA = P.validate(P.bytes(null), pub => validatePubkey(pub, PubT.ecdsa));\nconst PubKeySchnorr = P.validate(P.bytes(32), pub => validatePubkey(pub, PubT.schnorr));\nconst SignatureSchnorr = P.validate(P.bytes(null), sig => {\n  if (sig.length !== 64 && sig.length !== 65) throw new Error('Schnorr signature should be 64 or 65 bytes long');\n  return sig;\n});\nfunction uniqPubkey(pubkeys) {\n  const map = {};\n  for (const pub of pubkeys) {\n    const key = hex.encode(pub);\n    if (map[key]) throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(hex.encode)}`);\n    map[key] = true;\n  }\n}\nexport const NETWORK = {\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80\n};\nexport const TEST_NETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef\n};\nexport const PRECISION = 8;\nexport const DEFAULT_VERSION = 2;\nexport const DEFAULT_LOCKTIME = 0;\nexport const DEFAULT_SEQUENCE = 4294967295;\nconst EMPTY32 = new Uint8Array(32);\n// Utils\nexport const Decimal = P.coders.decimal(PRECISION);\n// Exported for tests, internal method\nexport function _cmpBytes(a, b) {\n  if (!isBytes(a) || !isBytes(b)) throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n  // -1 -> a<b, 0 -> a==b, 1 -> a>b\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) if (a[i] != b[i]) return Math.sign(a[i] - b[i]);\n  return Math.sign(a.length - b.length);\n}\n// Coders\n// prettier-ignore\nexport var OP;\n(function (OP) {\n  OP[OP[\"OP_0\"] = 0] = \"OP_0\";\n  OP[OP[\"PUSHDATA1\"] = 76] = \"PUSHDATA1\";\n  OP[OP[\"PUSHDATA2\"] = 77] = \"PUSHDATA2\";\n  OP[OP[\"PUSHDATA4\"] = 78] = \"PUSHDATA4\";\n  OP[OP[\"1NEGATE\"] = 79] = \"1NEGATE\";\n  OP[OP[\"RESERVED\"] = 80] = \"RESERVED\";\n  OP[OP[\"OP_1\"] = 81] = \"OP_1\";\n  OP[OP[\"OP_2\"] = 82] = \"OP_2\";\n  OP[OP[\"OP_3\"] = 83] = \"OP_3\";\n  OP[OP[\"OP_4\"] = 84] = \"OP_4\";\n  OP[OP[\"OP_5\"] = 85] = \"OP_5\";\n  OP[OP[\"OP_6\"] = 86] = \"OP_6\";\n  OP[OP[\"OP_7\"] = 87] = \"OP_7\";\n  OP[OP[\"OP_8\"] = 88] = \"OP_8\";\n  OP[OP[\"OP_9\"] = 89] = \"OP_9\";\n  OP[OP[\"OP_10\"] = 90] = \"OP_10\";\n  OP[OP[\"OP_11\"] = 91] = \"OP_11\";\n  OP[OP[\"OP_12\"] = 92] = \"OP_12\";\n  OP[OP[\"OP_13\"] = 93] = \"OP_13\";\n  OP[OP[\"OP_14\"] = 94] = \"OP_14\";\n  OP[OP[\"OP_15\"] = 95] = \"OP_15\";\n  OP[OP[\"OP_16\"] = 96] = \"OP_16\";\n  // Control\n  OP[OP[\"NOP\"] = 97] = \"NOP\";\n  OP[OP[\"VER\"] = 98] = \"VER\";\n  OP[OP[\"IF\"] = 99] = \"IF\";\n  OP[OP[\"NOTIF\"] = 100] = \"NOTIF\";\n  OP[OP[\"VERIF\"] = 101] = \"VERIF\";\n  OP[OP[\"VERNOTIF\"] = 102] = \"VERNOTIF\";\n  OP[OP[\"ELSE\"] = 103] = \"ELSE\";\n  OP[OP[\"ENDIF\"] = 104] = \"ENDIF\";\n  OP[OP[\"VERIFY\"] = 105] = \"VERIFY\";\n  OP[OP[\"RETURN\"] = 106] = \"RETURN\";\n  // Stack\n  OP[OP[\"TOALTSTACK\"] = 107] = \"TOALTSTACK\";\n  OP[OP[\"FROMALTSTACK\"] = 108] = \"FROMALTSTACK\";\n  OP[OP[\"2DROP\"] = 109] = \"2DROP\";\n  OP[OP[\"2DUP\"] = 110] = \"2DUP\";\n  OP[OP[\"3DUP\"] = 111] = \"3DUP\";\n  OP[OP[\"2OVER\"] = 112] = \"2OVER\";\n  OP[OP[\"2ROT\"] = 113] = \"2ROT\";\n  OP[OP[\"2SWAP\"] = 114] = \"2SWAP\";\n  OP[OP[\"IFDUP\"] = 115] = \"IFDUP\";\n  OP[OP[\"DEPTH\"] = 116] = \"DEPTH\";\n  OP[OP[\"DROP\"] = 117] = \"DROP\";\n  OP[OP[\"DUP\"] = 118] = \"DUP\";\n  OP[OP[\"NIP\"] = 119] = \"NIP\";\n  OP[OP[\"OVER\"] = 120] = \"OVER\";\n  OP[OP[\"PICK\"] = 121] = \"PICK\";\n  OP[OP[\"ROLL\"] = 122] = \"ROLL\";\n  OP[OP[\"ROT\"] = 123] = \"ROT\";\n  OP[OP[\"SWAP\"] = 124] = \"SWAP\";\n  OP[OP[\"TUCK\"] = 125] = \"TUCK\";\n  // Splice\n  OP[OP[\"CAT\"] = 126] = \"CAT\";\n  OP[OP[\"SUBSTR\"] = 127] = \"SUBSTR\";\n  OP[OP[\"LEFT\"] = 128] = \"LEFT\";\n  OP[OP[\"RIGHT\"] = 129] = \"RIGHT\";\n  OP[OP[\"SIZE\"] = 130] = \"SIZE\";\n  // Boolean logic\n  OP[OP[\"INVERT\"] = 131] = \"INVERT\";\n  OP[OP[\"AND\"] = 132] = \"AND\";\n  OP[OP[\"OR\"] = 133] = \"OR\";\n  OP[OP[\"XOR\"] = 134] = \"XOR\";\n  OP[OP[\"EQUAL\"] = 135] = \"EQUAL\";\n  OP[OP[\"EQUALVERIFY\"] = 136] = \"EQUALVERIFY\";\n  OP[OP[\"RESERVED1\"] = 137] = \"RESERVED1\";\n  OP[OP[\"RESERVED2\"] = 138] = \"RESERVED2\";\n  // Numbers\n  OP[OP[\"1ADD\"] = 139] = \"1ADD\";\n  OP[OP[\"1SUB\"] = 140] = \"1SUB\";\n  OP[OP[\"2MUL\"] = 141] = \"2MUL\";\n  OP[OP[\"2DIV\"] = 142] = \"2DIV\";\n  OP[OP[\"NEGATE\"] = 143] = \"NEGATE\";\n  OP[OP[\"ABS\"] = 144] = \"ABS\";\n  OP[OP[\"NOT\"] = 145] = \"NOT\";\n  OP[OP[\"0NOTEQUAL\"] = 146] = \"0NOTEQUAL\";\n  OP[OP[\"ADD\"] = 147] = \"ADD\";\n  OP[OP[\"SUB\"] = 148] = \"SUB\";\n  OP[OP[\"MUL\"] = 149] = \"MUL\";\n  OP[OP[\"DIV\"] = 150] = \"DIV\";\n  OP[OP[\"MOD\"] = 151] = \"MOD\";\n  OP[OP[\"LSHIFT\"] = 152] = \"LSHIFT\";\n  OP[OP[\"RSHIFT\"] = 153] = \"RSHIFT\";\n  OP[OP[\"BOOLAND\"] = 154] = \"BOOLAND\";\n  OP[OP[\"BOOLOR\"] = 155] = \"BOOLOR\";\n  OP[OP[\"NUMEQUAL\"] = 156] = \"NUMEQUAL\";\n  OP[OP[\"NUMEQUALVERIFY\"] = 157] = \"NUMEQUALVERIFY\";\n  OP[OP[\"NUMNOTEQUAL\"] = 158] = \"NUMNOTEQUAL\";\n  OP[OP[\"LESSTHAN\"] = 159] = \"LESSTHAN\";\n  OP[OP[\"GREATERTHAN\"] = 160] = \"GREATERTHAN\";\n  OP[OP[\"LESSTHANOREQUAL\"] = 161] = \"LESSTHANOREQUAL\";\n  OP[OP[\"GREATERTHANOREQUAL\"] = 162] = \"GREATERTHANOREQUAL\";\n  OP[OP[\"MIN\"] = 163] = \"MIN\";\n  OP[OP[\"MAX\"] = 164] = \"MAX\";\n  OP[OP[\"WITHIN\"] = 165] = \"WITHIN\";\n  // Crypto\n  OP[OP[\"RIPEMD160\"] = 166] = \"RIPEMD160\";\n  OP[OP[\"SHA1\"] = 167] = \"SHA1\";\n  OP[OP[\"SHA256\"] = 168] = \"SHA256\";\n  OP[OP[\"HASH160\"] = 169] = \"HASH160\";\n  OP[OP[\"HASH256\"] = 170] = \"HASH256\";\n  OP[OP[\"CODESEPARATOR\"] = 171] = \"CODESEPARATOR\";\n  OP[OP[\"CHECKSIG\"] = 172] = \"CHECKSIG\";\n  OP[OP[\"CHECKSIGVERIFY\"] = 173] = \"CHECKSIGVERIFY\";\n  OP[OP[\"CHECKMULTISIG\"] = 174] = \"CHECKMULTISIG\";\n  OP[OP[\"CHECKMULTISIGVERIFY\"] = 175] = \"CHECKMULTISIGVERIFY\";\n  // Expansion\n  OP[OP[\"NOP1\"] = 176] = \"NOP1\";\n  OP[OP[\"CHECKLOCKTIMEVERIFY\"] = 177] = \"CHECKLOCKTIMEVERIFY\";\n  OP[OP[\"CHECKSEQUENCEVERIFY\"] = 178] = \"CHECKSEQUENCEVERIFY\";\n  OP[OP[\"NOP4\"] = 179] = \"NOP4\";\n  OP[OP[\"NOP5\"] = 180] = \"NOP5\";\n  OP[OP[\"NOP6\"] = 181] = \"NOP6\";\n  OP[OP[\"NOP7\"] = 182] = \"NOP7\";\n  OP[OP[\"NOP8\"] = 183] = \"NOP8\";\n  OP[OP[\"NOP9\"] = 184] = \"NOP9\";\n  OP[OP[\"NOP10\"] = 185] = \"NOP10\";\n  // BIP 342\n  OP[OP[\"CHECKSIGADD\"] = 186] = \"CHECKSIGADD\";\n  // Invalid\n  OP[OP[\"INVALID\"] = 255] = \"INVALID\";\n})(OP || (OP = {}));\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport const Script = P.wrap({\n  encodeStream: (w, value) => {\n    for (let o of value) {\n      if (typeof o === 'string') {\n        if (OP[o] === undefined) throw new Error(`Unknown opcode=${o}`);\n        w.byte(OP[o]);\n        continue;\n      } else if (typeof o === 'number') {\n        if (o === 0x00) {\n          w.byte(0x00);\n          continue;\n        } else if (1 <= o && o <= 16) {\n          w.byte(OP.OP_1 - 1 + o);\n          continue;\n        }\n      }\n      // Encode big numbers\n      if (typeof o === 'number') o = ScriptNum().encode(BigInt(o));\n      if (!isBytes(o)) throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n      // Bytes\n      const len = o.length;\n      if (len < OP.PUSHDATA1) w.byte(len);else if (len <= 0xff) {\n        w.byte(OP.PUSHDATA1);\n        w.byte(len);\n      } else if (len <= 0xffff) {\n        w.byte(OP.PUSHDATA2);\n        w.bytes(P.U16LE.encode(len));\n      } else {\n        w.byte(OP.PUSHDATA4);\n        w.bytes(P.U32LE.encode(len));\n      }\n      w.bytes(o);\n    }\n  },\n  decodeStream: r => {\n    const out = [];\n    while (!r.isEnd()) {\n      const cur = r.byte();\n      // if 0 < cur < 78\n      if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n        let len;\n        if (cur < OP.PUSHDATA1) len = cur;else if (cur === OP.PUSHDATA1) len = P.U8.decodeStream(r);else if (cur === OP.PUSHDATA2) len = P.U16LE.decodeStream(r);else if (cur === OP.PUSHDATA4) len = P.U32LE.decodeStream(r);else throw new Error('Should be not possible');\n        out.push(r.bytes(len));\n      } else if (cur === 0x00) {\n        out.push(0);\n      } else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n        out.push(cur - (OP.OP_1 - 1));\n      } else {\n        const op = OP[cur];\n        if (op === undefined) throw new Error(`Unknown opcode=${cur.toString(16)}`);\n        out.push(op);\n      }\n    }\n    return out;\n  }\n});\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum(bytesLimit = 6, forceMinimal = false) {\n  return P.wrap({\n    encodeStream: (w, value) => {\n      if (value === 0n) return;\n      const neg = value < 0;\n      const val = BigInt(value);\n      const nums = [];\n      for (let abs = neg ? -val : val; abs; abs >>= 8n) nums.push(Number(abs & 0xffn));\n      if (nums[nums.length - 1] >= 0x80) nums.push(neg ? 0x80 : 0);else if (neg) nums[nums.length - 1] |= 0x80;\n      w.bytes(new Uint8Array(nums));\n    },\n    decodeStream: r => {\n      const len = r.leftBytes;\n      if (len > bytesLimit) throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n      if (len === 0) return 0n;\n      if (forceMinimal) {\n        // MSB is zero (without sign bit) -> not minimally encoded\n        if ((r.data[len - 1] & 0x7f) === 0) {\n          // exception\n          if (len <= 1 || (r.data[len - 2] & 0x80) === 0) throw new Error('Non-minimally encoded ScriptNum');\n        }\n      }\n      let last = 0;\n      let res = 0n;\n      for (let i = 0; i < len; ++i) {\n        last = r.byte();\n        res |= BigInt(last) << 8n * BigInt(i);\n      }\n      if (last >= 0x80) {\n        res &= 2n ** BigInt(len * 8) - 1n >> 1n;\n        res = -res;\n      }\n      return res;\n    }\n  });\n}\nexport function OpToNum(op, bytesLimit = 4, forceMinimal = true) {\n  if (typeof op === 'number') return op;\n  if (isBytes(op)) {\n    try {\n      const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n      if (val > Number.MAX_SAFE_INTEGER) return;\n      return Number(val);\n    } catch (e) {\n      return;\n    }\n  }\n  return;\n}\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits = {\n  0xfd: [0xfd, 2, 253n, 65535n],\n  0xfe: [0xfe, 4, 65536n, 4294967295n],\n  0xff: [0xff, 8, 4294967296n, 18446744073709551615n]\n};\nexport const CompactSize = P.wrap({\n  encodeStream: (w, value) => {\n    if (typeof value === 'number') value = BigInt(value);\n    if (0n <= value && value <= 252n) return w.byte(Number(value));\n    for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n      if (start > value || value > stop) continue;\n      w.byte(flag);\n      for (let i = 0; i < bytes; i++) w.byte(Number(value >> 8n * BigInt(i) & 0xffn));\n      return;\n    }\n    throw w.err(`VarInt too big: ${value}`);\n  },\n  decodeStream: r => {\n    const b0 = r.byte();\n    if (b0 <= 0xfc) return BigInt(b0);\n    const [_, bytes, start] = CSLimits[b0];\n    let num = 0n;\n    for (let i = 0; i < bytes; i++) num |= BigInt(r.byte()) << 8n * BigInt(i);\n    if (num < start) throw r.err(`Wrong CompactSize(${8 * bytes})`);\n    return num;\n  }\n});\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nconst CompactSizeLen = P.apply(CompactSize, P.coders.number);\n// Array of size <CompactSize>\nexport const BTCArray = t => P.array(CompactSize, t);\n// ui8a of size <CompactSize>\nexport const VarBytes = P.bytes(CompactSize);\nexport const RawInput = P.struct({\n  txid: P.bytes(32, true),\n  index: P.U32LE,\n  finalScriptSig: VarBytes,\n  sequence: P.U32LE // ?\n});\n\nexport const RawOutput = P.struct({\n  amount: P.U64LE,\n  script: VarBytes\n});\nconst EMPTY_OUTPUT = {\n  amount: 0xffffffffffffffffn,\n  script: P.EMPTY\n};\n// SegWit v0 stack of witness buffers\nexport const RawWitness = P.array(CompactSizeLen, VarBytes);\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n  version: P.I32LE,\n  segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n  inputs: BTCArray(RawInput),\n  outputs: BTCArray(RawOutput),\n  witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n  // < 500000000\tBlock number at which this transaction is unlocked\n  // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n  // Handled as part of PSBTv2\n  lockTime: P.U32LE\n});\nfunction validateRawTx(tx) {\n  if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length) throw new Error('Segwit flag with empty witnesses array');\n  return tx;\n}\nexport const RawTx = P.validate(_RawTx, validateRawTx);\nfunction PSBTKeyInfo(info) {\n  const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n  return {\n    type,\n    kc,\n    vc,\n    reqInc,\n    allowInc,\n    silentIgnore\n  };\n}\nconst BIP32Der = P.struct({\n  fingerprint: P.U32BE,\n  path: P.array(null, P.U32LE)\n});\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n  version: P.U8,\n  internalKey: P.bytes(32),\n  merklePath: P.array(null, P.bytes(32))\n});\nexport const TaprootControlBlock = P.validate(_TaprootControlBlock, cb => {\n  if (cb.merklePath.length > 128) throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n  return cb;\n});\nconst TaprootBIP32Der = P.struct({\n  hashes: P.array(CompactSizeLen, P.bytes(32)),\n  der: BIP32Der\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({\n  pubKey: PubKeySchnorr,\n  leafHash: P.bytes(32)\n});\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(null, P.struct({\n  depth: P.U8,\n  version: P.U8,\n  script: VarBytes\n}));\nconst BytesInf = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20 = P.bytes(20);\nconst Bytes32 = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nconst PSBTGlobal = {\n  unsignedTx: [0x00, false, RawTx, [0], [0], false],\n  xpub: [0x01, GlobalXPUB, BIP32Der, [], [0, 2], false],\n  txVersion: [0x02, false, P.U32LE, [2], [2], false],\n  fallbackLocktime: [0x03, false, P.U32LE, [], [2], false],\n  inputCount: [0x04, false, CompactSizeLen, [2], [2], false],\n  outputCount: [0x05, false, CompactSizeLen, [2], [2], false],\n  txModifiable: [0x06, false, P.U8, [], [2], false],\n  version: [0xfb, false, P.U32LE, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// prettier-ignore\nconst PSBTInput = {\n  nonWitnessUtxo: [0x00, false, RawTx, [], [0, 2], false],\n  witnessUtxo: [0x01, false, RawOutput, [], [0, 2], false],\n  partialSig: [0x02, PubKeyECDSA, BytesInf, [], [0, 2], false],\n  sighashType: [0x03, false, P.U32LE, [], [0, 2], false],\n  redeemScript: [0x04, false, BytesInf, [], [0, 2], false],\n  witnessScript: [0x05, false, BytesInf, [], [0, 2], false],\n  bip32Derivation: [0x06, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n  finalScriptSig: [0x07, false, BytesInf, [], [0, 2], false],\n  finalScriptWitness: [0x08, false, RawWitness, [], [0, 2], false],\n  porCommitment: [0x09, false, BytesInf, [], [0, 2], false],\n  ripemd160: [0x0a, Bytes20, BytesInf, [], [0, 2], false],\n  sha256: [0x0b, Bytes32, BytesInf, [], [0, 2], false],\n  hash160: [0x0c, Bytes20, BytesInf, [], [0, 2], false],\n  hash256: [0x0d, Bytes32, BytesInf, [], [0, 2], false],\n  txid: [0x0e, false, Bytes32, [2], [2], true],\n  index: [0x0f, false, P.U32LE, [2], [2], true],\n  sequence: [0x10, false, P.U32LE, [], [2], true],\n  requiredTimeLocktime: [0x11, false, P.U32LE, [], [2], false],\n  requiredHeightLocktime: [0x12, false, P.U32LE, [], [2], false],\n  tapKeySig: [0x13, false, SignatureSchnorr, [], [0, 2], false],\n  tapScriptSig: [0x14, tapScriptSigKey, SignatureSchnorr, [], [0, 2], false],\n  tapLeafScript: [0x15, TaprootControlBlock, BytesInf, [], [0, 2], false],\n  tapBip32Derivation: [0x16, Bytes32, TaprootBIP32Der, [], [0, 2], false],\n  tapInternalKey: [0x17, false, PubKeySchnorr, [], [0, 2], false],\n  tapMerkleRoot: [0x18, false, Bytes32, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// All other keys removed when finalizing\nconst PSBTInputFinalKeys = ['txid', 'sequence', 'index', 'witnessUtxo', 'nonWitnessUtxo', 'finalScriptSig', 'finalScriptWitness', 'unknown'];\n// Can be modified even on signed input\nconst PSBTInputUnsignedKeys = ['partialSig', 'finalScriptSig', 'finalScriptWitness', 'tapKeySig', 'tapScriptSig'];\n// prettier-ignore\nconst PSBTOutput = {\n  redeemScript: [0x00, false, BytesInf, [], [0, 2], false],\n  witnessScript: [0x01, false, BytesInf, [], [0, 2], false],\n  bip32Derivation: [0x02, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n  amount: [0x03, false, P.I64LE, [2], [2], true],\n  script: [0x04, false, BytesInf, [2], [2], true],\n  tapInternalKey: [0x05, false, PubKeySchnorr, [], [0, 2], false],\n  tapTree: [0x06, false, tapTree, [], [0, 2], false],\n  tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// Can be modified even on signed input\nconst PSBTOutputUnsignedKeys = [];\nconst PSBTKeyPair = P.array(P.NULL, P.struct({\n  //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n  key: P.prefix(CompactSizeLen, P.struct({\n    type: CompactSizeLen,\n    key: P.bytes(null)\n  })),\n  //  <value> := <valuelen> <valuedata>\n  value: P.bytes(CompactSizeLen)\n}));\nconst PSBTUnknownKey = P.struct({\n  type: CompactSizeLen,\n  key: P.bytes(null)\n});\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap(psbtEnum) {\n  // -> Record<type, [keyName, ...coders]>\n  const byType = {};\n  for (const k in psbtEnum) {\n    const [num, kc, vc] = psbtEnum[k];\n    byType[num] = [k, kc, vc];\n  }\n  return P.wrap({\n    encodeStream: (w, value) => {\n      let out = [];\n      // Because we use order of psbtEnum, keymap is sorted here\n      for (const name in psbtEnum) {\n        const val = value[name];\n        if (val === undefined) continue;\n        const [type, kc, vc] = psbtEnum[name];\n        if (!kc) {\n          out.push({\n            key: {\n              type,\n              key: P.EMPTY\n            },\n            value: vc.encode(val)\n          });\n        } else {\n          // Low level interface, returns keys as is (with duplicates). Useful for debug\n          const kv = val.map(([k, v]) => [kc.encode(k), vc.encode(v)]);\n          // sort by keys\n          kv.sort((a, b) => _cmpBytes(a[0], b[0]));\n          for (const [key, value] of kv) out.push({\n            key: {\n              key,\n              type\n            },\n            value\n          });\n        }\n      }\n      if (value.unknown) {\n        value.unknown.sort((a, b) => _cmpBytes(a[0].key, b[0].key));\n        for (const [k, v] of value.unknown) out.push({\n          key: k,\n          value: v\n        });\n      }\n      PSBTKeyPair.encodeStream(w, out);\n    },\n    decodeStream: r => {\n      const raw = PSBTKeyPair.decodeStream(r);\n      const out = {};\n      const noKey = {};\n      for (const elm of raw) {\n        let name = 'unknown';\n        let key = elm.key.key;\n        let value = elm.value;\n        if (byType[elm.key.type]) {\n          const [_name, kc, vc] = byType[elm.key.type];\n          name = _name;\n          if (!kc && key.length) {\n            throw new Error(`PSBT: Non-empty key for ${name} (key=${hex.encode(key)} value=${hex.encode(value)}`);\n          }\n          key = kc ? kc.decode(key) : undefined;\n          value = vc.decode(value);\n          if (!kc) {\n            if (out[name]) throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n            out[name] = value;\n            noKey[name] = true;\n            continue;\n          }\n        } else {\n          // For unknown: add key type inside key\n          key = {\n            type: elm.key.type,\n            key: elm.key.key\n          };\n        }\n        // Only keyed elements at this point\n        if (noKey[name]) throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n        if (!out[name]) out[name] = [];\n        out[name].push([key, value]);\n      }\n      return out;\n    }\n  });\n}\n// Basic sanity check for scripts\nfunction checkWSH(s, witnessScript) {\n  if (!P.equalBytes(s.hash, sha256(witnessScript))) throw new Error('checkScript: wsh wrong witnessScript hash');\n  const w = OutScript.decode(witnessScript);\n  if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms') throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n  if (w.type === 'wpkh' || w.type === 'sh') throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\nfunction checkScript(script, redeemScript, witnessScript) {\n  if (script) {\n    const s = OutScript.decode(script);\n    // ms||pk maybe work, but there will be no address, hard to spend\n    if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk') throw new Error(`checkScript: non-wrapped ${s.type}`);\n    if (s.type === 'sh' && redeemScript) {\n      if (!P.equalBytes(s.hash, hash160(redeemScript))) throw new Error('checkScript: sh wrong redeemScript hash');\n      const r = OutScript.decode(redeemScript);\n      if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms') throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n      // Not sure if this unspendable, but we cannot represent this via PSBT\n      if (r.type === 'sh') throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n    }\n    if (s.type === 'wsh' && witnessScript) checkWSH(s, witnessScript);\n  }\n  if (redeemScript) {\n    const r = OutScript.decode(redeemScript);\n    if (r.type === 'wsh' && witnessScript) checkWSH(r, witnessScript);\n  }\n}\nconst PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), i => {\n  if (i.finalScriptWitness && !i.finalScriptWitness.length) throw new Error('validateInput: wmpty finalScriptWitness');\n  //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n  if (i.partialSig && !i.partialSig.length) throw new Error('Empty partialSig');\n  if (i.partialSig) for (const [k] of i.partialSig) validatePubkey(k, PubT.ecdsa);\n  if (i.bip32Derivation) for (const [k] of i.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n  if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000) throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n  // unsigned little endian integer greater than 0 and less than 500000000\n  if (i.requiredHeightLocktime !== undefined && (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000)) throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n  if (i.nonWitnessUtxo && i.index !== undefined) {\n    const last = i.nonWitnessUtxo.outputs.length - 1;\n    if (i.index > last) throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n    const prevOut = i.nonWitnessUtxo.outputs[i.index];\n    if (i.witnessUtxo && (!P.equalBytes(i.witnessUtxo.script, prevOut.script) || i.witnessUtxo.amount !== prevOut.amount)) throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n  }\n  if (i.tapLeafScript) {\n    // tap leaf version appears here twice: in control block and at the end of script\n    for (const [k, v] of i.tapLeafScript) {\n      if ((k.version & 254) !== v[v.length - 1]) throw new Error('validateInput: tapLeafScript version mimatch');\n      if (v[v.length - 1] & 1) throw new Error('validateInput: tapLeafScript version has parity bit!');\n    }\n  }\n  // Validate txid for nonWitnessUtxo is correct\n  if (i.nonWitnessUtxo && i.index && i.txid) {\n    const outputs = i.nonWitnessUtxo.outputs;\n    if (outputs.length - 1 < i.index) throw new Error('nonWitnessUtxo: incorect output index');\n    const tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo));\n    const txid = hex.encode(i.txid);\n    if (tx.id !== txid) throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n  }\n  return i;\n});\nconst PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), o => {\n  if (o.bip32Derivation) for (const [k] of o.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  return o;\n});\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), g => {\n  const version = g.version || 0;\n  if (version === 0) {\n    if (!g.unsignedTx) throw new Error('PSBTv0: missing unsignedTx');\n    if (g.unsignedTx.segwitFlag || g.unsignedTx.witnesses) throw new Error('PSBTv0: witness in unsingedTx');\n    for (const inp of g.unsignedTx.inputs) if (inp.finalScriptSig && inp.finalScriptSig.length) throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n  }\n  return g;\n});\nexport const _RawPSBTV0 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n  outputs: P.array(null, PSBTOutputCoder)\n});\nexport const _RawPSBTV2 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/inputCount', PSBTInputCoder),\n  outputs: P.array('global/outputCount', PSBTOutputCoder)\n});\nexport const _DebugPSBT = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  items: P.array(null, P.apply(P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])), P.coders.dict()))\n});\nfunction validatePSBTFields(version, info, lst) {\n  for (const k in lst) {\n    if (k === 'unknown') continue;\n    if (!info[k]) continue;\n    const {\n      allowInc\n    } = PSBTKeyInfo(info[k]);\n    if (!allowInc.includes(version)) throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n  }\n  for (const k in info) {\n    const {\n      reqInc\n    } = PSBTKeyInfo(info[k]);\n    if (reqInc.includes(version) && lst[k] === undefined) throw new Error(`PSBTv${version}: missing required field ${k}`);\n  }\n}\nfunction cleanPSBTFields(version, info, lst) {\n  const out = {};\n  for (const _k in lst) {\n    const k = _k;\n    if (k !== 'unknown') {\n      if (!info[k]) continue;\n      const {\n        allowInc,\n        silentIgnore\n      } = PSBTKeyInfo(info[k]);\n      if (!allowInc.includes(version)) {\n        if (silentIgnore) continue;\n        throw new Error(`Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`);\n      }\n    }\n    out[k] = lst[k];\n  }\n  return out;\n}\nfunction validatePSBT(tx) {\n  const version = tx && tx.global && tx.global.version || 0;\n  validatePSBTFields(version, PSBTGlobal, tx.global);\n  for (const i of tx.inputs) validatePSBTFields(version, PSBTInput, i);\n  for (const o of tx.outputs) validatePSBTFields(version, PSBTOutput, o);\n  // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n  const inputCount = !version ? tx.global.unsignedTx.inputs.length : tx.global.inputCount;\n  if (tx.inputs.length < inputCount) throw new Error('Not enough inputs');\n  const inputsLeft = tx.inputs.slice(inputCount);\n  if (inputsLeft.length > 1 || inputsLeft.length && Object.keys(inputsLeft[0]).length) throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n  // Same for inputs\n  const outputCount = !version ? tx.global.unsignedTx.outputs.length : tx.global.outputCount;\n  if (tx.outputs.length < outputCount) throw new Error('Not outputs inputs');\n  const outputsLeft = tx.outputs.slice(outputCount);\n  if (outputsLeft.length > 1 || outputsLeft.length && Object.keys(outputsLeft[0]).length) throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n  return tx;\n}\nfunction mergeKeyMap(psbtEnum, val, cur, allowedFields) {\n  const res = {\n    ...cur,\n    ...val\n  };\n  // All arguments can be provided as hex\n  for (const k in psbtEnum) {\n    const key = k;\n    const [_, kC, vC] = psbtEnum[key];\n    const cannotChange = allowedFields && !allowedFields.includes(k);\n    if (val[k] === undefined && k in val) {\n      if (cannotChange) throw new Error(`Cannot remove signed field=${k}`);\n      delete res[k];\n    } else if (kC) {\n      const oldKV = cur && cur[k] ? cur[k] : [];\n      let newKV = val[key];\n      if (newKV) {\n        if (!Array.isArray(newKV)) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n        // Decode hex in k-v\n        newKV = newKV.map(val => {\n          if (val.length !== 2) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n          return [typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0], typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1]];\n        });\n        const map = {};\n        const add = (kStr, k, v) => {\n          if (map[kStr] === undefined) {\n            map[kStr] = [k, v];\n            return;\n          }\n          const oldVal = hex.encode(vC.encode(map[kStr][1]));\n          const newVal = hex.encode(vC.encode(v));\n          if (oldVal !== newVal) throw new Error(`keyMap(${key}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`);\n        };\n        for (const [k, v] of oldKV) {\n          const kStr = hex.encode(kC.encode(k));\n          add(kStr, k, v);\n        }\n        for (const [k, v] of newKV) {\n          const kStr = hex.encode(kC.encode(k));\n          // undefined removes previous value\n          if (v === undefined) {\n            if (cannotChange) throw new Error(`Cannot remove signed field=${key}/${k}`);\n            delete map[kStr];\n          } else add(kStr, k, v);\n        }\n        res[key] = Object.values(map);\n      }\n    } else if (typeof res[k] === 'string') {\n      res[k] = vC.decode(hex.decode(res[k]));\n    } else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n      if (!P.equalBytes(vC.encode(val[k]), vC.encode(cur[k]))) throw new Error(`Cannot change signed field=${k}`);\n    }\n  }\n  // Remove unknown keys\n  for (const k in res) if (!psbtEnum[k]) delete res[k];\n  return res;\n}\nexport const RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport const RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({\n  txid: P.bytes(32, true),\n  index: P.U32LE\n});\nconst OutPK = {\n  encode(from) {\n    if (from.length !== 2 || !isBytes(from[0]) || !isValidPubkey(from[0], PubT.ecdsa) || from[1] !== 'CHECKSIG') return;\n    return {\n      type: 'pk',\n      pubkey: from[0]\n    };\n  },\n  decode: to => to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined\n};\n// @ts-ignore\nexport const p2pk = (pubkey, network = NETWORK) => {\n  // network is unused\n  if (!isValidPubkey(pubkey, PubT.ecdsa)) throw new Error('P2PK: invalid publicKey');\n  return {\n    type: 'pk',\n    script: OutScript.encode({\n      type: 'pk',\n      pubkey\n    })\n  };\n};\nconst OutPKH = {\n  encode(from) {\n    if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !isBytes(from[2])) return;\n    if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG') return;\n    return {\n      type: 'pkh',\n      hash: from[2]\n    };\n  },\n  decode: to => to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined\n};\nexport const p2pkh = (publicKey, network = NETWORK) => {\n  if (!isValidPubkey(publicKey, PubT.ecdsa)) throw new Error('P2PKH: invalid publicKey');\n  const hash = hash160(publicKey);\n  return {\n    type: 'pkh',\n    script: OutScript.encode({\n      type: 'pkh',\n      hash\n    }),\n    address: Address(network).encode({\n      type: 'pkh',\n      hash\n    })\n  };\n};\nconst OutSH = {\n  encode(from) {\n    if (from.length !== 3 || from[0] !== 'HASH160' || !isBytes(from[1]) || from[2] !== 'EQUAL') return;\n    return {\n      type: 'sh',\n      hash: from[1]\n    };\n  },\n  decode: to => to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined\n};\nexport const p2sh = (child, network = NETWORK) => {\n  // It is already tested inside noble-hashes and checkScript\n  const cs = child.script;\n  if (!isBytes(cs)) throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n  const hash = hash160(cs);\n  const script = OutScript.encode({\n    type: 'sh',\n    hash\n  });\n  checkScript(script, cs, child.witnessScript);\n  const res = {\n    type: 'sh',\n    redeemScript: cs,\n    script: OutScript.encode({\n      type: 'sh',\n      hash\n    }),\n    address: Address(network).encode({\n      type: 'sh',\n      hash\n    })\n  };\n  if (child.witnessScript) res.witnessScript = child.witnessScript;\n  return res;\n};\nconst OutWSH = {\n  encode(from) {\n    if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1])) return;\n    if (from[1].length !== 32) return;\n    return {\n      type: 'wsh',\n      hash: from[1]\n    };\n  },\n  decode: to => to.type === 'wsh' ? [0, to.hash] : undefined\n};\nexport const p2wsh = (child, network = NETWORK) => {\n  const cs = child.script;\n  if (!isBytes(cs)) throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n  const hash = sha256(cs);\n  const script = OutScript.encode({\n    type: 'wsh',\n    hash\n  });\n  checkScript(script, undefined, cs);\n  return {\n    type: 'wsh',\n    witnessScript: cs,\n    script: OutScript.encode({\n      type: 'wsh',\n      hash\n    }),\n    address: Address(network).encode({\n      type: 'wsh',\n      hash\n    })\n  };\n};\nconst OutWPKH = {\n  encode(from) {\n    if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1])) return;\n    if (from[1].length !== 20) return;\n    return {\n      type: 'wpkh',\n      hash: from[1]\n    };\n  },\n  decode: to => to.type === 'wpkh' ? [0, to.hash] : undefined\n};\nexport const p2wpkh = (publicKey, network = NETWORK) => {\n  if (!isValidPubkey(publicKey, PubT.ecdsa)) throw new Error('P2WPKH: invalid publicKey');\n  if (publicKey.length === 65) throw new Error('P2WPKH: uncompressed public key');\n  const hash = hash160(publicKey);\n  return {\n    type: 'wpkh',\n    script: OutScript.encode({\n      type: 'wpkh',\n      hash\n    }),\n    address: Address(network).encode({\n      type: 'wpkh',\n      hash\n    })\n  };\n};\nconst OutMS = {\n  encode(from) {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKMULTISIG') return;\n    const m = from[0];\n    const n = from[last - 1];\n    if (typeof m !== 'number' || typeof n !== 'number') return;\n    const pubkeys = from.slice(1, -2);\n    if (n !== pubkeys.length) return;\n    for (const pub of pubkeys) if (!isBytes(pub)) return;\n    return {\n      type: 'ms',\n      m,\n      pubkeys: pubkeys\n    }; // we don't need n, since it is the same as pubkeys\n  },\n\n  // checkmultisig(n, ..pubkeys, m)\n  decode: to => to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined\n};\nexport const p2ms = (m, pubkeys, allowSamePubkeys = false) => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'ms',\n    script: OutScript.encode({\n      type: 'ms',\n      pubkeys,\n      m\n    })\n  };\n};\nconst OutTR = {\n  encode(from) {\n    if (from.length !== 2 || from[0] !== 1 || !isBytes(from[1])) return;\n    return {\n      type: 'tr',\n      pubkey: from[1]\n    };\n  },\n  decode: to => to.type === 'tr' ? [1, to.pubkey] : undefined\n};\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList) {\n  // Clone input in order to not corrupt it\n  const lst = Array.from(taprootList);\n  // We have at least 2 elements => can create branch\n  while (lst.length >= 2) {\n    // Sort: elements with smallest weight are in the end of queue\n    lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n    const b = lst.pop();\n    const a = lst.pop();\n    const weight = (a?.weight || 1) + (b?.weight || 1);\n    lst.push({\n      weight,\n      // Unwrap children array\n      // TODO: Very hard to remove any here\n      childs: [a?.childs || a, b?.childs || b]\n    });\n  }\n  // At this point there is always 1 element in lst\n  const last = lst[0];\n  return last?.childs || last;\n}\nfunction checkTaprootScript(script, internalPubKey, allowUnknownOutputs = false) {\n  const out = OutScript.decode(script);\n  if (out.type === 'unknown' && allowUnknownOutputs) return;\n  if (!['tr_ns', 'tr_ms'].includes(out.type)) throw new Error(`P2TR: invalid leaf script=${out.type}`);\n  const outms = out;\n  if (!allowUnknownOutputs && outms.pubkeys) {\n    for (const p of outms.pubkeys) {\n      if (P.equalBytes(p, TAPROOT_UNSPENDABLE_KEY)) throw new Error('Unspendable taproot key in leaf script');\n      // It's likely a mistake at this point:\n      // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n      // but will take more space and fees.\n      // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n      // User creates 2 of 3 multisig of keys [A, B, C],\n      // but key A always can spend whole output without signatures from other keys.\n      // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n      if (P.equalBytes(p, internalPubKey)) {\n        throw new Error('Using P2TR with leaf script with same key as internal key is not supported');\n      }\n    }\n  }\n}\nfunction taprootHashTree(tree, internalPubKey, allowUnknownOutputs = false) {\n  if (!tree) throw new Error('taprootHashTree: empty tree');\n  if (Array.isArray(tree) && tree.length === 1) tree = tree[0];\n  // Terminal node (leaf)\n  if (!Array.isArray(tree)) {\n    const {\n      leafVersion: version,\n      script: leafScript\n    } = tree;\n    // Earliest tree walk where we can validate tapScripts\n    if (tree.tapLeafScript || tree.tapMerkleRoot && !P.equalBytes(tree.tapMerkleRoot, P.EMPTY)) throw new Error('P2TR: tapRoot leafScript cannot have tree');\n    const script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n    if (!isBytes(script)) throw new Error(`checkScript: wrong script type=${script}`);\n    checkTaprootScript(script, internalPubKey, allowUnknownOutputs);\n    return {\n      type: 'leaf',\n      version,\n      script,\n      hash: tapLeafHash(script, version)\n    };\n  }\n  // If tree / branch is not binary tree, convert it\n  if (tree.length !== 2) tree = taprootListToTree(tree);\n  if (tree.length !== 2) throw new Error('hashTree: non binary tree!');\n  // branch\n  // Both nodes should exist\n  const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs);\n  const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs);\n  // We cannot swap left/right here, since it will change structure of tree\n  let [lH, rH] = [left.hash, right.hash];\n  if (_cmpBytes(rH, lH) === -1) [lH, rH] = [rH, lH];\n  return {\n    type: 'branch',\n    left,\n    right,\n    hash: schnorr.utils.taggedHash('TapBranch', lH, rH)\n  };\n}\nfunction taprootAddPath(tree, path = []) {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return {\n    ...tree,\n    path\n  };\n  if (tree.type !== 'branch') throw new Error(`taprootAddPath: wrong type=${tree}`);\n  return {\n    ...tree,\n    path,\n    // Left element has right hash in path and otherwise\n    left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n    right: taprootAddPath(tree.right, [tree.left.hash, ...path])\n  };\n}\nfunction taprootWalkTree(tree) {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return [tree];\n  if (tree.type !== 'branch') throw new Error(`taprootWalkTree: wrong type=${tree}`);\n  return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport const TAPROOT_UNSPENDABLE_KEY = sha256(ProjPoint.BASE.toRawBytes(false));\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport function p2tr(internalPubKey, tree, network = NETWORK, allowUnknownOutputs = false) {\n  // Unspendable\n  if (!internalPubKey && !tree) throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n  const pubKey = typeof internalPubKey === 'string' ? hex.decode(internalPubKey) : internalPubKey || TAPROOT_UNSPENDABLE_KEY;\n  if (!isValidPubkey(pubKey, PubT.schnorr)) throw new Error('p2tr: non-schnorr pubkey');\n  let hashedTree = tree ? taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs)) : undefined;\n  const tapMerkleRoot = hashedTree ? hashedTree.hash : undefined;\n  const [tweakedPubkey, parity] = taprootTweakPubkey(pubKey, tapMerkleRoot || P.EMPTY);\n  let leaves;\n  if (hashedTree) {\n    leaves = taprootWalkTree(hashedTree).map(l => ({\n      ...l,\n      controlBlock: TaprootControlBlock.encode({\n        version: (l.version || TAP_LEAF_VERSION) + parity,\n        internalKey: pubKey,\n        merklePath: l.path\n      })\n    }));\n  }\n  let tapLeafScript;\n  if (leaves) {\n    tapLeafScript = leaves.map(l => [TaprootControlBlock.decode(l.controlBlock), concat(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION]))]);\n  }\n  const res = {\n    type: 'tr',\n    script: OutScript.encode({\n      type: 'tr',\n      pubkey: tweakedPubkey\n    }),\n    address: Address(network).encode({\n      type: 'tr',\n      pubkey: tweakedPubkey\n    }),\n    // For tests\n    tweakedPubkey,\n    // PSBT stuff\n    tapInternalKey: pubKey\n  };\n  // Just in case someone would want to select a specific script\n  if (leaves) res.leaves = leaves;\n  if (tapLeafScript) res.tapLeafScript = tapLeafScript;\n  if (tapMerkleRoot) res.tapMerkleRoot = tapMerkleRoot;\n  return res;\n}\nconst OutTRNS = {\n  encode(from) {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    // On error return, since it can be different script\n    for (let i = 0; i < last; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== 'CHECKSIGVERIFY' || i === last - 1) return;\n        continue;\n      }\n      if (!isBytes(elm)) return;\n      pubkeys.push(elm);\n    }\n    return {\n      type: 'tr_ns',\n      pubkeys\n    };\n  },\n  decode: to => {\n    if (to.type !== 'tr_ns') return;\n    const out = [];\n    for (let i = 0; i < to.pubkeys.length - 1; i++) out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n    out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n    return out;\n  }\n};\n// Returns all combinations of size M from lst\nexport function combinations(m, list) {\n  const res = [];\n  if (!Array.isArray(list)) throw new Error('combinations: lst arg should be array');\n  const n = list.length;\n  if (m > n) throw new Error('combinations: m > lst.length, no combinations possible');\n  /*\n  Basically works as M nested loops like:\n  for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n  but since we cannot create nested loops dynamically, we unroll it to a single loop\n  */\n  const idx = Array.from({\n    length: m\n  }, (_, i) => i);\n  const last = idx.length - 1;\n  main: for (;;) {\n    res.push(idx.map(i => list[i]));\n    idx[last] += 1;\n    let i = last;\n    // Propagate increment\n    // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n    for (; i >= 0 && idx[i] > n - m + i; i--) {\n      idx[i] = 0;\n      // Overflow in idx[0], break\n      if (i === 0) break main;\n      idx[i - 1] += 1;\n    }\n    // Propagate: idx[i+1] = idx[idx]+1\n    for (i += 1; i < idx.length; i++) idx[i] = idx[i - 1] + 1;\n  }\n  return res;\n}\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport const p2tr_ns = (m, pubkeys, allowSamePubkeys = false) => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return combinations(m, pubkeys).map(i => ({\n    type: 'tr_ns',\n    script: OutScript.encode({\n      type: 'tr_ns',\n      pubkeys: i\n    })\n  }));\n};\n// Taproot public key (case of p2tr_ns)\nexport const p2tr_pk = pubkey => p2tr_ns(1, [pubkey], undefined)[0];\nconst OutTRMS = {\n  encode(from) {\n    const last = from.length - 1;\n    if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    const m = OpToNum(from[last - 1]);\n    if (typeof m !== 'number') return;\n    for (let i = 0; i < last - 1; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD')) throw new Error('OutScript.encode/tr_ms: wrong element');\n        continue;\n      }\n      if (!isBytes(elm)) throw new Error('OutScript.encode/tr_ms: wrong key element');\n      pubkeys.push(elm);\n    }\n    return {\n      type: 'tr_ms',\n      pubkeys,\n      m\n    };\n  },\n  decode: to => {\n    if (to.type !== 'tr_ms') return;\n    const out = [to.pubkeys[0], 'CHECKSIG'];\n    for (let i = 1; i < to.pubkeys.length; i++) out.push(to.pubkeys[i], 'CHECKSIGADD');\n    out.push(to.m, 'NUMEQUAL');\n    return out;\n  }\n};\nexport function p2tr_ms(m, pubkeys, allowSamePubkeys = false) {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'tr_ms',\n    script: OutScript.encode({\n      type: 'tr_ms',\n      pubkeys,\n      m\n    })\n  };\n}\nconst OutUnknown = {\n  encode(from) {\n    return {\n      type: 'unknown',\n      script: Script.encode(from)\n    };\n  },\n  decode: to => to.type === 'unknown' ? Script.decode(to.script) : undefined\n};\n// /Payments\nconst OutScripts = [OutPK, OutPKH, OutSH, OutWSH, OutWPKH, OutMS, OutTR, OutTRNS, OutTRMS, OutUnknown];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(Script, P.coders.match(OutScripts));\n// We can validate this once, because of packed & coders\nexport const OutScript = P.validate(_OutScript, i => {\n  if (i.type === 'pk' && !isValidPubkey(i.pubkey, PubT.ecdsa)) throw new Error('OutScript/pk: wrong key');\n  if ((i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') && (!isBytes(i.hash) || i.hash.length !== 20)) throw new Error(`OutScript/${i.type}: wrong hash`);\n  if (i.type === 'wsh' && (!isBytes(i.hash) || i.hash.length !== 32)) throw new Error(`OutScript/wsh: wrong hash`);\n  if (i.type === 'tr' && (!isBytes(i.pubkey) || !isValidPubkey(i.pubkey, PubT.schnorr))) throw new Error('OutScript/tr: wrong taproot public key');\n  if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms') if (!Array.isArray(i.pubkeys)) throw new Error('OutScript/multisig: wrong pubkeys array');\n  if (i.type === 'ms') {\n    const n = i.pubkeys.length;\n    for (const p of i.pubkeys) if (!isValidPubkey(p, PubT.ecdsa)) throw new Error('OutScript/multisig: wrong pubkey');\n    if (i.m <= 0 || n > 16 || i.m > n) throw new Error('OutScript/multisig: invalid params');\n  }\n  if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n    for (const p of i.pubkeys) if (!isValidPubkey(p, PubT.schnorr)) throw new Error(`OutScript/${i.type}: wrong pubkey`);\n  }\n  if (i.type === 'tr_ms') {\n    const n = i.pubkeys.length;\n    if (i.m <= 0 || n > 999 || i.m > n) throw new Error('OutScript/tr_ms: invalid params');\n  }\n  return i;\n});\n// Address\nfunction validateWitness(version, data) {\n  if (data.length < 2 || data.length > 40) throw new Error('Witness: invalid length');\n  if (version > 16) throw new Error('Witness: invalid version');\n  if (version === 0 && !(data.length === 20 || data.length === 32)) throw new Error('Witness: invalid length for version');\n}\nexport function programToWitness(version, data, network = NETWORK) {\n  validateWitness(version, data);\n  const coder = version === 0 ? bech32 : bech32m;\n  return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\nfunction formatKey(hashed, prefix) {\n  return base58check.encode(concat(Uint8Array.from(prefix), hashed));\n}\nexport function WIF(network = NETWORK) {\n  return {\n    encode(privKey) {\n      const compressed = concat(privKey, new Uint8Array([0x01]));\n      return formatKey(compressed.subarray(0, 33), [network.wif]);\n    },\n    decode(wif) {\n      let parsed = base58check.decode(wif);\n      if (parsed[0] !== network.wif) throw new Error('Wrong WIF prefix');\n      parsed = parsed.subarray(1);\n      // Check what it is. Compressed flag?\n      if (parsed.length !== 33) throw new Error('Wrong WIF length');\n      if (parsed[32] !== 0x01) throw new Error('Wrong WIF postfix');\n      return parsed.subarray(0, -1);\n    }\n  };\n}\n// Returns OutType, which can be used to create outscript\nexport function Address(network = NETWORK) {\n  return {\n    encode(from) {\n      const {\n        type\n      } = from;\n      if (type === 'wpkh') return programToWitness(0, from.hash, network);else if (type === 'wsh') return programToWitness(0, from.hash, network);else if (type === 'tr') return programToWitness(1, from.pubkey, network);else if (type === 'pkh') return formatKey(from.hash, [network.pubKeyHash]);else if (type === 'sh') return formatKey(from.hash, [network.scriptHash]);\n      throw new Error(`Unknown address type=${type}`);\n    },\n    decode(address) {\n      if (address.length < 14 || address.length > 74) throw new Error('Invalid address length');\n      // Bech32\n      if (network.bech32 && address.toLowerCase().startsWith(network.bech32)) {\n        let res;\n        try {\n          res = bech32.decode(address);\n          if (res.words[0] !== 0) throw new Error(`bech32: wrong version=${res.words[0]}`);\n        } catch (_) {\n          // Starting from version 1 it is decoded as bech32m\n          res = bech32m.decode(address);\n          if (res.words[0] === 0) throw new Error(`bech32m: wrong version=${res.words[0]}`);\n        }\n        if (res.prefix !== network.bech32) throw new Error(`wrong bech32 prefix=${res.prefix}`);\n        const [version, ...program] = res.words;\n        const data = bech32.fromWords(program);\n        validateWitness(version, data);\n        if (version === 0 && data.length === 32) return {\n          type: 'wsh',\n          hash: data\n        };else if (version === 0 && data.length === 20) return {\n          type: 'wpkh',\n          hash: data\n        };else if (version === 1 && data.length === 32) return {\n          type: 'tr',\n          pubkey: data\n        };else throw new Error('Unknown witness program');\n      }\n      const data = base58check.decode(address);\n      if (data.length !== 21) throw new Error('Invalid base58 address');\n      // Pay To Public Key Hash\n      if (data[0] === network.pubKeyHash) {\n        return {\n          type: 'pkh',\n          hash: data.slice(1)\n        };\n      } else if (data[0] === network.scriptHash) {\n        return {\n          type: 'sh',\n          hash: data.slice(1)\n        };\n      }\n      throw new Error(`Invalid address prefix=${data[0]}`);\n    }\n  };\n}\n// /Address\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport var SignatureHash;\n(function (SignatureHash) {\n  SignatureHash[SignatureHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SignatureHash[SignatureHash[\"ALL\"] = 1] = \"ALL\";\n  SignatureHash[SignatureHash[\"NONE\"] = 2] = \"NONE\";\n  SignatureHash[SignatureHash[\"SINGLE\"] = 3] = \"SINGLE\";\n  SignatureHash[SignatureHash[\"ANYONECANPAY\"] = 128] = \"ANYONECANPAY\";\n})(SignatureHash || (SignatureHash = {}));\nexport var SigHash;\n(function (SigHash) {\n  SigHash[SigHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SigHash[SigHash[\"ALL\"] = 1] = \"ALL\";\n  SigHash[SigHash[\"NONE\"] = 2] = \"NONE\";\n  SigHash[SigHash[\"SINGLE\"] = 3] = \"SINGLE\";\n  SigHash[SigHash[\"DEFAULT_ANYONECANPAY\"] = 128] = \"DEFAULT_ANYONECANPAY\";\n  SigHash[SigHash[\"ALL_ANYONECANPAY\"] = 129] = \"ALL_ANYONECANPAY\";\n  SigHash[SigHash[\"NONE_ANYONECANPAY\"] = 130] = \"NONE_ANYONECANPAY\";\n  SigHash[SigHash[\"SINGLE_ANYONECANPAY\"] = 131] = \"SINGLE_ANYONECANPAY\";\n})(SigHash || (SigHash = {}));\nfunction validateSigHash(s) {\n  if (typeof s !== 'number' || typeof SigHash[s] !== 'string') throw new Error(`Invalid SigHash=${s}`);\n  return s;\n}\nfunction unpackSighash(hashType) {\n  const masked = hashType & 0b0011111;\n  return {\n    isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n    isNone: masked === SignatureHash.NONE,\n    isSingle: masked === SignatureHash.SINGLE\n  };\n}\nexport const _sortPubkeys = pubkeys => Array.from(pubkeys).sort(_cmpBytes);\n// Force check index/txid/sequence\nfunction inputBeforeSign(i) {\n  if (i.txid === undefined || i.index === undefined) throw new Error('Transaction/input: txid and index required');\n  return {\n    txid: i.txid,\n    index: i.index,\n    sequence: def(i.sequence, DEFAULT_SEQUENCE),\n    finalScriptSig: def(i.finalScriptSig, P.EMPTY)\n  };\n}\nfunction cleanFinalInput(i) {\n  for (const _k in i) {\n    const k = _k;\n    if (!PSBTInputFinalKeys.includes(k)) delete i[k];\n  }\n}\n// Force check amount/script\nfunction outputBeforeSign(i) {\n  if (i.script === undefined || i.amount === undefined) throw new Error('Transaction/output: script and amount required');\n  return {\n    script: i.script,\n    amount: i.amount\n  };\n}\nexport const TAP_LEAF_VERSION = 0xc0;\nexport const tapLeafHash = (script, version = TAP_LEAF_VERSION) => schnorr.utils.taggedHash('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\nfunction getTaprootKeys(privKey, pubKey, internalKey, merkleRoot = P.EMPTY) {\n  if (P.equalBytes(internalKey, pubKey)) {\n    privKey = taprootTweakPrivKey(privKey, merkleRoot);\n    pubKey = schnorr.getPublicKey(privKey);\n  }\n  return {\n    privKey,\n    pubKey\n  };\n}\nconst toStr = {}.toString;\nfunction validateOpts(opts) {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error(`Wrong object type for transaction options: ${opts}`);\n  const _opts = {\n    ...opts,\n    // Defaults\n    version: def(opts.version, DEFAULT_VERSION),\n    lockTime: def(opts.lockTime, 0),\n    PSBTVersion: def(opts.PSBTVersion, 0)\n  };\n  if (typeof _opts.allowUnknowInput !== 'undefined') opts.allowUnknownInputs = _opts.allowUnknowInput;\n  if (typeof _opts.allowUnknowOutput !== 'undefined') opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n  // 0 and -1 happens in tests\n  if (![-1, 0, 1, 2].includes(_opts.version)) throw new Error(`Unknown version: ${_opts.version}`);\n  if (typeof _opts.lockTime !== 'number') throw new Error('Transaction lock time should be number');\n  P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n  // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n  // can lead to constructing broken transactions\n  if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2) throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n  // Flags\n  for (const k of ['allowUnknownOutputs', 'allowUnknownInputs', 'disableScriptCheck', 'bip174jsCompat', 'allowLegacyWitnessUtxo', 'lowR']) {\n    const v = _opts[k];\n    if (v === undefined) continue; // optional\n    if (typeof v !== 'boolean') throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n  }\n  return Object.freeze(_opts);\n}\nexport class Transaction {\n  constructor(opts = {}) {\n    this.global = {};\n    this.inputs = []; // use getInput()\n    this.outputs = []; // use getOutput()\n    const _opts = this.opts = validateOpts(opts);\n    // Merge with global structure of PSBTv2\n    if (_opts.lockTime !== DEFAULT_LOCKTIME) this.global.fallbackLocktime = _opts.lockTime;\n    this.global.txVersion = _opts.version;\n  }\n  // Import\n  static fromRaw(raw, opts = {}) {\n    const parsed = RawTx.decode(raw);\n    const tx = new Transaction({\n      ...opts,\n      version: parsed.version,\n      lockTime: parsed.lockTime\n    });\n    for (const o of parsed.outputs) tx.addOutput(o);\n    tx.outputs = parsed.outputs;\n    tx.inputs = parsed.inputs;\n    if (parsed.witnesses) {\n      for (let i = 0; i < parsed.witnesses.length; i++) tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n    }\n    return tx;\n  }\n  // PSBT\n  static fromPSBT(psbt, opts = {}) {\n    let parsed;\n    try {\n      parsed = RawPSBTV0.decode(psbt);\n    } catch (e0) {\n      try {\n        parsed = RawPSBTV2.decode(psbt);\n      } catch (e2) {\n        // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n        throw e0;\n      }\n    }\n    const PSBTVersion = parsed.global.version || 0;\n    if (PSBTVersion !== 0 && PSBTVersion !== 2) throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    const unsigned = parsed.global.unsignedTx;\n    const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n    const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n    const tx = new Transaction({\n      ...opts,\n      version,\n      lockTime,\n      PSBTVersion\n    });\n    // We need slice here, because otherwise\n    const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n    tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) => ({\n      finalScriptSig: P.EMPTY,\n      ...parsed.global.unsignedTx?.inputs[j],\n      ...i\n    }));\n    const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n    tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n      ...i,\n      ...parsed.global.unsignedTx?.outputs[j]\n    }));\n    tx.global = {\n      ...parsed.global,\n      txVersion: version\n    }; // just in case proprietary/unknown fields\n    if (lockTime !== DEFAULT_LOCKTIME) tx.global.fallbackLocktime = lockTime;\n    return tx;\n  }\n  toPSBT(PSBTVersion = this.opts.PSBTVersion) {\n    if (PSBTVersion !== 0 && PSBTVersion !== 2) throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    const inputs = this.inputs.map(i => cleanPSBTFields(PSBTVersion, PSBTInput, i));\n    for (const inp of inputs) {\n      // Don't serialize empty fields\n      if (inp.partialSig && !inp.partialSig.length) delete inp.partialSig;\n      if (inp.finalScriptSig && !inp.finalScriptSig.length) delete inp.finalScriptSig;\n      if (inp.finalScriptWitness && !inp.finalScriptWitness.length) delete inp.finalScriptWitness;\n    }\n    const outputs = this.outputs.map(i => cleanPSBTFields(PSBTVersion, PSBTOutput, i));\n    const global = {\n      ...this.global\n    };\n    if (PSBTVersion === 0) {\n      global.unsignedTx = RawTx.decode(this.unsignedTx);\n      delete global.fallbackLocktime;\n      delete global.txVersion;\n    } else {\n      global.version = PSBTVersion;\n      global.txVersion = this.version;\n      global.inputCount = this.inputs.length;\n      global.outputCount = this.outputs.length;\n      if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME) delete global.fallbackLocktime;\n    }\n    if (this.opts.bip174jsCompat) {\n      if (!inputs.length) inputs.push({});\n      if (!outputs.length) outputs.push({});\n    }\n    return (PSBTVersion === 0 ? RawPSBTV0 : RawPSBTV2).encode({\n      global,\n      inputs,\n      outputs\n    });\n  }\n  // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n  get lockTime() {\n    let height = DEFAULT_LOCKTIME;\n    let heightCnt = 0;\n    let time = DEFAULT_LOCKTIME;\n    let timeCnt = 0;\n    for (const i of this.inputs) {\n      if (i.requiredHeightLocktime) {\n        height = Math.max(height, i.requiredHeightLocktime);\n        heightCnt++;\n      }\n      if (i.requiredTimeLocktime) {\n        time = Math.max(time, i.requiredTimeLocktime);\n        timeCnt++;\n      }\n    }\n    if (heightCnt && heightCnt >= timeCnt) return height;\n    if (time !== DEFAULT_LOCKTIME) return time;\n    return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n  }\n  get version() {\n    // Should be not possible\n    if (this.global.txVersion === undefined) throw new Error('No global.txVersion');\n    return this.global.txVersion;\n  }\n  inputStatus(idx) {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    // Finalized\n    if (input.finalScriptSig && input.finalScriptSig.length) return 'finalized';\n    if (input.finalScriptWitness && input.finalScriptWitness.length) return 'finalized';\n    // Signed taproot\n    if (input.tapKeySig) return 'signed';\n    if (input.tapScriptSig && input.tapScriptSig.length) return 'signed';\n    // Signed\n    if (input.partialSig && input.partialSig.length) return 'signed';\n    return 'unsigned';\n  }\n  // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n  // We will lose some vectors -> smaller test coverage of preimages (very important!)\n  inputSighash(idx) {\n    this.checkInputIdx(idx);\n    const sighash = this.inputType(this.inputs[idx]).sighash;\n    // ALL or DEFAULT -- everything signed\n    // NONE           -- all inputs + no outputs\n    // SINGLE         -- all inputs + output with same index\n    // ALL + ANYONE   -- specific input + all outputs\n    // NONE + ANYONE  -- specific input + no outputs\n    // SINGLE         -- specific inputs + output with same index\n    const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n    const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n    return {\n      sigInputs,\n      sigOutputs\n    };\n  }\n  // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n  // Some cache will be nice, but there chance to have bugs with cache invalidation\n  signStatus() {\n    // if addInput or addOutput is not possible, then all inputs or outputs are signed\n    let addInput = true,\n      addOutput = true;\n    let inputs = [],\n      outputs = [];\n    for (let idx = 0; idx < this.inputs.length; idx++) {\n      const status = this.inputStatus(idx);\n      // Unsigned input doesn't affect anything\n      if (status === 'unsigned') continue;\n      const {\n        sigInputs,\n        sigOutputs\n      } = this.inputSighash(idx);\n      // Input type\n      if (sigInputs === SignatureHash.ANYONECANPAY) inputs.push(idx);else addInput = false;\n      // Output type\n      if (sigOutputs === SignatureHash.ALL) addOutput = false;else if (sigOutputs === SignatureHash.SINGLE) outputs.push(idx);else if (sigOutputs === SignatureHash.NONE) {\n        // Doesn't affect any outputs at all\n      } else throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n    }\n    return {\n      addInput,\n      addOutput,\n      inputs,\n      outputs\n    };\n  }\n  get isFinal() {\n    for (let idx = 0; idx < this.inputs.length; idx++) if (this.inputStatus(idx) !== 'finalized') return false;\n    return true;\n  }\n  // Info utils\n  get hasWitnesses() {\n    let out = false;\n    for (const i of this.inputs) if (i.finalScriptWitness && i.finalScriptWitness.length) out = true;\n    return out;\n  }\n  // https://en.bitcoin.it/wiki/Weight_units\n  get weight() {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    // TODO: Can we find out how much witnesses/script will be used before signing?\n    let out = 32;\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (this.hasWitnesses) out += 2;\n    out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n    out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n    for (const i of this.inputs) out += 160 + 4 * VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n    for (const o of outputs) out += 32 + 4 * VarBytes.encode(o.script).length;\n    if (this.hasWitnesses) {\n      for (const i of this.inputs) if (i.finalScriptWitness) out += RawWitness.encode(i.finalScriptWitness).length;\n    }\n    return out;\n  }\n  get vsize() {\n    return Math.ceil(this.weight / 4);\n  }\n  toBytes(withScriptSig = false, withWitness = false) {\n    return RawTx.encode({\n      version: this.version,\n      lockTime: this.lockTime,\n      inputs: this.inputs.map(inputBeforeSign).map(i => ({\n        ...i,\n        finalScriptSig: withScriptSig && i.finalScriptSig || P.EMPTY\n      })),\n      outputs: this.outputs.map(outputBeforeSign),\n      witnesses: this.inputs.map(i => i.finalScriptWitness || []),\n      segwitFlag: withWitness && this.hasWitnesses\n    });\n  }\n  get unsignedTx() {\n    return this.toBytes(false, false);\n  }\n  get hex() {\n    return hex.encode(this.toBytes(true, this.hasWitnesses));\n  }\n  get hash() {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(sha256x2(this.toBytes(true)));\n  }\n  get id() {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(sha256x2(this.toBytes(true)).reverse());\n  }\n  // Input stuff\n  checkInputIdx(idx) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length) throw new Error(`Wrong input index=${idx}`);\n  }\n  getInput(idx) {\n    this.checkInputIdx(idx);\n    return cloneDeep(this.inputs[idx]);\n  }\n  get inputsLength() {\n    return this.inputs.length;\n  }\n  // Modification\n  normalizeInput(i, cur, allowedFields) {\n    let {\n      nonWitnessUtxo,\n      txid\n    } = i;\n    // String support for common fields. We usually prefer Uint8Array to avoid errors (like hex looking string accidentally passed),\n    // however in case of nonWitnessUtxo it is better to expect string, since constructing this complex object will be difficult for user\n    if (typeof nonWitnessUtxo === 'string') nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n    if (isBytes(nonWitnessUtxo)) nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n    if (nonWitnessUtxo === undefined) nonWitnessUtxo = cur?.nonWitnessUtxo;\n    if (typeof txid === 'string') txid = hex.decode(txid);\n    if (txid === undefined) txid = cur?.txid;\n    let res = {\n      ...cur,\n      ...i,\n      nonWitnessUtxo,\n      txid\n    };\n    if (res.nonWitnessUtxo === undefined) delete res.nonWitnessUtxo;\n    if (res.sequence === undefined) res.sequence = DEFAULT_SEQUENCE;\n    if (res.tapMerkleRoot === null) delete res.tapMerkleRoot;\n    res = mergeKeyMap(PSBTInput, res, cur, allowedFields);\n    PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n    let prevOut;\n    if (res.nonWitnessUtxo && res.index !== undefined) prevOut = res.nonWitnessUtxo.outputs[res.index];else if (res.witnessUtxo) prevOut = res.witnessUtxo;\n    if (prevOut && !this.opts.disableScriptCheck) checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n    return res;\n  }\n  addInput(input, _ignoreSignStatus = false) {\n    if (!_ignoreSignStatus && !this.signStatus().addInput) throw new Error('Tx has signed inputs, cannot add new one');\n    this.inputs.push(this.normalizeInput(input));\n    return this.inputs.length - 1;\n  }\n  updateInput(idx, input, _ignoreSignStatus = false) {\n    this.checkInputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addInput || status.inputs.includes(idx)) allowedFields = PSBTInputUnsignedKeys;\n    }\n    this.inputs[idx] = this.normalizeInput(input, this.inputs[idx], allowedFields);\n  }\n  // Output stuff\n  checkOutputIdx(idx) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length) throw new Error(`Wrong output index=${idx}`);\n  }\n  getOutput(idx) {\n    this.checkOutputIdx(idx);\n    return cloneDeep(this.outputs[idx]);\n  }\n  get outputsLength() {\n    return this.outputs.length;\n  }\n  normalizeOutput(o, cur, allowedFields) {\n    let {\n      amount,\n      script\n    } = o;\n    if (amount === undefined) amount = cur?.amount;\n    if (typeof amount !== 'bigint') throw new Error('amount must be bigint sats');\n    if (typeof script === 'string') script = hex.decode(script);\n    if (script === undefined) script = cur?.script;\n    let res = {\n      ...cur,\n      ...o,\n      amount,\n      script\n    };\n    if (res.amount === undefined) delete res.amount;\n    res = mergeKeyMap(PSBTOutput, res, cur, allowedFields);\n    PSBTOutputCoder.encode(res);\n    if (res.script && !this.opts.allowUnknownOutputs && OutScript.decode(res.script).type === 'unknown') {\n      throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownScript=true, if you sure');\n    }\n    if (!this.opts.disableScriptCheck) checkScript(res.script, res.redeemScript, res.witnessScript);\n    return res;\n  }\n  addOutput(o, _ignoreSignStatus = false) {\n    if (!_ignoreSignStatus && !this.signStatus().addOutput) throw new Error('Tx has signed outputs, cannot add new one');\n    this.outputs.push(this.normalizeOutput(o));\n    return this.outputs.length - 1;\n  }\n  updateOutput(idx, output, _ignoreSignStatus = false) {\n    this.checkOutputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addOutput || status.outputs.includes(idx)) allowedFields = PSBTOutputUnsignedKeys;\n    }\n    this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n  }\n  addOutputAddress(address, amount, network = NETWORK) {\n    return this.addOutput({\n      script: OutScript.encode(Address(network).decode(address)),\n      amount\n    });\n  }\n  // Utils\n  get fee() {\n    let res = 0n;\n    for (const i of this.inputs) {\n      const prevOut = this.prevOut(i);\n      if (!prevOut) throw new Error('Empty input amount');\n      res += prevOut.amount;\n    }\n    const outputs = this.outputs.map(outputBeforeSign);\n    for (const o of outputs) res -= o.amount;\n    return res;\n  }\n  // Signing\n  // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n  // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n  // but we are trying to be less complicated for audit purpose for now.\n  preimageLegacy(idx, prevOutScript, hashType) {\n    const {\n      isAny,\n      isNone,\n      isSingle\n    } = unpackSighash(hashType);\n    if (idx < 0 || !Number.isSafeInteger(idx)) throw new Error(`Invalid input idx=${idx}`);\n    if (isSingle && idx >= this.outputs.length || idx >= this.inputs.length) return P.U256BE.encode(1n);\n    prevOutScript = Script.encode(Script.decode(prevOutScript).filter(i => i !== 'CODESEPARATOR'));\n    let inputs = this.inputs.map(inputBeforeSign).map((input, inputIdx) => ({\n      ...input,\n      finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY\n    }));\n    if (isAny) inputs = [inputs[idx]];else if (isNone || isSingle) {\n      inputs = inputs.map((input, inputIdx) => ({\n        ...input,\n        sequence: inputIdx === idx ? input.sequence : 0\n      }));\n    }\n    let outputs = this.outputs.map(outputBeforeSign);\n    if (isNone) outputs = [];else if (isSingle) {\n      outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n    }\n    const tmpTx = RawTx.encode({\n      lockTime: this.lockTime,\n      version: this.version,\n      segwitFlag: false,\n      inputs,\n      outputs\n    });\n    return sha256x2(tmpTx, P.I32LE.encode(hashType));\n  }\n  preimageWitnessV0(idx, prevOutScript, hashType, amount) {\n    const {\n      isAny,\n      isNone,\n      isSingle\n    } = unpackSighash(hashType);\n    let inputHash = EMPTY32;\n    let sequenceHash = EMPTY32;\n    let outputHash = EMPTY32;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (!isAny) inputHash = sha256x2(...inputs.map(TxHashIdx.encode));\n    if (!isAny && !isSingle && !isNone) sequenceHash = sha256x2(...inputs.map(i => P.U32LE.encode(i.sequence)));\n    if (!isSingle && !isNone) {\n      outputHash = sha256x2(...outputs.map(RawOutput.encode));\n    } else if (isSingle && idx < outputs.length) outputHash = sha256x2(RawOutput.encode(outputs[idx]));\n    const input = inputs[idx];\n    return sha256x2(P.I32LE.encode(this.version), inputHash, sequenceHash, P.bytes(32, true).encode(input.txid), P.U32LE.encode(input.index), VarBytes.encode(prevOutScript), P.U64LE.encode(amount), P.U32LE.encode(input.sequence), outputHash, P.U32LE.encode(this.lockTime), P.U32LE.encode(hashType));\n  }\n  preimageWitnessV1(idx, prevOutScript, hashType, amount, codeSeparator = -1, leafScript, leafVer = 0xc0, annex) {\n    if (!Array.isArray(amount) || this.inputs.length !== amount.length) throw new Error(`Invalid amounts array=${amount}`);\n    if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length) throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n    const out = [P.U8.encode(0), P.U8.encode(hashType), P.I32LE.encode(this.version), P.U32LE.encode(this.lockTime)];\n    const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n    const inType = hashType & SignatureHash.ANYONECANPAY;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (inType !== SignatureHash.ANYONECANPAY) {\n      out.push(...[inputs.map(TxHashIdx.encode), amount.map(P.U64LE.encode), prevOutScript.map(VarBytes.encode), inputs.map(i => P.U32LE.encode(i.sequence))].map(i => sha256(concat(...i))));\n    }\n    if (outType === SignatureHash.ALL) {\n      out.push(sha256(concat(...outputs.map(RawOutput.encode))));\n    }\n    const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n    out.push(new Uint8Array([spendType]));\n    if (inType === SignatureHash.ANYONECANPAY) {\n      const inp = inputs[idx];\n      out.push(TxHashIdx.encode(inp), P.U64LE.encode(amount[idx]), VarBytes.encode(prevOutScript[idx]), P.U32LE.encode(inp.sequence));\n    } else out.push(P.U32LE.encode(idx));\n    if (spendType & 1) out.push(sha256(VarBytes.encode(annex || P.EMPTY)));\n    if (outType === SignatureHash.SINGLE) out.push(idx < outputs.length ? sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n    if (leafScript) out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n    return schnorr.utils.taggedHash('TapSighash', ...out);\n  }\n  // Utils for sign/finalize\n  // Used pretty often, should be fast\n  prevOut(input) {\n    if (input.nonWitnessUtxo) {\n      if (input.index === undefined) throw new Error('Unknown input index');\n      return input.nonWitnessUtxo.outputs[input.index];\n    } else if (input.witnessUtxo) return input.witnessUtxo;else throw new Error('Cannot find previous output info');\n  }\n  inputType(input) {\n    let txType = 'legacy';\n    let defaultSighash = SignatureHash.ALL;\n    const prevOut = this.prevOut(input);\n    const first = OutScript.decode(prevOut.script);\n    let type = first.type;\n    let cur = first;\n    const stack = [first];\n    if (first.type === 'tr') {\n      defaultSighash = SignatureHash.DEFAULT;\n      return {\n        txType: 'taproot',\n        type: 'tr',\n        last: first,\n        lastScript: prevOut.script,\n        defaultSighash,\n        sighash: input.sighashType || defaultSighash\n      };\n    } else {\n      if (first.type === 'wpkh' || first.type === 'wsh') txType = 'segwit';\n      if (first.type === 'sh') {\n        if (!input.redeemScript) throw new Error('inputType: sh without redeemScript');\n        let child = OutScript.decode(input.redeemScript);\n        if (child.type === 'wpkh' || child.type === 'wsh') txType = 'segwit';\n        stack.push(child);\n        cur = child;\n        type += `-${child.type}`;\n      }\n      // wsh can be inside sh\n      if (cur.type === 'wsh') {\n        if (!input.witnessScript) throw new Error('inputType: wsh without witnessScript');\n        let child = OutScript.decode(input.witnessScript);\n        if (child.type === 'wsh') txType = 'segwit';\n        stack.push(child);\n        cur = child;\n        type += `-${child.type}`;\n      }\n      const last = stack[stack.length - 1];\n      if (last.type === 'sh' || last.type === 'wsh') throw new Error('inputType: sh/wsh cannot be terminal type');\n      const lastScript = OutScript.encode(last);\n      const res = {\n        type,\n        txType,\n        last,\n        lastScript,\n        defaultSighash,\n        sighash: input.sighashType || defaultSighash\n      };\n      if (txType === 'legacy' && !this.opts.allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n        throw new Error(`Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`);\n      }\n      return res;\n    }\n  }\n  // Signer can be privateKey OR instance of bip32 HD stuff\n  signIdx(privateKey, idx, allowedSighash, _auxRand) {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    const inputType = this.inputType(input);\n    // Handle BIP32 HDKey\n    if (!isBytes(privateKey)) {\n      if (!input.bip32Derivation || !input.bip32Derivation.length) throw new Error('bip32Derivation: empty');\n      const signers = input.bip32Derivation.filter(i => i[1].fingerprint == privateKey.fingerprint).map(([pubKey, {\n        path\n      }]) => {\n        let s = privateKey;\n        for (const i of path) s = s.deriveChild(i);\n        if (!P.equalBytes(s.publicKey, pubKey)) throw new Error('bip32Derivation: wrong pubKey');\n        if (!s.privateKey) throw new Error('bip32Derivation: no privateKey');\n        return s;\n      });\n      if (!signers.length) throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n      let signed = false;\n      for (const s of signers) if (this.signIdx(s.privateKey, idx)) signed = true;\n      return signed;\n    }\n    // Sighash checks\n    // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n    if (!allowedSighash) allowedSighash = [inputType.defaultSighash];else allowedSighash.forEach(validateSigHash);\n    const sighash = inputType.sighash;\n    if (!allowedSighash.includes(sighash)) {\n      throw new Error(`Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`);\n    }\n    // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n    // however this was because of bug in bitcoin-core, which remains here because of consensus.\n    // If this is absolutely neccessary for your case, please open issue.\n    // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n    const {\n      sigOutputs\n    } = this.inputSighash(idx);\n    if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n      throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${idx}`);\n    }\n    // Actual signing\n    // Taproot\n    const prevOut = this.prevOut(input);\n    if (inputType.txType === 'taproot') {\n      if (input.tapBip32Derivation) throw new Error('tapBip32Derivation unsupported');\n      const prevOuts = this.inputs.map(this.prevOut);\n      const prevOutScript = prevOuts.map(i => i.script);\n      const amount = prevOuts.map(i => i.amount);\n      let signed = false;\n      let schnorrPub = schnorr.getPublicKey(privateKey);\n      let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n      if (input.tapInternalKey) {\n        // internal + tweak = tweaked key\n        // if internal key == current public key, we need to tweak private key,\n        // otherwise sign as is. bitcoinjs implementation always wants tweaked\n        // priv key to be provided\n        const {\n          pubKey,\n          privKey\n        } = getTaprootKeys(privateKey, schnorrPub, input.tapInternalKey, merkleRoot);\n        const [taprootPubKey, _] = taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n        if (P.equalBytes(taprootPubKey, pubKey)) {\n          const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n          const sig = concat(schnorr.sign(hash, privKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n          this.updateInput(idx, {\n            tapKeySig: sig\n          }, true);\n          signed = true;\n        }\n      }\n      if (input.tapLeafScript) {\n        input.tapScriptSig = input.tapScriptSig || [];\n        for (const [_, _script] of input.tapLeafScript) {\n          const script = _script.subarray(0, -1);\n          const scriptDecoded = Script.decode(script);\n          const ver = _script[_script.length - 1];\n          const hash = tapLeafHash(script, ver);\n          // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n          const pos = scriptDecoded.findIndex(i => isBytes(i) && P.equalBytes(i, schnorrPub));\n          // Skip if there is no public key in tapLeafScript\n          if (pos === -1) continue;\n          const msg = this.preimageWitnessV1(idx, prevOutScript, sighash, amount, undefined, script, ver);\n          const sig = concat(schnorr.sign(msg, privateKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n          this.updateInput(idx, {\n            tapScriptSig: [[{\n              pubKey: schnorrPub,\n              leafHash: hash\n            }, sig]]\n          }, true);\n          signed = true;\n        }\n      }\n      if (!signed) throw new Error('No taproot scripts signed');\n      return true;\n    } else {\n      // only compressed keys are supported for now\n      const pubKey = _pubECDSA(privateKey);\n      // TODO: replace with explicit checks\n      // Check if script has public key or its has inside\n      let hasPubkey = false;\n      const pubKeyHash = hash160(pubKey);\n      for (const i of Script.decode(inputType.lastScript)) {\n        if (isBytes(i) && (P.equalBytes(i, pubKey) || P.equalBytes(i, pubKeyHash))) hasPubkey = true;\n      }\n      if (!hasPubkey) throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n      let hash;\n      if (inputType.txType === 'legacy') {\n        hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n      } else if (inputType.txType === 'segwit') {\n        let script = inputType.lastScript;\n        // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n        if (inputType.last.type === 'wpkh') script = OutScript.encode({\n          type: 'pkh',\n          hash: inputType.last.hash\n        });\n        hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n      } else throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n      const sig = signECDSA(hash, privateKey, this.opts.lowR);\n      this.updateInput(idx, {\n        partialSig: [[pubKey, concat(sig, new Uint8Array([sighash]))]]\n      }, true);\n    }\n    return true;\n  }\n  // This is bad API. Will work if user creates and signs tx, but if\n  // there is some complex workflow with exchanging PSBT and signing them,\n  // then it is better to validate which output user signs. How could a better API look like?\n  // Example: user adds input, sends to another party, then signs received input (mixer etc),\n  // another user can add different input for same key and user will sign it.\n  // Even worse: another user can add bip32 derivation, and spend money from different address.\n  // Better api: signIdx\n  sign(privateKey, allowedSighash, _auxRand) {\n    let num = 0;\n    for (let i = 0; i < this.inputs.length; i++) {\n      try {\n        if (this.signIdx(privateKey, i, allowedSighash, _auxRand)) num++;\n      } catch (e) {}\n    }\n    if (!num) throw new Error('No inputs signed');\n    return num;\n  }\n  finalizeIdx(idx) {\n    this.checkInputIdx(idx);\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    const input = this.inputs[idx];\n    const inputType = this.inputType(input);\n    // Taproot finalize\n    if (inputType.txType === 'taproot') {\n      if (input.tapKeySig) input.finalScriptWitness = [input.tapKeySig];else if (input.tapLeafScript && input.tapScriptSig) {\n        // Sort leafs by control block length.\n        const leafs = input.tapLeafScript.sort((a, b) => TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length);\n        for (const [cb, _script] of leafs) {\n          // Last byte is version\n          const script = _script.slice(0, -1);\n          const ver = _script[_script.length - 1];\n          const outScript = OutScript.decode(script);\n          const hash = tapLeafHash(script, ver);\n          const scriptSig = input.tapScriptSig.filter(i => P.equalBytes(i[0].leafHash, hash));\n          let signatures = [];\n          if (outScript.type === 'tr_ms') {\n            const m = outScript.m;\n            const pubkeys = outScript.pubkeys;\n            let added = 0;\n            for (const pub of pubkeys) {\n              const sigIdx = scriptSig.findIndex(i => P.equalBytes(i[0].pubKey, pub));\n              // Should have exact amount of signatures (more -- will fail)\n              if (added === m || sigIdx === -1) {\n                signatures.push(P.EMPTY);\n                continue;\n              }\n              signatures.push(scriptSig[sigIdx][1]);\n              added++;\n            }\n            // Should be exact same as m\n            if (added !== m) continue;\n          } else if (outScript.type === 'tr_ns') {\n            for (const pub of outScript.pubkeys) {\n              const sigIdx = scriptSig.findIndex(i => P.equalBytes(i[0].pubKey, pub));\n              if (sigIdx === -1) continue;\n              signatures.push(scriptSig[sigIdx][1]);\n            }\n            if (signatures.length !== outScript.pubkeys.length) continue;\n          } else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n            // Trying our best to sign what we can\n            const scriptDecoded = Script.decode(script);\n            signatures = scriptSig.map(([{\n              pubKey\n            }, signature]) => {\n              const pos = scriptDecoded.findIndex(i => isBytes(i) && P.equalBytes(i, pubKey));\n              if (pos === -1) throw new Error('finalize/taproot: cannot find position of pubkey in script');\n              return {\n                signature,\n                pos\n              };\n            })\n            // Reverse order (because witness is stack and we take last element first from it)\n            .sort((a, b) => a.pos - b.pos).map(i => i.signature);\n            if (!signatures.length) continue;\n          } else throw new Error('Finalize: Unknown tapLeafScript');\n          // Witness is stack, so last element will be used first\n          input.finalScriptWitness = signatures.reverse().concat([script, TaprootControlBlock.encode(cb)]);\n          break;\n        }\n        if (!input.finalScriptWitness) throw new Error('finalize/taproot: empty witness');\n      } else throw new Error('finalize/taproot: unknown input');\n      input.finalScriptSig = P.EMPTY;\n      cleanFinalInput(input);\n      return;\n    }\n    if (!input.partialSig || !input.partialSig.length) throw new Error('Not enough partial sign');\n    let inputScript = P.EMPTY;\n    let witness = [];\n    // TODO: move input scripts closer to payments/output scripts\n    // Multisig\n    if (inputType.last.type === 'ms') {\n      const m = inputType.last.m;\n      const pubkeys = inputType.last.pubkeys;\n      let signatures = [];\n      // partial: [pubkey, sign]\n      for (const pub of pubkeys) {\n        const sign = input.partialSig.find(s => P.equalBytes(pub, s[0]));\n        if (!sign) continue;\n        signatures.push(sign[1]);\n      }\n      signatures = signatures.slice(0, m);\n      if (signatures.length !== m) {\n        throw new Error(`Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`);\n      }\n      inputScript = Script.encode([0, ...signatures]);\n    } else if (inputType.last.type === 'pk') {\n      inputScript = Script.encode([input.partialSig[0][1]]);\n    } else if (inputType.last.type === 'pkh') {\n      inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n    } else if (inputType.last.type === 'wpkh') {\n      inputScript = P.EMPTY;\n      witness = [input.partialSig[0][1], input.partialSig[0][0]];\n    } else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs) throw new Error('Unknown inputs not allowed');\n    // Create final scripts (generic part)\n    let finalScriptSig, finalScriptWitness;\n    if (inputType.type.includes('wsh-')) {\n      // P2WSH\n      if (inputScript.length && inputType.lastScript.length) {\n        witness = Script.decode(inputScript).map(i => {\n          if (i === 0) return P.EMPTY;\n          if (isBytes(i)) return i;\n          throw new Error(`Wrong witness op=${i}`);\n        });\n      }\n      witness = witness.concat(inputType.lastScript);\n    }\n    if (inputType.txType === 'segwit') finalScriptWitness = witness;\n    if (inputType.type.startsWith('sh-wsh-')) {\n      finalScriptSig = Script.encode([Script.encode([0, sha256(inputType.lastScript)])]);\n    } else if (inputType.type.startsWith('sh-')) {\n      finalScriptSig = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n    } else if (inputType.type.startsWith('wsh-')) {} else if (inputType.txType !== 'segwit') finalScriptSig = inputScript;\n    if (!finalScriptSig && !finalScriptWitness) throw new Error('Unknown error finalizing input');\n    if (finalScriptSig) input.finalScriptSig = finalScriptSig;\n    if (finalScriptWitness) input.finalScriptWitness = finalScriptWitness;\n    cleanFinalInput(input);\n  }\n  finalize() {\n    for (let i = 0; i < this.inputs.length; i++) this.finalizeIdx(i);\n  }\n  extract() {\n    if (!this.isFinal) throw new Error('Transaction has unfinalized inputs');\n    if (!this.outputs.length) throw new Error('Transaction has no outputs');\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    return this.toBytes(true, true);\n  }\n  combine(other) {\n    for (const k of ['PSBTVersion', 'version', 'lockTime']) {\n      if (this.opts[k] !== other.opts[k]) {\n        throw new Error(`Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`);\n      }\n    }\n    for (const k of ['inputs', 'outputs']) {\n      if (this[k].length !== other[k].length) {\n        throw new Error(`Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`);\n      }\n    }\n    const thisUnsigned = this.global.unsignedTx ? RawTx.encode(this.global.unsignedTx) : P.EMPTY;\n    const otherUnsigned = other.global.unsignedTx ? RawTx.encode(other.global.unsignedTx) : P.EMPTY;\n    if (!P.equalBytes(thisUnsigned, otherUnsigned)) throw new Error(`Transaction/combine: different unsigned tx`);\n    this.global = mergeKeyMap(PSBTGlobal, this.global, other.global);\n    for (let i = 0; i < this.inputs.length; i++) this.updateInput(i, other.inputs[i], true);\n    for (let i = 0; i < this.outputs.length; i++) this.updateOutput(i, other.outputs[i], true);\n    return this;\n  }\n  clone() {\n    // deepClone probably faster, but this enforces that encoding is valid\n    return Transaction.fromPSBT(this.toPSBT(2), this.opts);\n  }\n}\n// User facing API?\n// Simple pubkey address, without complex scripts\nexport function getAddress(type, privKey, network = NETWORK) {\n  if (type === 'tr') {\n    return p2tr(schnorr.getPublicKey(privKey), undefined, network).address;\n  }\n  const pubKey = _pubECDSA(privKey);\n  if (type === 'pkh') return p2pkh(pubKey, network).address;\n  if (type === 'wpkh') return p2wpkh(pubKey, network).address;\n  throw new Error(`getAddress: unknown type=${type}`);\n}\nexport function multisig(m, pubkeys, sorted = false, witness = false) {\n  const ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n  return witness ? p2wsh(ms) : p2sh(ms);\n}\nexport function sortedMultisig(m, pubkeys, witness = false) {\n  return multisig(m, pubkeys, true, witness);\n}\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET = 0x80000000;\nexport function bip32Path(path) {\n  const out = [];\n  if (!/^[mM]'?/.test(path)) throw new Error('Path must start with \"m\" or \"M\"');\n  if (/^[mM]'?$/.test(path)) return out;\n  const parts = path.replace(/^[mM]'?\\//, '').split('/');\n  for (const c of parts) {\n    const m = /^(\\d+)('?)$/.exec(c);\n    if (!m || m.length !== 3) throw new Error(`Invalid child index: ${c}`);\n    let idx = +m[1];\n    if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) throw new Error('Invalid index');\n    // hardened key\n    if (m[2] === \"'\") idx += HARDENED_OFFSET;\n    out.push(idx);\n  }\n  return out;\n}\nexport function PSBTCombine(psbts) {\n  if (!psbts || !Array.isArray(psbts) || !psbts.length) throw new Error('PSBTCombine: wrong PSBT list');\n  const tx = Transaction.fromPSBT(psbts[0]);\n  for (let i = 1; i < psbts.length; i++) tx.combine(Transaction.fromPSBT(psbts[i]));\n  return tx.toPSBT();\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}