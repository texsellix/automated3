{"ast":null,"code":"\"use strict\";\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar _classCallCheck = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _regeneratorRuntime = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nvar crypto_1 = require(\"@noble/hashes/crypto\");\nvar u8a = function u8a(a) {\n  return a instanceof Uint8Array;\n};\n// Cast array to different type\nvar u8 = function u8(arr) {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n};\nexports.u8 = u8;\nvar u32 = function u32(arr) {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n};\nexports.u32 = u32;\n// Cast array to view\nvar createView = function createView(arr) {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n};\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nvar rotr = function rotr(word, shift) {\n  return word << 32 - shift | word >>> shift;\n};\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE) throw new Error('Non little-endian hardware is not supported');\nvar hexes = /* @__PURE__ */Array.from({\n  length: 256\n}, function (_, i) {\n  return i.toString(16).padStart(2, '0');\n});\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  var hex = '';\n  for (var i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  var len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  var array = new Uint8Array(len / 2);\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    var hexByte = hex.slice(j, j + 2);\n    var byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nvar nextTick = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function nextTick() {\n    return _ref.apply(this, arguments);\n  };\n}();\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nfunction asyncLoop(_x, _x2, _x3) {\n  return _asyncLoop.apply(this, arguments);\n}\nfunction _asyncLoop() {\n  _asyncLoop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iters, tick, cb) {\n    var ts, i, diff;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          ts = Date.now();\n          i = 0;\n        case 2:\n          if (!(i < iters)) {\n            _context2.next = 13;\n            break;\n          }\n          cb(i);\n          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n          diff = Date.now() - ts;\n          if (!(diff >= 0 && diff < tick)) {\n            _context2.next = 7;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 10);\n        case 7:\n          _context2.next = 9;\n          return (0, exports.nextTick)();\n        case 9:\n          ts += diff;\n        case 10:\n          i++;\n          _context2.next = 2;\n          break;\n        case 13:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _asyncLoop.apply(this, arguments);\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(\"utf8ToBytes expected string, got \".concat(typeof str));\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(\"expected Uint8Array, got \".concat(typeof data));\n  return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  var r = new Uint8Array(arrays.reduce(function (sum, a) {\n    return sum + a.length;\n  }, 0));\n  var pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach(function (a) {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nvar Hash = /*#__PURE__*/function () {\n  function Hash() {\n    _classCallCheck(this, Hash);\n  }\n  _createClass(Hash, [{\n    key: \"clone\",\n    value:\n    // Safe version that clones internal state\n    function clone() {\n      return this._cloneInto();\n    }\n  }]);\n  return Hash;\n}();\nexports.Hash = Hash;\nvar toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');\n  var merged = Object.assign(defaults, opts);\n  return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n  var hashC = function hashC(msg) {\n    return hashCons().update(toBytes(msg)).digest();\n  };\n  var tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = function () {\n    return hashCons();\n  };\n  return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n  var hashC = function hashC(msg, opts) {\n    return hashCons(opts).update(toBytes(msg)).digest();\n  };\n  var tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = function (opts) {\n    return hashCons(opts);\n  };\n  return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n  var hashC = function hashC(msg, opts) {\n    return hashCons(opts).update(toBytes(msg)).digest();\n  };\n  var tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = function (opts) {\n    return hashCons(opts);\n  };\n  return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes() {\n  var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n  if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n    return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}