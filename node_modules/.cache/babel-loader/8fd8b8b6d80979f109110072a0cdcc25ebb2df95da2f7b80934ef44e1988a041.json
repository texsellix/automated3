{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenVerifier = void 0;\nvar base64url = require(\"./base64Url\");\nvar cryptoClients_1 = require(\"./cryptoClients\");\nvar errors_1 = require(\"./errors\");\nvar sha256_1 = require(\"./cryptoClients/sha256\");\nvar TokenVerifier = /*#__PURE__*/function () {\n  function TokenVerifier(signingAlgorithm, rawPublicKey) {\n    _classCallCheck(this, TokenVerifier);\n    if (!(signingAlgorithm && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n    }\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPublicKey = rawPublicKey;\n  }\n  _createClass(TokenVerifier, [{\n    key: \"verify\",\n    value: function verify(token) {\n      if (typeof token === 'string') {\n        return this.verifyCompact(token, false);\n      } else if (typeof token === 'object') {\n        return this.verifyExpanded(token, false);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"verifyAsync\",\n    value: function verifyAsync(token) {\n      if (typeof token === 'string') {\n        return this.verifyCompact(token, true);\n      } else if (typeof token === 'object') {\n        return this.verifyExpanded(token, true);\n      } else {\n        return Promise.resolve(false);\n      }\n    }\n  }, {\n    key: \"verifyCompact\",\n    value: function verifyCompact(token, async) {\n      var _this = this;\n      // decompose the token into parts\n      var tokenParts = token.split('.');\n      // calculate the signing input hash\n      var signingInput = tokenParts[0] + '.' + tokenParts[1];\n      var performVerify = function performVerify(signingInputHash) {\n        // extract the signature as a DER array\n        var derSignatureBytes = _this.cryptoClient.loadSignature(tokenParts[2]);\n        // verify the signed hash\n        return _this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, _this.rawPublicKey);\n      };\n      if (async) {\n        return (0, sha256_1.hashSha256Async)(signingInput).then(function (signingInputHash) {\n          return performVerify(signingInputHash);\n        });\n      } else {\n        var signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n        return performVerify(signingInputHash);\n      }\n    }\n  }, {\n    key: \"verifyExpanded\",\n    value: function verifyExpanded(token, async) {\n      var _this2 = this;\n      var signingInput = [token['header'].join('.'), base64url.encode(token['payload'])].join('.');\n      var verified = true;\n      var performVerify = function performVerify(signingInputHash) {\n        token['signature'].map(function (signature) {\n          var derSignatureBytes = _this2.cryptoClient.loadSignature(signature);\n          var signatureVerified = _this2.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, _this2.rawPublicKey);\n          if (!signatureVerified) {\n            verified = false;\n          }\n        });\n        return verified;\n      };\n      if (async) {\n        return (0, sha256_1.hashSha256Async)(signingInput).then(function (signingInputHash) {\n          return performVerify(signingInputHash);\n        });\n      } else {\n        var signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n        return performVerify(signingInputHash);\n      }\n    }\n  }]);\n  return TokenVerifier;\n}();\nexports.TokenVerifier = TokenVerifier;\n//# sourceMappingURL=verifier.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}