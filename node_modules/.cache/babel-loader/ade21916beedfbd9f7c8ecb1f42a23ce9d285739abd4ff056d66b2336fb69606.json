{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SECP256K1Client = void 0;\nvar hmac_1 = require(\"@noble/hashes/hmac\");\nvar sha256_1 = require(\"@noble/hashes/sha256\");\nvar secp = require(\"@noble/secp256k1\");\nvar ecdsaSigFormatter_1 = require(\"../ecdsaSigFormatter\");\nvar errors_1 = require(\"../errors\");\nvar utils_1 = require(\"@noble/hashes/utils\");\n// required to use noble secp https://github.com/paulmillr/noble-secp256k1\nsecp.utils.hmacSha256Sync = function (key) {\n  var h = hmac_1.hmac.create(sha256_1.sha256, key);\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n  msgs.forEach(function (msg) {\n    return h.update(msg);\n  });\n  return h.digest();\n};\nvar SECP256K1Client = /*#__PURE__*/function () {\n  function SECP256K1Client() {\n    _classCallCheck(this, SECP256K1Client);\n  }\n  _createClass(SECP256K1Client, null, [{\n    key: \"derivePublicKey\",\n    value: function derivePublicKey(privateKey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (privateKey.length === 66) {\n        privateKey = privateKey.slice(0, 64);\n      }\n      if (privateKey.length < 64) {\n        // backward compatibly accept too short private keys\n        privateKey = privateKey.padStart(64, '0');\n      }\n      return (0, utils_1.bytesToHex)(secp.getPublicKey(privateKey, compressed));\n    }\n  }, {\n    key: \"signHash\",\n    value: function signHash(signingInputHash, privateKey) {\n      var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'jose';\n      // make sure the required parameters are provided\n      if (!signingInputHash || !privateKey) {\n        throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n      }\n      var derSignature = secp.signSync(signingInputHash, privateKey.slice(0, 64), {\n        der: true,\n        canonical: false\n      });\n      if (format === 'der') return (0, utils_1.bytesToHex)(derSignature);\n      if (format === 'jose') return (0, ecdsaSigFormatter_1.derToJose)(derSignature, 'ES256');\n      throw Error('Invalid signature format');\n    }\n  }, {\n    key: \"loadSignature\",\n    value: function loadSignature(joseSignature) {\n      // create and return the DER-formatted signature bytes\n      return (0, ecdsaSigFormatter_1.joseToDer)(joseSignature, 'ES256');\n    }\n  }, {\n    key: \"verifyHash\",\n    value: function verifyHash(signingInputHash, derSignatureBytes, publicKey) {\n      // make sure the required parameters are provided\n      if (!signingInputHash || !derSignatureBytes || !publicKey) {\n        throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n      }\n      return secp.verify(derSignatureBytes, signingInputHash, publicKey, {\n        strict: false\n      });\n    }\n  }]);\n  return SECP256K1Client;\n}();\nexports.SECP256K1Client = SECP256K1Client;\nSECP256K1Client.algorithmName = 'ES256K';\n//# sourceMappingURL=secp256k1.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}