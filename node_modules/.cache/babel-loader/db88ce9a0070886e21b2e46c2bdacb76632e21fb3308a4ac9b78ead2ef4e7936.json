{"ast":null,"code":"import { base64, hex } from \"@scure/base\";\nimport * as btc from \"@scure/btc-signer\";\nimport { BitcoinNetworkType } from \"sats-connect\";\nexport const getUTXOs = async (network, address) => {\n  const networkSubpath = network === BitcoinNetworkType.Testnet ? \"/testnet\" : \"\";\n  const url = `https://mempool.space${networkSubpath}/api/address/${address}/utxo`;\n  const response = await fetch(url);\n  return response.json();\n};\nexport const createPSBT = async (networkType, paymentPublicKeyString, ordinalsPublicKeyString, paymentUnspentOutputs, ordinalsUnspentOutputs, recipient1, recipient2) => {\n  const network = networkType === BitcoinNetworkType.Testnet ? btc.TEST_NETWORK : btc.NETWORK;\n\n  // choose first unspent output\n  const paymentOutput = paymentUnspentOutputs[0];\n  const ordinalOutput = ordinalsUnspentOutputs[0];\n  const paymentPublicKey = hex.decode(paymentPublicKeyString);\n  const ordinalPublicKey = hex.decode(ordinalsPublicKeyString);\n  const tx = new btc.Transaction({\n    allowUnknownOutputs: true\n  });\n\n  // create segwit spend\n  const p2wpkh = btc.p2wpkh(paymentPublicKey, network);\n  const p2sh = btc.p2sh(p2wpkh, network);\n\n  // create taproot spend\n  const p2tr = btc.p2tr(ordinalPublicKey, undefined, network);\n\n  // set transfer amount and calculate change\n  const fee = 300n; // set the miner fee amount\n  const recipient1Amount = BigInt(Math.min(paymentOutput.value, 3000)) - fee;\n  const recipient2Amount = BigInt(Math.min(ordinalOutput.value, 3000));\n  const total = recipient1Amount + recipient2Amount;\n  const changeAmount = BigInt(paymentOutput.value) + BigInt(ordinalOutput.value) - total - fee;\n\n  // payment input\n  tx.addInput({\n    txid: paymentOutput.txid,\n    index: paymentOutput.vout,\n    witnessUtxo: {\n      script: p2sh.script ? p2sh.script : Buffer.alloc(0),\n      amount: BigInt(paymentOutput.value)\n    },\n    redeemScript: p2sh.redeemScript ? p2sh.redeemScript : Buffer.alloc(0),\n    witnessScript: p2sh.witnessScript,\n    sighashType: btc.SignatureHash.SINGLE | btc.SignatureHash.ANYONECANPAY\n  });\n\n  // ordinals input\n  tx.addInput({\n    txid: ordinalOutput.txid,\n    index: ordinalOutput.vout,\n    witnessUtxo: {\n      script: p2tr.script,\n      amount: BigInt(ordinalOutput.value)\n    },\n    tapInternalKey: ordinalPublicKey,\n    sighashType: btc.SignatureHash.SINGLE | btc.SignatureHash.ANYONECANPAY\n  });\n  tx.addOutputAddress(recipient1, recipient1Amount, network);\n  tx.addOutputAddress(recipient2, recipient2Amount, network);\n  tx.addOutputAddress(recipient2, changeAmount, network);\n  tx.addOutput({\n    script: btc.Script.encode([\"HASH160\", \"DUP\", new TextEncoder().encode(\"SP1KSN9GZ21F4B3DZD4TQ9JZXKFTZE3WW5GXREQKX\")]),\n    amount: 0n\n  });\n  const psbt = tx.toPSBT(0);\n  const psbtB64 = base64.encode(psbt);\n  return psbtB64;\n};","map":{"version":3,"names":["base64","hex","btc","BitcoinNetworkType","getUTXOs","network","address","networkSubpath","Testnet","url","response","fetch","json","createPSBT","networkType","paymentPublicKeyString","ordinalsPublicKeyString","paymentUnspentOutputs","ordinalsUnspentOutputs","recipient1","recipient2","TEST_NETWORK","NETWORK","paymentOutput","ordinalOutput","paymentPublicKey","decode","ordinalPublicKey","tx","Transaction","allowUnknownOutputs","p2wpkh","p2sh","p2tr","undefined","fee","recipient1Amount","BigInt","Math","min","value","recipient2Amount","total","changeAmount","addInput","txid","index","vout","witnessUtxo","script","Buffer","alloc","amount","redeemScript","witnessScript","sighashType","SignatureHash","SINGLE","ANYONECANPAY","tapInternalKey","addOutputAddress","addOutput","Script","encode","TextEncoder","psbt","toPSBT","psbtB64"],"sources":["/Users/metehan/Downloads/ord/sats-connect-example-main/src/utils.ts"],"sourcesContent":["import { base64, hex } from \"@scure/base\";\nimport * as btc from \"@scure/btc-signer\";\n\nimport { BitcoinNetworkType } from \"sats-connect\";\n\nexport type UTXO = {\n  txid: string;\n  vout: number;\n  status: {\n    confirmed: boolean;\n    block_height?: number;\n    block_hash?: string;\n    block_time?: number;\n  };\n  value: number;\n};\n\nexport const getUTXOs = async (\n  network: BitcoinNetworkType,\n  address: string\n): Promise<UTXO[]> => {\n  const networkSubpath =\n    network === BitcoinNetworkType.Testnet ? \"/testnet\" : \"\";\n\n  const url = `https://mempool.space${networkSubpath}/api/address/${address}/utxo`;\n  const response = await fetch(url);\n\n  return response.json();\n};\n\nexport const createPSBT = async (\n  networkType: BitcoinNetworkType,\n  paymentPublicKeyString: string,\n  ordinalsPublicKeyString: string,\n  paymentUnspentOutputs: UTXO[],\n  ordinalsUnspentOutputs: UTXO[],\n  recipient1: string,\n  recipient2: string\n) => {\n  const network =\n    networkType === BitcoinNetworkType.Testnet ? btc.TEST_NETWORK : btc.NETWORK;\n\n  // choose first unspent output\n  const paymentOutput = paymentUnspentOutputs[0];\n  const ordinalOutput = ordinalsUnspentOutputs[0];\n\n  const paymentPublicKey = hex.decode(paymentPublicKeyString);\n  const ordinalPublicKey = hex.decode(ordinalsPublicKeyString);\n\n  const tx = new btc.Transaction({\n    allowUnknownOutputs: true,\n  });\n\n  // create segwit spend\n  const p2wpkh = btc.p2wpkh(paymentPublicKey, network);\n  const p2sh = btc.p2sh(p2wpkh, network);\n\n  // create taproot spend\n  const p2tr = btc.p2tr(ordinalPublicKey, undefined, network);\n\n  // set transfer amount and calculate change\n  const fee = 300n; // set the miner fee amount\n  const recipient1Amount = BigInt(Math.min(paymentOutput.value, 3000)) - fee;\n  const recipient2Amount = BigInt(Math.min(ordinalOutput.value, 3000));\n  const total = recipient1Amount + recipient2Amount;\n  const changeAmount =\n    BigInt(paymentOutput.value) + BigInt(ordinalOutput.value) - total - fee;\n\n  // payment input\n  tx.addInput({\n    txid: paymentOutput.txid,\n    index: paymentOutput.vout,\n    witnessUtxo: {\n      script: p2sh.script ? p2sh.script : Buffer.alloc(0),\n      amount: BigInt(paymentOutput.value),\n    },\n    redeemScript: p2sh.redeemScript ? p2sh.redeemScript : Buffer.alloc(0),\n    witnessScript: p2sh.witnessScript,\n    sighashType: btc.SignatureHash.SINGLE | btc.SignatureHash.ANYONECANPAY,\n  });\n\n  // ordinals input\n  tx.addInput({\n    txid: ordinalOutput.txid,\n    index: ordinalOutput.vout,\n    witnessUtxo: {\n      script: p2tr.script,\n      amount: BigInt(ordinalOutput.value),\n    },\n    tapInternalKey: ordinalPublicKey,\n    sighashType: btc.SignatureHash.SINGLE | btc.SignatureHash.ANYONECANPAY,\n  });\n\n  tx.addOutputAddress(recipient1, recipient1Amount, network);\n  tx.addOutputAddress(recipient2, recipient2Amount, network);\n  tx.addOutputAddress(recipient2, changeAmount, network);\n\n  tx.addOutput({\n    script: btc.Script.encode([\n      \"HASH160\",\n      \"DUP\",\n      new TextEncoder().encode(\"SP1KSN9GZ21F4B3DZD4TQ9JZXKFTZE3WW5GXREQKX\"),\n    ]),\n    amount: 0n,\n  });\n\n  const psbt = tx.toPSBT(0);\n  const psbtB64 = base64.encode(psbt);\n  return psbtB64;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}