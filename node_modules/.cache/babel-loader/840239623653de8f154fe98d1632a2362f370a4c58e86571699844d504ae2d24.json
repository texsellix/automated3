{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenSigner = exports.createUnsecuredToken = void 0;\nvar base64url = require(\"./base64Url\");\nvar cryptoClients_1 = require(\"./cryptoClients\");\nvar errors_1 = require(\"./errors\");\nvar sha256_1 = require(\"./cryptoClients/sha256\");\nfunction createSigningInput(payload, header) {\n  var tokenParts = [];\n  // add in the header\n  var encodedHeader = base64url.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader);\n  // add in the payload\n  var encodedPayload = base64url.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload);\n  // prepare the message\n  var signingInput = tokenParts.join('.');\n  // return the signing input\n  return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n  var header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nvar TokenSigner = /*#__PURE__*/function () {\n  function TokenSigner(signingAlgorithm, rawPrivateKey) {\n    _classCallCheck(this, TokenSigner);\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n  _createClass(TokenSigner, [{\n    key: \"header\",\n    value: function header() {\n      var _header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var defaultHeader = {\n        typ: this.tokenType,\n        alg: this.cryptoClient.algorithmName\n      };\n      return Object.assign({}, defaultHeader, _header);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(payload) {\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      // generate the token header\n      var header = this.header(customHeader);\n      // prepare the message to be signed\n      var signingInput = createSigningInput(payload, header);\n      var signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n      return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    }\n  }, {\n    key: \"signAsync\",\n    value: function signAsync(payload) {\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var header, signingInput, signingInputHash;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // generate the token header\n              header = this.header(customHeader); // prepare the message to be signed\n              signingInput = createSigningInput(payload, header);\n              _context.next = 4;\n              return (0, sha256_1.hashSha256Async)(signingInput);\n            case 4:\n              signingInputHash = _context.sent;\n              return _context.abrupt(\"return\", this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash));\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"createWithSignedHash\",\n    value: function createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n      // sign the message and add in the signature\n      var signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n      if (expanded) {\n        var signedToken = {\n          header: [base64url.encode(JSON.stringify(header))],\n          payload: JSON.stringify(payload),\n          signature: [signature]\n        };\n        return signedToken;\n      } else {\n        return [signingInput, signature].join('.');\n      }\n    }\n  }]);\n  return TokenSigner;\n}();\nexports.TokenSigner = TokenSigner;\n//# sourceMappingURL=signer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}