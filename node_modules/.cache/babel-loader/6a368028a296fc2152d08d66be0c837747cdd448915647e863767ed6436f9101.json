{"ast":null,"code":"import _toConsumableArray from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  var _32n = BigInt(32);\n  var _u32_max = BigInt(0xffffffff);\n  var wh = Number(value >> _32n & _u32_max);\n  var wl = Number(value & _u32_max);\n  var h = isLE ? 4 : 0;\n  var l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport var SHA2 = /*#__PURE__*/function (_Hash) {\n  _inherits(SHA2, _Hash);\n  var _super = _createSuper(SHA2);\n  function SHA2(blockLen, outputLen, padOffset, isLE) {\n    var _this;\n    _classCallCheck(this, SHA2);\n    _this = _super.call(this);\n    _this.blockLen = blockLen;\n    _this.outputLen = outputLen;\n    _this.padOffset = padOffset;\n    _this.isLE = isLE;\n    _this.finished = false;\n    _this.length = 0;\n    _this.pos = 0;\n    _this.destroyed = false;\n    _this.buffer = new Uint8Array(blockLen);\n    _this.view = createView(_this.buffer);\n    return _this;\n  }\n  _createClass(SHA2, [{\n    key: \"update\",\n    value: function update(data) {\n      exists(this);\n      var view = this.view,\n        buffer = this.buffer,\n        blockLen = this.blockLen;\n      data = toBytes(data);\n      var len = data.length;\n      for (var pos = 0; pos < len;) {\n        var take = Math.min(blockLen - this.pos, len - pos);\n        // Fast path: we have at least one block in input, cast it to view and process\n        if (take === blockLen) {\n          var dataView = createView(data);\n          for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n          continue;\n        }\n        buffer.set(data.subarray(pos, pos + take), this.pos);\n        this.pos += take;\n        pos += take;\n        if (this.pos === blockLen) {\n          this.process(view, 0);\n          this.pos = 0;\n        }\n      }\n      this.length += data.length;\n      this.roundClean();\n      return this;\n    }\n  }, {\n    key: \"digestInto\",\n    value: function digestInto(out) {\n      exists(this);\n      output(out, this);\n      this.finished = true;\n      // Padding\n      // We can avoid allocation of buffer for padding completely if it\n      // was previously not allocated here. But it won't change performance.\n      var buffer = this.buffer,\n        view = this.view,\n        blockLen = this.blockLen,\n        isLE = this.isLE;\n      var pos = this.pos;\n      // append the bit '1' to the message\n      buffer[pos++] = 128;\n      this.buffer.subarray(pos).fill(0);\n      // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n      if (this.padOffset > blockLen - pos) {\n        this.process(view, 0);\n        pos = 0;\n      }\n      // Pad until full block byte with zeros\n      for (var i = pos; i < blockLen; i++) buffer[i] = 0;\n      // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n      // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n      // So we just write lowest 64 bits of that value.\n      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n      this.process(view, 0);\n      var oview = createView(out);\n      var len = this.outputLen;\n      // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n      if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n      var outLen = len / 4;\n      var state = this.get();\n      if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n      for (var _i = 0; _i < outLen; _i++) oview.setUint32(4 * _i, state[_i], isLE);\n    }\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      var buffer = this.buffer,\n        outputLen = this.outputLen;\n      this.digestInto(buffer);\n      var res = buffer.slice(0, outputLen);\n      this.destroy();\n      return res;\n    }\n  }, {\n    key: \"_cloneInto\",\n    value: function _cloneInto(to) {\n      var _to;\n      to || (to = new this.constructor());\n      (_to = to).set.apply(_to, _toConsumableArray(this.get()));\n      var blockLen = this.blockLen,\n        buffer = this.buffer,\n        length = this.length,\n        finished = this.finished,\n        destroyed = this.destroyed,\n        pos = this.pos;\n      to.length = length;\n      to.pos = pos;\n      to.finished = finished;\n      to.destroyed = destroyed;\n      if (length % blockLen) to.buffer.set(buffer);\n      return to;\n    }\n  }]);\n  return SHA2;\n}(Hash);\n//# sourceMappingURL=_sha2.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}