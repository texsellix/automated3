{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenVerifier = void 0;\nconst base64url = require(\"./base64Url\");\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nconst sha256_1 = require(\"./cryptoClients/sha256\");\nclass TokenVerifier {\n  constructor(signingAlgorithm, rawPublicKey) {\n    if (!(signingAlgorithm && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n    }\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPublicKey = rawPublicKey;\n  }\n  verify(token) {\n    if (typeof token === 'string') {\n      return this.verifyCompact(token, false);\n    } else if (typeof token === 'object') {\n      return this.verifyExpanded(token, false);\n    } else {\n      return false;\n    }\n  }\n  verifyAsync(token) {\n    if (typeof token === 'string') {\n      return this.verifyCompact(token, true);\n    } else if (typeof token === 'object') {\n      return this.verifyExpanded(token, true);\n    } else {\n      return Promise.resolve(false);\n    }\n  }\n  verifyCompact(token, async) {\n    // decompose the token into parts\n    const tokenParts = token.split('.');\n    // calculate the signing input hash\n    const signingInput = tokenParts[0] + '.' + tokenParts[1];\n    const performVerify = signingInputHash => {\n      // extract the signature as a DER array\n      const derSignatureBytes = this.cryptoClient.loadSignature(tokenParts[2]);\n      // verify the signed hash\n      return this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);\n    };\n    if (async) {\n      return (0, sha256_1.hashSha256Async)(signingInput).then(signingInputHash => performVerify(signingInputHash));\n    } else {\n      const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n      return performVerify(signingInputHash);\n    }\n  }\n  verifyExpanded(token, async) {\n    const signingInput = [token['header'].join('.'), base64url.encode(token['payload'])].join('.');\n    let verified = true;\n    const performVerify = signingInputHash => {\n      token['signature'].map(signature => {\n        const derSignatureBytes = this.cryptoClient.loadSignature(signature);\n        const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);\n        if (!signatureVerified) {\n          verified = false;\n        }\n      });\n      return verified;\n    };\n    if (async) {\n      return (0, sha256_1.hashSha256Async)(signingInput).then(signingInputHash => performVerify(signingInputHash));\n    } else {\n      const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n      return performVerify(signingInputHash);\n    }\n  }\n}\nexports.TokenVerifier = TokenVerifier;\n//# sourceMappingURL=verifier.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}