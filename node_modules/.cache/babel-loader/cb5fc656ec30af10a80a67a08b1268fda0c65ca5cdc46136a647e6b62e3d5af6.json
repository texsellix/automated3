{"ast":null,"code":"import * as base from '@scure/base';\nexport const EMPTY = new Uint8Array();\nexport const NULL = new Uint8Array([0]);\nexport function equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\nexport function concatBytes(...arrays) {\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nexport const isBytes = b => b instanceof Uint8Array;\nexport class Reader {\n  constructor(data, path = [], fieldPath = []) {\n    this.data = data;\n    this.path = path;\n    this.fieldPath = fieldPath;\n    this.pos = 0;\n    this.hasPtr = false;\n    this.bitBuf = 0;\n    this.bitPos = 0;\n  }\n  err(msg) {\n    return new Error(`Reader(${this.fieldPath.join('/')}): ${msg}`);\n  }\n  absBytes(n) {\n    if (n > this.data.length) throw new Error('absBytes: Unexpected end of buffer');\n    return this.data.subarray(n);\n  }\n  bytes(n, peek = false) {\n    if (this.bitPos) throw this.err('readBytes: bitPos not empty');\n    if (!Number.isFinite(n)) throw this.err(`readBytes: wrong length=${n}`);\n    if (this.pos + n > this.data.length) throw this.err('readBytes: Unexpected end of buffer');\n    const slice = this.data.subarray(this.pos, this.pos + n);\n    if (!peek) this.pos += n;\n    return slice;\n  }\n  byte(peek = false) {\n    if (this.bitPos) throw this.err('readByte: bitPos not empty');\n    return this.data[peek ? this.pos : this.pos++];\n  }\n  get leftBytes() {\n    return this.data.length - this.pos;\n  }\n  isEnd() {\n    return this.pos >= this.data.length && !this.bitPos;\n  }\n  length(len) {\n    let byteLen;\n    if (isCoder(len)) byteLen = Number(len.decodeStream(this));else if (typeof len === 'number') byteLen = len;else if (typeof len === 'string') byteLen = getPath(this.path, len.split('/'));\n    if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n    if (typeof byteLen !== 'number') throw this.err(`Wrong length: ${byteLen}`);\n    return byteLen;\n  }\n  bits(bits) {\n    if (bits > 32) throw this.err('BitReader: cannot read more than 32 bits in single call');\n    let out = 0;\n    while (bits) {\n      if (!this.bitPos) {\n        this.bitBuf = this.data[this.pos++];\n        this.bitPos = 8;\n      }\n      const take = Math.min(bits, this.bitPos);\n      this.bitPos -= take;\n      out = out << take | this.bitBuf >> this.bitPos & 2 ** take - 1;\n      this.bitBuf &= 2 ** this.bitPos - 1;\n      bits -= take;\n    }\n    return out >>> 0;\n  }\n  find(needle, pos = this.pos) {\n    if (!isBytes(needle)) throw this.err(`find: needle is not bytes! ${needle}`);\n    if (this.bitPos) throw this.err('findByte: bitPos not empty');\n    if (!needle.length) throw this.err(`find: needle is empty`);\n    for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n      if (idx === -1) return;\n      const leftBytes = this.data.length - idx;\n      if (leftBytes < needle.length) return;\n      if (equalBytes(needle, this.data.subarray(idx, idx + needle.length))) return idx;\n    }\n  }\n  finish() {\n    if (this.isEnd() || this.hasPtr) return;\n    throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${base.hex.encode(this.data.slice(this.pos))}`);\n  }\n  fieldPathPush(s) {\n    this.fieldPath.push(s);\n  }\n  fieldPathPop() {\n    this.fieldPath.pop();\n  }\n}\nexport class Writer {\n  constructor(path = [], fieldPath = []) {\n    this.path = path;\n    this.fieldPath = fieldPath;\n    this.buffers = [];\n    this.pos = 0;\n    this.ptrs = [];\n    this.bitBuf = 0;\n    this.bitPos = 0;\n  }\n  err(msg) {\n    return new Error(`Writer(${this.fieldPath.join('/')}): ${msg}`);\n  }\n  bytes(b) {\n    if (this.bitPos) throw this.err('writeBytes: ends with non-empty bit buffer');\n    this.buffers.push(b);\n    this.pos += b.length;\n  }\n  byte(b) {\n    if (this.bitPos) throw this.err('writeByte: ends with non-empty bit buffer');\n    this.buffers.push(new Uint8Array([b]));\n    this.pos++;\n  }\n  get buffer() {\n    if (this.bitPos) throw this.err('buffer: ends with non-empty bit buffer');\n    let buf = concatBytes(...this.buffers);\n    for (let ptr of this.ptrs) {\n      const pos = buf.length;\n      buf = concatBytes(buf, ptr.buffer);\n      const val = ptr.ptr.encode(pos);\n      for (let i = 0; i < val.length; i++) buf[ptr.pos + i] = val[i];\n    }\n    return buf;\n  }\n  length(len, value) {\n    if (len === null) return;\n    if (isCoder(len)) return len.encodeStream(this, value);\n    let byteLen;\n    if (typeof len === 'number') byteLen = len;else if (typeof len === 'string') byteLen = getPath(this.path, len.split('/'));\n    if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n    if (byteLen === undefined || byteLen !== value) throw this.err(`Wrong length: ${byteLen} len=${len} exp=${value}`);\n  }\n  bits(value, bits) {\n    if (bits > 32) throw this.err('writeBits: cannot write more than 32 bits in single call');\n    if (value >= 2 ** bits) throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n    while (bits) {\n      const take = Math.min(bits, 8 - this.bitPos);\n      this.bitBuf = this.bitBuf << take | value >> bits - take;\n      this.bitPos += take;\n      bits -= take;\n      value &= 2 ** bits - 1;\n      if (this.bitPos === 8) {\n        this.bitPos = 0;\n        this.buffers.push(new Uint8Array([this.bitBuf]));\n        this.pos++;\n      }\n    }\n  }\n  fieldPathPush(s) {\n    this.fieldPath.push(s);\n  }\n  fieldPathPop() {\n    this.fieldPath.pop();\n  }\n}\nconst swap = b => Uint8Array.from(b).reverse();\nexport function checkBounds(p, value, bits, signed) {\n  if (signed) {\n    const signBit = 2n ** (bits - 1n);\n    if (value < -signBit || value >= signBit) throw p.err('sInt: value out of bounds');\n  } else {\n    if (0n > value || value >= 2n ** bits) throw p.err('uInt: value out of bounds');\n  }\n}\nexport function wrap(inner) {\n  return {\n    ...inner,\n    encode: value => {\n      const w = new Writer();\n      inner.encodeStream(w, value);\n      return w.buffer;\n    },\n    decode: data => {\n      const r = new Reader(data);\n      const res = inner.decodeStream(r);\n      r.finish();\n      return res;\n    }\n  };\n}\nfunction getPath(objPath, path) {\n  objPath = Array.from(objPath);\n  let i = 0;\n  for (; i < path.length; i++) {\n    if (path[i] === '..') objPath.pop();else break;\n  }\n  let cur = objPath.pop();\n  for (; i < path.length; i++) {\n    if (!cur || cur[path[i]] === undefined) return undefined;\n    cur = cur[path[i]];\n  }\n  return cur;\n}\nexport function isCoder(elm) {\n  return typeof elm.encode === 'function' && typeof elm.encodeStream === 'function' && typeof elm.decode === 'function' && typeof elm.decodeStream === 'function';\n}\nfunction dict() {\n  return {\n    encode: from => {\n      const to = {};\n      for (const [name, value] of from) {\n        if (to[name] !== undefined) throw new Error(`coders.dict: same key(${name}) appears twice in struct`);\n        to[name] = value;\n      }\n      return to;\n    },\n    decode: to => Object.entries(to)\n  };\n}\nconst number = {\n  encode: from => {\n    if (from > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${from}`);\n    return Number(from);\n  },\n  decode: to => BigInt(to)\n};\nfunction tsEnum(e) {\n  return {\n    encode: from => e[from],\n    decode: to => e[to]\n  };\n}\nfunction decimal(precision) {\n  const decimalMask = 10n ** BigInt(precision);\n  return {\n    encode: from => {\n      let s = (from < 0n ? -from : from).toString(10);\n      let sep = s.length - precision;\n      if (sep < 0) {\n        s = s.padStart(s.length - sep, '0');\n        sep = 0;\n      }\n      let i = s.length - 1;\n      for (; i >= sep && s[i] === '0'; i--);\n      let [int, frac] = [s.slice(0, sep), s.slice(sep, i + 1)];\n      if (!int) int = '0';\n      if (from < 0n) int = '-' + int;\n      if (!frac) return int;\n      return `${int}.${frac}`;\n    },\n    decode: to => {\n      let neg = false;\n      if (to.startsWith('-')) {\n        neg = true;\n        to = to.slice(1);\n      }\n      let sep = to.indexOf('.');\n      sep = sep === -1 ? to.length : sep;\n      const [intS, fracS] = [to.slice(0, sep), to.slice(sep + 1)];\n      const int = BigInt(intS) * decimalMask;\n      const fracLen = Math.min(fracS.length, precision);\n      const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n      const value = int + frac;\n      return neg ? -value : value;\n    }\n  };\n}\nfunction match(lst) {\n  return {\n    encode: from => {\n      for (const c of lst) {\n        const elm = c.encode(from);\n        if (elm !== undefined) return elm;\n      }\n      throw new Error(`match/encode: cannot find match in ${from}`);\n    },\n    decode: to => {\n      for (const c of lst) {\n        const elm = c.decode(to);\n        if (elm !== undefined) return elm;\n      }\n      throw new Error(`match/decode: cannot find match in ${to}`);\n    }\n  };\n}\nexport const coders = {\n  dict,\n  number,\n  tsEnum,\n  decimal,\n  match\n};\nexport const bits = len => wrap({\n  encodeStream: (w, value) => w.bits(value, len),\n  decodeStream: r => r.bits(len)\n});\nexport const bigint = (size, le = false, signed = false) => wrap({\n  size,\n  encodeStream: (w, value) => {\n    if (typeof value !== 'number' && typeof value !== 'bigint') throw w.err(`bigint: invalid value: ${value}`);\n    let _value = BigInt(value);\n    const bLen = BigInt(size);\n    checkBounds(w, _value, 8n * bLen, !!signed);\n    const signBit = 2n ** (8n * bLen - 1n);\n    if (signed && _value < 0) _value = _value | signBit;\n    let b = [];\n    for (let i = 0; i < size; i++) {\n      b.push(Number(_value & 255n));\n      _value >>= 8n;\n    }\n    let res = new Uint8Array(b).reverse();\n    w.bytes(le ? res.reverse() : res);\n  },\n  decodeStream: r => {\n    const bLen = BigInt(size);\n    let value = r.bytes(size);\n    if (le) value = swap(value);\n    const b = swap(value);\n    const signBit = 2n ** (8n * bLen - 1n);\n    let res = 0n;\n    for (let i = 0; i < b.length; i++) res |= BigInt(b[i]) << 8n * BigInt(i);\n    if (signed && res & signBit) res = (res ^ signBit) - signBit;\n    checkBounds(r, res, 8n * bLen, !!signed);\n    return res;\n  }\n});\nexport const U256LE = bigint(32, true);\nexport const U256BE = bigint(32, false);\nexport const I256LE = bigint(32, true, true);\nexport const I256BE = bigint(32, false, true);\nexport const U128LE = bigint(16, true);\nexport const U128BE = bigint(16, false);\nexport const I128LE = bigint(16, true, true);\nexport const I128BE = bigint(16, false, true);\nexport const U64LE = bigint(8, true);\nexport const U64BE = bigint(8, false);\nexport const I64LE = bigint(8, true, true);\nexport const I64BE = bigint(8, false, true);\nexport const int = (size, le = false, signed = false) => {\n  if (size > 6) throw new Error('int supports size up to 6 bytes (48 bits), for other use bigint');\n  return apply(bigint(size, le, signed), coders.number);\n};\nexport const U32LE = int(4, true);\nexport const U32BE = int(4, false);\nexport const I32LE = int(4, true, true);\nexport const I32BE = int(4, false, true);\nexport const U16LE = int(2, true);\nexport const U16BE = int(2, false);\nexport const I16LE = int(2, true, true);\nexport const I16BE = int(2, false, true);\nexport const U8 = int(1, false);\nexport const I8 = int(1, false, true);\nexport const bool = wrap({\n  size: 1,\n  encodeStream: (w, value) => w.byte(value ? 1 : 0),\n  decodeStream: r => {\n    const value = r.byte();\n    if (value !== 0 && value !== 1) throw r.err(`bool: invalid value ${value}`);\n    return value === 1;\n  }\n});\nexport const bytes = (len, le = false) => wrap({\n  size: typeof len === 'number' ? len : undefined,\n  encodeStream: (w, value) => {\n    if (!isBytes(value)) throw w.err(`bytes: invalid value ${value}`);\n    if (!isBytes(len)) w.length(len, value.length);\n    w.bytes(le ? swap(value) : value);\n    if (isBytes(len)) w.bytes(len);\n  },\n  decodeStream: r => {\n    let bytes;\n    if (isBytes(len)) {\n      const tPos = r.find(len);\n      if (!tPos) throw r.err(`bytes: cannot find terminator`);\n      bytes = r.bytes(tPos - r.pos);\n      r.bytes(len.length);\n    } else bytes = r.bytes(len === null ? r.leftBytes : r.length(len));\n    return le ? swap(bytes) : bytes;\n  }\n});\nexport const string = (len, le = false) => {\n  const inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, base.utf8.decode(value)),\n    decodeStream: r => base.utf8.encode(inner.decodeStream(r))\n  });\n};\nexport const cstring = string(NULL);\nexport const hex = (len, le = false, withZero = false) => {\n  const inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => {\n      if (withZero && !value.startsWith('0x')) throw new Error('hex(withZero=true).encode input should start with 0x');\n      const bytes = base.hex.decode(withZero ? value.slice(2) : value);\n      return inner.encodeStream(w, bytes);\n    },\n    decodeStream: r => (withZero ? '0x' : '') + base.hex.encode(inner.decodeStream(r))\n  });\n};\nexport function apply(inner, b) {\n  if (!isCoder(inner)) throw new Error(`apply: invalid inner value ${inner}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => {\n      let innerValue;\n      try {\n        innerValue = b.decode(value);\n      } catch (e) {\n        throw w.err('' + e);\n      }\n      return inner.encodeStream(w, innerValue);\n    },\n    decodeStream: r => {\n      const innerValue = inner.decodeStream(r);\n      try {\n        return b.encode(innerValue);\n      } catch (e) {\n        throw r.err('' + e);\n      }\n    }\n  });\n}\nexport function validate(inner, fn) {\n  if (!isCoder(inner)) throw new Error(`validate: invalid inner value ${inner}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, fn(value)),\n    decodeStream: r => fn(inner.decodeStream(r))\n  });\n}\nexport function lazy(fn) {\n  return wrap({\n    encodeStream: (w, value) => fn().encodeStream(w, value),\n    decodeStream: r => fn().decodeStream(r)\n  });\n}\nexport const bytesFormatted = (len, fmt, le = false) => {\n  const inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, base.bytes(fmt, value)),\n    decodeStream: r => base.str(fmt, inner.decodeStream(r))\n  });\n};\nexport const flag = (flagValue, xor = false) => wrap({\n  size: flagValue.length,\n  encodeStream: (w, value) => {\n    if (!!value !== xor) w.bytes(flagValue);\n  },\n  decodeStream: r => {\n    let hasFlag = r.leftBytes >= flagValue.length;\n    if (hasFlag) {\n      hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n      if (hasFlag) r.bytes(flagValue.length);\n    }\n    return hasFlag !== xor;\n  }\n});\nexport function flagged(path, inner, def) {\n  if (!isCoder(inner)) throw new Error(`flagged: invalid inner value ${inner}`);\n  return wrap({\n    encodeStream: (w, value) => {\n      if (typeof path === 'string') {\n        if (getPath(w.path, path.split('/'))) inner.encodeStream(w, value);else if (def) inner.encodeStream(w, def);\n      } else {\n        path.encodeStream(w, !!value);\n        if (!!value) inner.encodeStream(w, value);else if (def) inner.encodeStream(w, def);\n      }\n    },\n    decodeStream: r => {\n      let hasFlag = false;\n      if (typeof path === 'string') hasFlag = getPath(r.path, path.split('/'));else hasFlag = path.decodeStream(r);\n      if (hasFlag) return inner.decodeStream(r);else if (def) inner.decodeStream(r);\n    }\n  });\n}\nexport function optional(flag, inner, def) {\n  if (!isCoder(flag) || !isCoder(inner)) throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n  return wrap({\n    size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n    encodeStream: (w, value) => {\n      flag.encodeStream(w, !!value);\n      if (value) inner.encodeStream(w, value);else if (def !== undefined) inner.encodeStream(w, def);\n    },\n    decodeStream: r => {\n      if (flag.decodeStream(r)) return inner.decodeStream(r);else if (def !== undefined) inner.decodeStream(r);\n    }\n  });\n}\nexport function magic(inner, constant, check = true) {\n  if (!isCoder(inner)) throw new Error(`flagged: invalid inner value ${inner}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, constant),\n    decodeStream: r => {\n      const value = inner.decodeStream(r);\n      if (check && typeof value !== 'object' && value !== constant || isBytes(constant) && !equalBytes(constant, value)) {\n        throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n      }\n      return;\n    }\n  });\n}\nexport const magicBytes = constant => {\n  const c = typeof constant === 'string' ? base.utf8.decode(constant) : constant;\n  return magic(bytes(c.length), c);\n};\nexport function constant(c) {\n  return wrap({\n    encodeStream: (w, value) => {\n      if (value !== c) throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n    },\n    decodeStream: r => c\n  });\n}\nfunction sizeof(fields) {\n  let size = 0;\n  for (let f of fields) {\n    if (!f.size) return;\n    size += f.size;\n  }\n  return size;\n}\nexport function struct(fields) {\n  if (Array.isArray(fields)) throw new Error('Packed.Struct: got array instead of object');\n  return wrap({\n    size: sizeof(Object.values(fields)),\n    encodeStream: (w, value) => {\n      if (typeof value !== 'object' || value === null) throw w.err(`struct: invalid value ${value}`);\n      w.path.push(value);\n      for (let name in fields) {\n        w.fieldPathPush(name);\n        let field = fields[name];\n        field.encodeStream(w, value[name]);\n        w.fieldPathPop();\n      }\n      w.path.pop();\n    },\n    decodeStream: r => {\n      let res = {};\n      r.path.push(res);\n      for (let name in fields) {\n        r.fieldPathPush(name);\n        res[name] = fields[name].decodeStream(r);\n        r.fieldPathPop();\n      }\n      r.path.pop();\n      return res;\n    }\n  });\n}\nexport function tuple(fields) {\n  if (!Array.isArray(fields)) throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n  return wrap({\n    size: sizeof(fields),\n    encodeStream: (w, value) => {\n      if (!Array.isArray(value)) throw w.err(`tuple: invalid value ${value}`);\n      w.path.push(value);\n      for (let i = 0; i < fields.length; i++) {\n        w.fieldPathPush('' + i);\n        fields[i].encodeStream(w, value[i]);\n        w.fieldPathPop();\n      }\n      w.path.pop();\n    },\n    decodeStream: r => {\n      let res = [];\n      r.path.push(res);\n      for (let i = 0; i < fields.length; i++) {\n        r.fieldPathPush('' + i);\n        res.push(fields[i].decodeStream(r));\n        r.fieldPathPop();\n      }\n      r.path.pop();\n      return res;\n    }\n  });\n}\nexport function prefix(len, inner) {\n  if (!isCoder(inner)) throw new Error(`prefix: invalid inner value ${inner}`);\n  if (isBytes(len)) throw new Error(`prefix: len cannot be Uint8Array`);\n  const b = bytes(len);\n  return wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: (w, value) => {\n      const wChild = new Writer(w.path, w.fieldPath);\n      inner.encodeStream(wChild, value);\n      b.encodeStream(w, wChild.buffer);\n    },\n    decodeStream: r => {\n      const data = b.decodeStream(r);\n      return inner.decodeStream(new Reader(data, r.path, r.fieldPath));\n    }\n  });\n}\nexport function array(len, inner) {\n  if (!isCoder(inner)) throw new Error(`array: invalid inner value ${inner}`);\n  return wrap({\n    size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n    encodeStream: (w, value) => {\n      if (!Array.isArray(value)) throw w.err(`array: invalid value ${value}`);\n      if (!isBytes(len)) w.length(len, value.length);\n      w.path.push(value);\n      for (let i = 0; i < value.length; i++) {\n        w.fieldPathPush('' + i);\n        const elm = value[i];\n        const startPos = w.pos;\n        inner.encodeStream(w, elm);\n        if (isBytes(len)) {\n          if (len.length > w.pos - startPos) continue;\n          const data = w.buffer.subarray(startPos, w.pos);\n          if (equalBytes(data.subarray(0, len.length), len)) throw w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n        }\n        w.fieldPathPop();\n      }\n      w.path.pop();\n      if (isBytes(len)) w.bytes(len);\n    },\n    decodeStream: r => {\n      let res = [];\n      if (len === null) {\n        let i = 0;\n        r.path.push(res);\n        while (!r.isEnd()) {\n          r.fieldPathPush('' + i++);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n          if (inner.size && r.leftBytes < inner.size) break;\n        }\n        r.path.pop();\n      } else if (isBytes(len)) {\n        let i = 0;\n        r.path.push(res);\n        while (true) {\n          if (equalBytes(r.bytes(len.length, true), len)) {\n            r.bytes(len.length);\n            break;\n          }\n          r.fieldPathPush('' + i++);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n        }\n        r.path.pop();\n      } else {\n        r.fieldPathPush('arrayLen');\n        const length = r.length(len);\n        r.fieldPathPop();\n        r.path.push(res);\n        for (let i = 0; i < length; i++) {\n          r.fieldPathPush('' + i);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n        }\n        r.path.pop();\n      }\n      return res;\n    }\n  });\n}\nexport function map(inner, variants) {\n  if (!isCoder(inner)) throw new Error(`map: invalid inner value ${inner}`);\n  const variantNames = new Map();\n  for (const k in variants) variantNames.set(variants[k], k);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => {\n      if (typeof value !== 'string') throw w.err(`map: invalid value ${value}`);\n      if (!(value in variants)) throw w.err(`Map: unknown variant: ${value}`);\n      inner.encodeStream(w, variants[value]);\n    },\n    decodeStream: r => {\n      const variant = inner.decodeStream(r);\n      const name = variantNames.get(variant);\n      if (name === undefined) throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n      return name;\n    }\n  });\n}\nexport function tag(tag, variants) {\n  if (!isCoder(tag)) throw new Error(`tag: invalid tag value ${tag}`);\n  return wrap({\n    size: tag.size,\n    encodeStream: (w, value) => {\n      const {\n        TAG,\n        data\n      } = value;\n      const dataType = variants[TAG];\n      if (!dataType) throw w.err(`Tag: invalid tag ${TAG.toString()}`);\n      tag.encodeStream(w, TAG);\n      dataType.encodeStream(w, data);\n    },\n    decodeStream: r => {\n      const TAG = tag.decodeStream(r);\n      const dataType = variants[TAG];\n      if (!dataType) throw r.err(`Tag: invalid tag ${TAG}`);\n      return {\n        TAG,\n        data: dataType.decodeStream(r)\n      };\n    }\n  });\n}\nexport function mappedTag(tagCoder, variants) {\n  if (!isCoder(tagCoder)) throw new Error(`mappedTag: invalid tag value ${tag}`);\n  const mapValue = {};\n  const tagValue = {};\n  for (const key in variants) {\n    mapValue[key] = variants[key][0];\n    tagValue[key] = variants[key][1];\n  }\n  return tag(map(tagCoder, mapValue), tagValue);\n}\nexport function bitset(names, pad = false) {\n  return wrap({\n    encodeStream: (w, value) => {\n      if (typeof value !== 'object' || value === null) throw w.err(`bitset: invalid value ${value}`);\n      for (let i = 0; i < names.length; i++) w.bits(+value[names[i]], 1);\n      if (pad && names.length % 8) w.bits(0, 8 - names.length % 8);\n    },\n    decodeStream: r => {\n      let out = {};\n      for (let i = 0; i < names.length; i++) out[names[i]] = !!r.bits(1);\n      if (pad && names.length % 8) r.bits(8 - names.length % 8);\n      return out;\n    }\n  });\n}\nexport const ZeroPad = _ => 0;\nfunction padLength(blockSize, len) {\n  if (len % blockSize === 0) return 0;\n  return blockSize - len % blockSize;\n}\nexport function padLeft(blockSize, inner, padFn) {\n  if (!isCoder(inner)) throw new Error(`padLeft: invalid inner value ${inner}`);\n  const _padFn = padFn || ZeroPad;\n  if (!inner.size) throw new Error('padLeft with dynamic size argument is impossible');\n  return wrap({\n    size: inner.size + padLength(blockSize, inner.size),\n    encodeStream: (w, value) => {\n      const padBytes = padLength(blockSize, inner.size);\n      for (let i = 0; i < padBytes; i++) w.byte(_padFn(i));\n      inner.encodeStream(w, value);\n    },\n    decodeStream: r => {\n      r.bytes(padLength(blockSize, inner.size));\n      return inner.decodeStream(r);\n    }\n  });\n}\nexport function padRight(blockSize, inner, padFn) {\n  if (!isCoder(inner)) throw new Error(`padRight: invalid inner value ${inner}`);\n  const _padFn = padFn || ZeroPad;\n  return wrap({\n    size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n    encodeStream: (w, value) => {\n      const pos = w.pos;\n      inner.encodeStream(w, value);\n      const padBytes = padLength(blockSize, w.pos - pos);\n      for (let i = 0; i < padBytes; i++) w.byte(_padFn(i));\n    },\n    decodeStream: r => {\n      const start = r.pos;\n      const res = inner.decodeStream(r);\n      r.bytes(padLength(blockSize, r.pos - start));\n      return res;\n    }\n  });\n}\nexport function pointer(ptr, inner, sized = false) {\n  if (!isCoder(ptr)) throw new Error(`pointer: invalid ptr value ${ptr}`);\n  if (!isCoder(inner)) throw new Error(`pointer: invalid inner value ${inner}`);\n  if (!ptr.size) throw new Error('Pointer: unsized ptr');\n  return wrap({\n    size: sized ? ptr.size : undefined,\n    encodeStream: (w, value) => {\n      const start = w.pos;\n      ptr.encodeStream(w, 0);\n      w.ptrs.push({\n        pos: start,\n        ptr,\n        buffer: inner.encode(value)\n      });\n    },\n    decodeStream: r => {\n      const ptrVal = ptr.decodeStream(r);\n      if (ptrVal < r.pos) throw new Error('pointer.decodeStream pointer less than position');\n      r.hasPtr = true;\n      const rChild = new Reader(r.absBytes(ptrVal), r.path, r.fieldPath);\n      return inner.decodeStream(rChild);\n    }\n  });\n}\nexport function base64armor(name, lineLen, inner, checksum) {\n  const markBegin = `-----BEGIN ${name.toUpperCase()}-----`;\n  const markEnd = `-----END ${name.toUpperCase()}-----`;\n  return {\n    encode(value) {\n      const data = inner.encode(value);\n      const encoded = base.base64.encode(data);\n      let lines = [];\n      for (let i = 0; i < encoded.length; i += lineLen) {\n        const s = encoded.slice(i, i + lineLen);\n        if (s.length) lines.push(`${encoded.slice(i, i + lineLen)}\\n`);\n      }\n      let body = lines.join('');\n      if (checksum) body += `=${base.base64.encode(checksum(data))}\\n`;\n      return `${markBegin}\\n\\n${body}${markEnd}\\n`;\n    },\n    decode(s) {\n      let lines = s.replace(markBegin, '').replace(markEnd, '').trim().split('\\n');\n      lines = lines.map(l => l.replace('\\r', '').trim());\n      if (checksum && lines[lines.length - 1].startsWith('=')) {\n        const body = base.base64.decode(lines.slice(0, -1).join(''));\n        const cs = lines[lines.length - 1].slice(1);\n        const realCS = base.base64.encode(checksum(body));\n        if (realCS !== cs) throw new Error(`Base64Armor: invalid checksum ${cs} instead of ${realCS}`);\n        return inner.decode(body);\n      }\n      return inner.decode(base.base64.decode(lines.join('')));\n    }\n  };\n}\nexport const nothing = magic(bytes(0), EMPTY);\nexport function debug(inner) {\n  if (!isCoder(inner)) throw new Error(`debug: invalid inner value ${inner}`);\n  const log = (name, rw, value) => {\n    console.log(`DEBUG/${name}(${rw.fieldPath.join('/')}):`, {\n      type: typeof value,\n      value\n    });\n    return value;\n  };\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, log('encode', w, value)),\n    decodeStream: r => log('decode', r, inner.decodeStream(r))\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}