{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenSigner = exports.createUnsecuredToken = void 0;\nconst base64url = require(\"./base64Url\");\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nconst sha256_1 = require(\"./cryptoClients/sha256\");\nfunction createSigningInput(payload, header) {\n  const tokenParts = [];\n  // add in the header\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader);\n  // add in the payload\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload);\n  // prepare the message\n  const signingInput = tokenParts.join('.');\n  // return the signing input\n  return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n  const header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nclass TokenSigner {\n  constructor(signingAlgorithm, rawPrivateKey) {\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n  header(header = {}) {\n    const defaultHeader = {\n      typ: this.tokenType,\n      alg: this.cryptoClient.algorithmName\n    };\n    return Object.assign({}, defaultHeader, header);\n  }\n  sign(payload, expanded = false, customHeader = {}) {\n    // generate the token header\n    const header = this.header(customHeader);\n    // prepare the message to be signed\n    const signingInput = createSigningInput(payload, header);\n    const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n    return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n  }\n  signAsync(payload, expanded = false, customHeader = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // generate the token header\n      const header = this.header(customHeader);\n      // prepare the message to be signed\n      const signingInput = createSigningInput(payload, header);\n      const signingInputHash = yield (0, sha256_1.hashSha256Async)(signingInput);\n      return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    });\n  }\n  createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n    // sign the message and add in the signature\n    const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n    if (expanded) {\n      const signedToken = {\n        header: [base64url.encode(JSON.stringify(header))],\n        payload: JSON.stringify(payload),\n        signature: [signature]\n      };\n      return signedToken;\n    } else {\n      return [signingInput, signature].join('.');\n    }\n  }\n}\nexports.TokenSigner = TokenSigner;\n//# sourceMappingURL=signer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}