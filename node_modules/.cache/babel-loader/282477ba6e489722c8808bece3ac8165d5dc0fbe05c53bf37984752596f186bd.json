{"ast":null,"code":"import _classCallCheck from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toArray from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { secp256k1 as _secp, schnorr } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { hex, base58check as _b58, bech32, bech32m } from '@scure/base';\nimport * as P from 'micro-packed';\nvar ProjPoint = _secp.ProjectivePoint,\n  _signECDSA = _secp.sign,\n  _pubECDSA = _secp.getPublicKey;\nvar CURVE_ORDER = _secp.CURVE.n;\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nvar def = function def(value, _def) {\n  return value === undefined ? _def : value;\n};\nvar isBytes = P.isBytes;\nvar hash160 = function hash160(msg) {\n  return ripemd160(sha256(msg));\n};\nvar sha256x2 = function sha256x2() {\n  return sha256(sha256(concat.apply(void 0, arguments)));\n};\nvar concat = P.concatBytes;\n// Make base58check work\nexport var base58check = _b58(sha256);\nexport function cloneDeep(obj) {\n  if (Array.isArray(obj)) return obj.map(function (i) {\n    return cloneDeep(i);\n  });\n  // slice of nodejs Buffer doesn't copy\n  else if (obj instanceof Uint8Array) return Uint8Array.from(obj);\n  // immutable\n  else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj)) return obj;\n  // null is object\n  else if (obj === null) return obj;\n  // should be last, so it won't catch other types\n  else if (typeof obj === 'object') {\n    return Object.fromEntries(Object.entries(obj).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        k = _ref2[0],\n        v = _ref2[1];\n      return [k, cloneDeep(v)];\n    }));\n  }\n  throw new Error(\"cloneDeep: unknown type=\".concat(obj, \" (\").concat(typeof obj, \")\"));\n}\nvar PubT;\n(function (PubT) {\n  PubT[PubT[\"ecdsa\"] = 0] = \"ecdsa\";\n  PubT[PubT[\"schnorr\"] = 1] = \"schnorr\";\n})(PubT || (PubT = {}));\nfunction validatePubkey(pub, type) {\n  var len = pub.length;\n  if (type === PubT.ecdsa) {\n    if (len === 32) throw new Error('Expected non-Schnorr key');\n    ProjPoint.fromHex(pub); // does assertValidity\n    return pub;\n  } else if (type === PubT.schnorr) {\n    if (len !== 32) throw new Error('Expected 32-byte Schnorr key');\n    schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n    return pub;\n  } else {\n    throw new Error('Unknown key type');\n  }\n}\nfunction isValidPubkey(pub, type) {\n  try {\n    validatePubkey(pub, type);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nvar hasLowR = function hasLowR(sig) {\n  return sig.r < CURVE_ORDER / 2n;\n};\nfunction signECDSA(hash, privateKey) {\n  var lowR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var sig = _signECDSA(hash, privateKey);\n  if (lowR && !hasLowR(sig)) {\n    var extraEntropy = new Uint8Array(32);\n    for (var cnt = 0; cnt < Number.MAX_SAFE_INTEGER; cnt++) {\n      extraEntropy.set(P.U32LE.encode(cnt));\n      sig = _signECDSA(hash, privateKey, {\n        extraEntropy: extraEntropy\n      });\n      if (hasLowR(sig)) break;\n    }\n  }\n  return sig.toDERRawBytes();\n}\nfunction tapTweak(a, b) {\n  var u = schnorr.utils;\n  var t = u.taggedHash('TapTweak', a, b);\n  var tn = u.bytesToNumberBE(t);\n  if (tn >= CURVE_ORDER) throw new Error('tweak higher than curve order');\n  return tn;\n}\nexport function taprootTweakPrivKey(privKey) {\n  var merkleRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n  var u = schnorr.utils;\n  var seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n  var P = ProjPoint.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n  // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n  var seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n  var xP = u.pointToBytes(P);\n  // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n  var t = tapTweak(xP, merkleRoot);\n  // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n  return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\nexport function taprootTweakPubkey(pubKey, h) {\n  var u = schnorr.utils;\n  var t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n  var P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n  var Q = P.add(ProjPoint.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n  var parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n  return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n// Can be 33 or 64 bytes\nvar PubKeyECDSA = P.validate(P.bytes(null), function (pub) {\n  return validatePubkey(pub, PubT.ecdsa);\n});\nvar PubKeySchnorr = P.validate(P.bytes(32), function (pub) {\n  return validatePubkey(pub, PubT.schnorr);\n});\nvar SignatureSchnorr = P.validate(P.bytes(null), function (sig) {\n  if (sig.length !== 64 && sig.length !== 65) throw new Error('Schnorr signature should be 64 or 65 bytes long');\n  return sig;\n});\nfunction uniqPubkey(pubkeys) {\n  var map = {};\n  var _iterator = _createForOfIteratorHelper(pubkeys),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pub = _step.value;\n      var key = hex.encode(pub);\n      if (map[key]) throw new Error(\"Multisig: non-uniq pubkey: \".concat(pubkeys.map(hex.encode)));\n      map[key] = true;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport var NETWORK = {\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80\n};\nexport var TEST_NETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef\n};\nexport var PRECISION = 8;\nexport var DEFAULT_VERSION = 2;\nexport var DEFAULT_LOCKTIME = 0;\nexport var DEFAULT_SEQUENCE = 4294967295;\nvar EMPTY32 = new Uint8Array(32);\n// Utils\nexport var Decimal = P.coders.decimal(PRECISION);\n// Exported for tests, internal method\nexport function _cmpBytes(a, b) {\n  if (!isBytes(a) || !isBytes(b)) throw new Error(\"cmp: wrong type a=\".concat(typeof a, \" b=\").concat(typeof b));\n  // -1 -> a<b, 0 -> a==b, 1 -> a>b\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) if (a[i] != b[i]) return Math.sign(a[i] - b[i]);\n  return Math.sign(a.length - b.length);\n}\n// Coders\n// prettier-ignore\nexport var OP;\n(function (OP) {\n  OP[OP[\"OP_0\"] = 0] = \"OP_0\";\n  OP[OP[\"PUSHDATA1\"] = 76] = \"PUSHDATA1\";\n  OP[OP[\"PUSHDATA2\"] = 77] = \"PUSHDATA2\";\n  OP[OP[\"PUSHDATA4\"] = 78] = \"PUSHDATA4\";\n  OP[OP[\"1NEGATE\"] = 79] = \"1NEGATE\";\n  OP[OP[\"RESERVED\"] = 80] = \"RESERVED\";\n  OP[OP[\"OP_1\"] = 81] = \"OP_1\";\n  OP[OP[\"OP_2\"] = 82] = \"OP_2\";\n  OP[OP[\"OP_3\"] = 83] = \"OP_3\";\n  OP[OP[\"OP_4\"] = 84] = \"OP_4\";\n  OP[OP[\"OP_5\"] = 85] = \"OP_5\";\n  OP[OP[\"OP_6\"] = 86] = \"OP_6\";\n  OP[OP[\"OP_7\"] = 87] = \"OP_7\";\n  OP[OP[\"OP_8\"] = 88] = \"OP_8\";\n  OP[OP[\"OP_9\"] = 89] = \"OP_9\";\n  OP[OP[\"OP_10\"] = 90] = \"OP_10\";\n  OP[OP[\"OP_11\"] = 91] = \"OP_11\";\n  OP[OP[\"OP_12\"] = 92] = \"OP_12\";\n  OP[OP[\"OP_13\"] = 93] = \"OP_13\";\n  OP[OP[\"OP_14\"] = 94] = \"OP_14\";\n  OP[OP[\"OP_15\"] = 95] = \"OP_15\";\n  OP[OP[\"OP_16\"] = 96] = \"OP_16\";\n  // Control\n  OP[OP[\"NOP\"] = 97] = \"NOP\";\n  OP[OP[\"VER\"] = 98] = \"VER\";\n  OP[OP[\"IF\"] = 99] = \"IF\";\n  OP[OP[\"NOTIF\"] = 100] = \"NOTIF\";\n  OP[OP[\"VERIF\"] = 101] = \"VERIF\";\n  OP[OP[\"VERNOTIF\"] = 102] = \"VERNOTIF\";\n  OP[OP[\"ELSE\"] = 103] = \"ELSE\";\n  OP[OP[\"ENDIF\"] = 104] = \"ENDIF\";\n  OP[OP[\"VERIFY\"] = 105] = \"VERIFY\";\n  OP[OP[\"RETURN\"] = 106] = \"RETURN\";\n  // Stack\n  OP[OP[\"TOALTSTACK\"] = 107] = \"TOALTSTACK\";\n  OP[OP[\"FROMALTSTACK\"] = 108] = \"FROMALTSTACK\";\n  OP[OP[\"2DROP\"] = 109] = \"2DROP\";\n  OP[OP[\"2DUP\"] = 110] = \"2DUP\";\n  OP[OP[\"3DUP\"] = 111] = \"3DUP\";\n  OP[OP[\"2OVER\"] = 112] = \"2OVER\";\n  OP[OP[\"2ROT\"] = 113] = \"2ROT\";\n  OP[OP[\"2SWAP\"] = 114] = \"2SWAP\";\n  OP[OP[\"IFDUP\"] = 115] = \"IFDUP\";\n  OP[OP[\"DEPTH\"] = 116] = \"DEPTH\";\n  OP[OP[\"DROP\"] = 117] = \"DROP\";\n  OP[OP[\"DUP\"] = 118] = \"DUP\";\n  OP[OP[\"NIP\"] = 119] = \"NIP\";\n  OP[OP[\"OVER\"] = 120] = \"OVER\";\n  OP[OP[\"PICK\"] = 121] = \"PICK\";\n  OP[OP[\"ROLL\"] = 122] = \"ROLL\";\n  OP[OP[\"ROT\"] = 123] = \"ROT\";\n  OP[OP[\"SWAP\"] = 124] = \"SWAP\";\n  OP[OP[\"TUCK\"] = 125] = \"TUCK\";\n  // Splice\n  OP[OP[\"CAT\"] = 126] = \"CAT\";\n  OP[OP[\"SUBSTR\"] = 127] = \"SUBSTR\";\n  OP[OP[\"LEFT\"] = 128] = \"LEFT\";\n  OP[OP[\"RIGHT\"] = 129] = \"RIGHT\";\n  OP[OP[\"SIZE\"] = 130] = \"SIZE\";\n  // Boolean logic\n  OP[OP[\"INVERT\"] = 131] = \"INVERT\";\n  OP[OP[\"AND\"] = 132] = \"AND\";\n  OP[OP[\"OR\"] = 133] = \"OR\";\n  OP[OP[\"XOR\"] = 134] = \"XOR\";\n  OP[OP[\"EQUAL\"] = 135] = \"EQUAL\";\n  OP[OP[\"EQUALVERIFY\"] = 136] = \"EQUALVERIFY\";\n  OP[OP[\"RESERVED1\"] = 137] = \"RESERVED1\";\n  OP[OP[\"RESERVED2\"] = 138] = \"RESERVED2\";\n  // Numbers\n  OP[OP[\"1ADD\"] = 139] = \"1ADD\";\n  OP[OP[\"1SUB\"] = 140] = \"1SUB\";\n  OP[OP[\"2MUL\"] = 141] = \"2MUL\";\n  OP[OP[\"2DIV\"] = 142] = \"2DIV\";\n  OP[OP[\"NEGATE\"] = 143] = \"NEGATE\";\n  OP[OP[\"ABS\"] = 144] = \"ABS\";\n  OP[OP[\"NOT\"] = 145] = \"NOT\";\n  OP[OP[\"0NOTEQUAL\"] = 146] = \"0NOTEQUAL\";\n  OP[OP[\"ADD\"] = 147] = \"ADD\";\n  OP[OP[\"SUB\"] = 148] = \"SUB\";\n  OP[OP[\"MUL\"] = 149] = \"MUL\";\n  OP[OP[\"DIV\"] = 150] = \"DIV\";\n  OP[OP[\"MOD\"] = 151] = \"MOD\";\n  OP[OP[\"LSHIFT\"] = 152] = \"LSHIFT\";\n  OP[OP[\"RSHIFT\"] = 153] = \"RSHIFT\";\n  OP[OP[\"BOOLAND\"] = 154] = \"BOOLAND\";\n  OP[OP[\"BOOLOR\"] = 155] = \"BOOLOR\";\n  OP[OP[\"NUMEQUAL\"] = 156] = \"NUMEQUAL\";\n  OP[OP[\"NUMEQUALVERIFY\"] = 157] = \"NUMEQUALVERIFY\";\n  OP[OP[\"NUMNOTEQUAL\"] = 158] = \"NUMNOTEQUAL\";\n  OP[OP[\"LESSTHAN\"] = 159] = \"LESSTHAN\";\n  OP[OP[\"GREATERTHAN\"] = 160] = \"GREATERTHAN\";\n  OP[OP[\"LESSTHANOREQUAL\"] = 161] = \"LESSTHANOREQUAL\";\n  OP[OP[\"GREATERTHANOREQUAL\"] = 162] = \"GREATERTHANOREQUAL\";\n  OP[OP[\"MIN\"] = 163] = \"MIN\";\n  OP[OP[\"MAX\"] = 164] = \"MAX\";\n  OP[OP[\"WITHIN\"] = 165] = \"WITHIN\";\n  // Crypto\n  OP[OP[\"RIPEMD160\"] = 166] = \"RIPEMD160\";\n  OP[OP[\"SHA1\"] = 167] = \"SHA1\";\n  OP[OP[\"SHA256\"] = 168] = \"SHA256\";\n  OP[OP[\"HASH160\"] = 169] = \"HASH160\";\n  OP[OP[\"HASH256\"] = 170] = \"HASH256\";\n  OP[OP[\"CODESEPARATOR\"] = 171] = \"CODESEPARATOR\";\n  OP[OP[\"CHECKSIG\"] = 172] = \"CHECKSIG\";\n  OP[OP[\"CHECKSIGVERIFY\"] = 173] = \"CHECKSIGVERIFY\";\n  OP[OP[\"CHECKMULTISIG\"] = 174] = \"CHECKMULTISIG\";\n  OP[OP[\"CHECKMULTISIGVERIFY\"] = 175] = \"CHECKMULTISIGVERIFY\";\n  // Expansion\n  OP[OP[\"NOP1\"] = 176] = \"NOP1\";\n  OP[OP[\"CHECKLOCKTIMEVERIFY\"] = 177] = \"CHECKLOCKTIMEVERIFY\";\n  OP[OP[\"CHECKSEQUENCEVERIFY\"] = 178] = \"CHECKSEQUENCEVERIFY\";\n  OP[OP[\"NOP4\"] = 179] = \"NOP4\";\n  OP[OP[\"NOP5\"] = 180] = \"NOP5\";\n  OP[OP[\"NOP6\"] = 181] = \"NOP6\";\n  OP[OP[\"NOP7\"] = 182] = \"NOP7\";\n  OP[OP[\"NOP8\"] = 183] = \"NOP8\";\n  OP[OP[\"NOP9\"] = 184] = \"NOP9\";\n  OP[OP[\"NOP10\"] = 185] = \"NOP10\";\n  // BIP 342\n  OP[OP[\"CHECKSIGADD\"] = 186] = \"CHECKSIGADD\";\n  // Invalid\n  OP[OP[\"INVALID\"] = 255] = \"INVALID\";\n})(OP || (OP = {}));\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport var Script = P.wrap({\n  encodeStream: function encodeStream(w, value) {\n    var _iterator2 = _createForOfIteratorHelper(value),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var o = _step2.value;\n        if (typeof o === 'string') {\n          if (OP[o] === undefined) throw new Error(\"Unknown opcode=\".concat(o));\n          w.byte(OP[o]);\n          continue;\n        } else if (typeof o === 'number') {\n          if (o === 0x00) {\n            w.byte(0x00);\n            continue;\n          } else if (1 <= o && o <= 16) {\n            w.byte(OP.OP_1 - 1 + o);\n            continue;\n          }\n        }\n        // Encode big numbers\n        if (typeof o === 'number') o = ScriptNum().encode(BigInt(o));\n        if (!isBytes(o)) throw new Error(\"Wrong Script OP=\".concat(o, \" (\").concat(typeof o, \")\"));\n        // Bytes\n        var len = o.length;\n        if (len < OP.PUSHDATA1) w.byte(len);else if (len <= 0xff) {\n          w.byte(OP.PUSHDATA1);\n          w.byte(len);\n        } else if (len <= 0xffff) {\n          w.byte(OP.PUSHDATA2);\n          w.bytes(P.U16LE.encode(len));\n        } else {\n          w.byte(OP.PUSHDATA4);\n          w.bytes(P.U32LE.encode(len));\n        }\n        w.bytes(o);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  },\n  decodeStream: function decodeStream(r) {\n    var out = [];\n    while (!r.isEnd()) {\n      var cur = r.byte();\n      // if 0 < cur < 78\n      if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n        var len = void 0;\n        if (cur < OP.PUSHDATA1) len = cur;else if (cur === OP.PUSHDATA1) len = P.U8.decodeStream(r);else if (cur === OP.PUSHDATA2) len = P.U16LE.decodeStream(r);else if (cur === OP.PUSHDATA4) len = P.U32LE.decodeStream(r);else throw new Error('Should be not possible');\n        out.push(r.bytes(len));\n      } else if (cur === 0x00) {\n        out.push(0);\n      } else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n        out.push(cur - (OP.OP_1 - 1));\n      } else {\n        var op = OP[cur];\n        if (op === undefined) throw new Error(\"Unknown opcode=\".concat(cur.toString(16)));\n        out.push(op);\n      }\n    }\n    return out;\n  }\n});\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum() {\n  var bytesLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;\n  var forceMinimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return P.wrap({\n    encodeStream: function encodeStream(w, value) {\n      if (value === 0n) return;\n      var neg = value < 0;\n      var val = BigInt(value);\n      var nums = [];\n      for (var abs = neg ? -val : val; abs; abs >>= 8n) nums.push(Number(abs & 0xffn));\n      if (nums[nums.length - 1] >= 0x80) nums.push(neg ? 0x80 : 0);else if (neg) nums[nums.length - 1] |= 0x80;\n      w.bytes(new Uint8Array(nums));\n    },\n    decodeStream: function decodeStream(r) {\n      var len = r.leftBytes;\n      if (len > bytesLimit) throw new Error(\"ScriptNum: number (\".concat(len, \") bigger than limit=\").concat(bytesLimit));\n      if (len === 0) return 0n;\n      if (forceMinimal) {\n        // MSB is zero (without sign bit) -> not minimally encoded\n        if ((r.data[len - 1] & 0x7f) === 0) {\n          // exception\n          if (len <= 1 || (r.data[len - 2] & 0x80) === 0) throw new Error('Non-minimally encoded ScriptNum');\n        }\n      }\n      var last = 0;\n      var res = 0n;\n      for (var i = 0; i < len; ++i) {\n        last = r.byte();\n        res |= BigInt(last) << 8n * BigInt(i);\n      }\n      if (last >= 0x80) {\n        res &= Math.pow(2n, BigInt(len * 8)) - 1n >> 1n;\n        res = -res;\n      }\n      return res;\n    }\n  });\n}\nexport function OpToNum(op) {\n  var bytesLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  var forceMinimal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (typeof op === 'number') return op;\n  if (isBytes(op)) {\n    try {\n      var val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n      if (val > Number.MAX_SAFE_INTEGER) return;\n      return Number(val);\n    } catch (e) {\n      return;\n    }\n  }\n  return;\n}\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nvar CSLimits = {\n  0xfd: [0xfd, 2, 253n, 65535n],\n  0xfe: [0xfe, 4, 65536n, 4294967295n],\n  0xff: [0xff, 8, 4294967296n, 18446744073709551615n]\n};\nexport var CompactSize = P.wrap({\n  encodeStream: function encodeStream(w, value) {\n    if (typeof value === 'number') value = BigInt(value);\n    if (0n <= value && value <= 252n) return w.byte(Number(value));\n    for (var _i = 0, _Object$values = Object.values(CSLimits); _i < _Object$values.length; _i++) {\n      var _Object$values$_i = _slicedToArray(_Object$values[_i], 4),\n        flag = _Object$values$_i[0],\n        bytes = _Object$values$_i[1],\n        start = _Object$values$_i[2],\n        stop = _Object$values$_i[3];\n      if (start > value || value > stop) continue;\n      w.byte(flag);\n      for (var i = 0; i < bytes; i++) w.byte(Number(value >> 8n * BigInt(i) & 0xffn));\n      return;\n    }\n    throw w.err(\"VarInt too big: \".concat(value));\n  },\n  decodeStream: function decodeStream(r) {\n    var b0 = r.byte();\n    if (b0 <= 0xfc) return BigInt(b0);\n    var _CSLimits$b = _slicedToArray(CSLimits[b0], 3),\n      _ = _CSLimits$b[0],\n      bytes = _CSLimits$b[1],\n      start = _CSLimits$b[2];\n    var num = 0n;\n    for (var i = 0; i < bytes; i++) num |= BigInt(r.byte()) << 8n * BigInt(i);\n    if (num < start) throw r.err(\"Wrong CompactSize(\".concat(8 * bytes, \")\"));\n    return num;\n  }\n});\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nvar CompactSizeLen = P.apply(CompactSize, P.coders.number);\n// Array of size <CompactSize>\nexport var BTCArray = function BTCArray(t) {\n  return P.array(CompactSize, t);\n};\n// ui8a of size <CompactSize>\nexport var VarBytes = P.bytes(CompactSize);\nexport var RawInput = P.struct({\n  txid: P.bytes(32, true),\n  index: P.U32LE,\n  finalScriptSig: VarBytes,\n  sequence: P.U32LE // ?\n});\n\nexport var RawOutput = P.struct({\n  amount: P.U64LE,\n  script: VarBytes\n});\nvar EMPTY_OUTPUT = {\n  amount: 0xffffffffffffffffn,\n  script: P.EMPTY\n};\n// SegWit v0 stack of witness buffers\nexport var RawWitness = P.array(CompactSizeLen, VarBytes);\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nvar _RawTx = P.struct({\n  version: P.I32LE,\n  segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n  inputs: BTCArray(RawInput),\n  outputs: BTCArray(RawOutput),\n  witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n  // < 500000000\tBlock number at which this transaction is unlocked\n  // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n  // Handled as part of PSBTv2\n  lockTime: P.U32LE\n});\nfunction validateRawTx(tx) {\n  if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length) throw new Error('Segwit flag with empty witnesses array');\n  return tx;\n}\nexport var RawTx = P.validate(_RawTx, validateRawTx);\nfunction PSBTKeyInfo(info) {\n  var _info = _slicedToArray(info, 6),\n    type = _info[0],\n    kc = _info[1],\n    vc = _info[2],\n    reqInc = _info[3],\n    allowInc = _info[4],\n    silentIgnore = _info[5];\n  return {\n    type: type,\n    kc: kc,\n    vc: vc,\n    reqInc: reqInc,\n    allowInc: allowInc,\n    silentIgnore: silentIgnore\n  };\n}\nvar BIP32Der = P.struct({\n  fingerprint: P.U32BE,\n  path: P.array(null, P.U32LE)\n});\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nvar _TaprootControlBlock = P.struct({\n  version: P.U8,\n  internalKey: P.bytes(32),\n  merklePath: P.array(null, P.bytes(32))\n});\nexport var TaprootControlBlock = P.validate(_TaprootControlBlock, function (cb) {\n  if (cb.merklePath.length > 128) throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n  return cb;\n});\nvar TaprootBIP32Der = P.struct({\n  hashes: P.array(CompactSizeLen, P.bytes(32)),\n  der: BIP32Der\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nvar GlobalXPUB = P.bytes(78);\nvar tapScriptSigKey = P.struct({\n  pubKey: PubKeySchnorr,\n  leafHash: P.bytes(32)\n});\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nvar tapTree = P.array(null, P.struct({\n  depth: P.U8,\n  version: P.U8,\n  script: VarBytes\n}));\nvar BytesInf = P.bytes(null); // Bytes will conflict with Bytes type\nvar Bytes20 = P.bytes(20);\nvar Bytes32 = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nvar PSBTGlobal = {\n  unsignedTx: [0x00, false, RawTx, [0], [0], false],\n  xpub: [0x01, GlobalXPUB, BIP32Der, [], [0, 2], false],\n  txVersion: [0x02, false, P.U32LE, [2], [2], false],\n  fallbackLocktime: [0x03, false, P.U32LE, [], [2], false],\n  inputCount: [0x04, false, CompactSizeLen, [2], [2], false],\n  outputCount: [0x05, false, CompactSizeLen, [2], [2], false],\n  txModifiable: [0x06, false, P.U8, [], [2], false],\n  version: [0xfb, false, P.U32LE, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// prettier-ignore\nvar PSBTInput = {\n  nonWitnessUtxo: [0x00, false, RawTx, [], [0, 2], false],\n  witnessUtxo: [0x01, false, RawOutput, [], [0, 2], false],\n  partialSig: [0x02, PubKeyECDSA, BytesInf, [], [0, 2], false],\n  sighashType: [0x03, false, P.U32LE, [], [0, 2], false],\n  redeemScript: [0x04, false, BytesInf, [], [0, 2], false],\n  witnessScript: [0x05, false, BytesInf, [], [0, 2], false],\n  bip32Derivation: [0x06, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n  finalScriptSig: [0x07, false, BytesInf, [], [0, 2], false],\n  finalScriptWitness: [0x08, false, RawWitness, [], [0, 2], false],\n  porCommitment: [0x09, false, BytesInf, [], [0, 2], false],\n  ripemd160: [0x0a, Bytes20, BytesInf, [], [0, 2], false],\n  sha256: [0x0b, Bytes32, BytesInf, [], [0, 2], false],\n  hash160: [0x0c, Bytes20, BytesInf, [], [0, 2], false],\n  hash256: [0x0d, Bytes32, BytesInf, [], [0, 2], false],\n  txid: [0x0e, false, Bytes32, [2], [2], true],\n  index: [0x0f, false, P.U32LE, [2], [2], true],\n  sequence: [0x10, false, P.U32LE, [], [2], true],\n  requiredTimeLocktime: [0x11, false, P.U32LE, [], [2], false],\n  requiredHeightLocktime: [0x12, false, P.U32LE, [], [2], false],\n  tapKeySig: [0x13, false, SignatureSchnorr, [], [0, 2], false],\n  tapScriptSig: [0x14, tapScriptSigKey, SignatureSchnorr, [], [0, 2], false],\n  tapLeafScript: [0x15, TaprootControlBlock, BytesInf, [], [0, 2], false],\n  tapBip32Derivation: [0x16, Bytes32, TaprootBIP32Der, [], [0, 2], false],\n  tapInternalKey: [0x17, false, PubKeySchnorr, [], [0, 2], false],\n  tapMerkleRoot: [0x18, false, Bytes32, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// All other keys removed when finalizing\nvar PSBTInputFinalKeys = ['txid', 'sequence', 'index', 'witnessUtxo', 'nonWitnessUtxo', 'finalScriptSig', 'finalScriptWitness', 'unknown'];\n// Can be modified even on signed input\nvar PSBTInputUnsignedKeys = ['partialSig', 'finalScriptSig', 'finalScriptWitness', 'tapKeySig', 'tapScriptSig'];\n// prettier-ignore\nvar PSBTOutput = {\n  redeemScript: [0x00, false, BytesInf, [], [0, 2], false],\n  witnessScript: [0x01, false, BytesInf, [], [0, 2], false],\n  bip32Derivation: [0x02, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n  amount: [0x03, false, P.I64LE, [2], [2], true],\n  script: [0x04, false, BytesInf, [2], [2], true],\n  tapInternalKey: [0x05, false, PubKeySchnorr, [], [0, 2], false],\n  tapTree: [0x06, false, tapTree, [], [0, 2], false],\n  tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// Can be modified even on signed input\nvar PSBTOutputUnsignedKeys = [];\nvar PSBTKeyPair = P.array(P.NULL, P.struct({\n  //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n  key: P.prefix(CompactSizeLen, P.struct({\n    type: CompactSizeLen,\n    key: P.bytes(null)\n  })),\n  //  <value> := <valuelen> <valuedata>\n  value: P.bytes(CompactSizeLen)\n}));\nvar PSBTUnknownKey = P.struct({\n  type: CompactSizeLen,\n  key: P.bytes(null)\n});\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap(psbtEnum) {\n  // -> Record<type, [keyName, ...coders]>\n  var byType = {};\n  for (var k in psbtEnum) {\n    var _psbtEnum$k = _slicedToArray(psbtEnum[k], 3),\n      num = _psbtEnum$k[0],\n      kc = _psbtEnum$k[1],\n      vc = _psbtEnum$k[2];\n    byType[num] = [k, kc, vc];\n  }\n  return P.wrap({\n    encodeStream: function encodeStream(w, value) {\n      var out = [];\n      // Because we use order of psbtEnum, keymap is sorted here\n      var _loop = function _loop() {\n        var val = value[name];\n        if (val === undefined) return 1; // continue\n        var _psbtEnum$name = _slicedToArray(psbtEnum[name], 3),\n          type = _psbtEnum$name[0],\n          kc = _psbtEnum$name[1],\n          vc = _psbtEnum$name[2];\n        if (!kc) {\n          out.push({\n            key: {\n              type: type,\n              key: P.EMPTY\n            },\n            value: vc.encode(val)\n          });\n        } else {\n          // Low level interface, returns keys as is (with duplicates). Useful for debug\n          var kv = val.map(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n              k = _ref4[0],\n              v = _ref4[1];\n            return [kc.encode(k), vc.encode(v)];\n          });\n          // sort by keys\n          kv.sort(function (a, b) {\n            return _cmpBytes(a[0], b[0]);\n          });\n          var _iterator4 = _createForOfIteratorHelper(kv),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _step4$value = _slicedToArray(_step4.value, 2),\n                key = _step4$value[0],\n                _value = _step4$value[1];\n              out.push({\n                key: {\n                  key: key,\n                  type: type\n                },\n                value: _value\n              });\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      };\n      for (var name in psbtEnum) {\n        if (_loop()) continue;\n      }\n      if (value.unknown) {\n        value.unknown.sort(function (a, b) {\n          return _cmpBytes(a[0].key, b[0].key);\n        });\n        var _iterator3 = _createForOfIteratorHelper(value.unknown),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _slicedToArray(_step3.value, 2),\n              _k2 = _step3$value[0],\n              v = _step3$value[1];\n            out.push({\n              key: _k2,\n              value: v\n            });\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      PSBTKeyPair.encodeStream(w, out);\n    },\n    decodeStream: function decodeStream(r) {\n      var raw = PSBTKeyPair.decodeStream(r);\n      var out = {};\n      var noKey = {};\n      var _iterator5 = _createForOfIteratorHelper(raw),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var elm = _step5.value;\n          var name = 'unknown';\n          var key = elm.key.key;\n          var value = elm.value;\n          if (byType[elm.key.type]) {\n            var _byType$elm$key$type = _slicedToArray(byType[elm.key.type], 3),\n              _name = _byType$elm$key$type[0],\n              _kc = _byType$elm$key$type[1],\n              _vc = _byType$elm$key$type[2];\n            name = _name;\n            if (!_kc && key.length) {\n              throw new Error(\"PSBT: Non-empty key for \".concat(name, \" (key=\").concat(hex.encode(key), \" value=\").concat(hex.encode(value)));\n            }\n            key = _kc ? _kc.decode(key) : undefined;\n            value = _vc.decode(value);\n            if (!_kc) {\n              if (out[name]) throw new Error(\"PSBT: Same keys: \".concat(name, \" (key=\").concat(key, \" value=\").concat(value, \")\"));\n              out[name] = value;\n              noKey[name] = true;\n              continue;\n            }\n          } else {\n            // For unknown: add key type inside key\n            key = {\n              type: elm.key.type,\n              key: elm.key.key\n            };\n          }\n          // Only keyed elements at this point\n          if (noKey[name]) throw new Error(\"PSBT: Key type with empty key and no key=\".concat(name, \" val=\").concat(value));\n          if (!out[name]) out[name] = [];\n          out[name].push([key, value]);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return out;\n    }\n  });\n}\n// Basic sanity check for scripts\nfunction checkWSH(s, witnessScript) {\n  if (!P.equalBytes(s.hash, sha256(witnessScript))) throw new Error('checkScript: wsh wrong witnessScript hash');\n  var w = OutScript.decode(witnessScript);\n  if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms') throw new Error(\"checkScript: P2\".concat(w.type, \" cannot be wrapped in P2SH\"));\n  if (w.type === 'wpkh' || w.type === 'sh') throw new Error(\"checkScript: P2\".concat(w.type, \" cannot be wrapped in P2WSH\"));\n}\nfunction checkScript(script, redeemScript, witnessScript) {\n  if (script) {\n    var s = OutScript.decode(script);\n    // ms||pk maybe work, but there will be no address, hard to spend\n    if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk') throw new Error(\"checkScript: non-wrapped \".concat(s.type));\n    if (s.type === 'sh' && redeemScript) {\n      if (!P.equalBytes(s.hash, hash160(redeemScript))) throw new Error('checkScript: sh wrong redeemScript hash');\n      var r = OutScript.decode(redeemScript);\n      if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms') throw new Error(\"checkScript: P2\".concat(r.type, \" cannot be wrapped in P2SH\"));\n      // Not sure if this unspendable, but we cannot represent this via PSBT\n      if (r.type === 'sh') throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n    }\n    if (s.type === 'wsh' && witnessScript) checkWSH(s, witnessScript);\n  }\n  if (redeemScript) {\n    var _r = OutScript.decode(redeemScript);\n    if (_r.type === 'wsh' && witnessScript) checkWSH(_r, witnessScript);\n  }\n}\nvar PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), function (i) {\n  if (i.finalScriptWitness && !i.finalScriptWitness.length) throw new Error('validateInput: wmpty finalScriptWitness');\n  //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n  if (i.partialSig && !i.partialSig.length) throw new Error('Empty partialSig');\n  if (i.partialSig) {\n    var _iterator6 = _createForOfIteratorHelper(i.partialSig),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var _step6$value = _slicedToArray(_step6.value, 1),\n          k = _step6$value[0];\n        validatePubkey(k, PubT.ecdsa);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n  if (i.bip32Derivation) {\n    var _iterator7 = _createForOfIteratorHelper(i.bip32Derivation),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _step7$value = _slicedToArray(_step7.value, 1),\n          _k3 = _step7$value[0];\n        validatePubkey(_k3, PubT.ecdsa);\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n  }\n  // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n  if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000) throw new Error(\"validateInput: wrong timeLocktime=\".concat(i.requiredTimeLocktime));\n  // unsigned little endian integer greater than 0 and less than 500000000\n  if (i.requiredHeightLocktime !== undefined && (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000)) throw new Error(\"validateInput: wrong heighLocktime=\".concat(i.requiredHeightLocktime));\n  if (i.nonWitnessUtxo && i.index !== undefined) {\n    var last = i.nonWitnessUtxo.outputs.length - 1;\n    if (i.index > last) throw new Error(\"validateInput: index(\".concat(i.index, \") not in nonWitnessUtxo\"));\n    var prevOut = i.nonWitnessUtxo.outputs[i.index];\n    if (i.witnessUtxo && (!P.equalBytes(i.witnessUtxo.script, prevOut.script) || i.witnessUtxo.amount !== prevOut.amount)) throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n  }\n  if (i.tapLeafScript) {\n    // tap leaf version appears here twice: in control block and at the end of script\n    var _iterator8 = _createForOfIteratorHelper(i.tapLeafScript),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _step8$value = _slicedToArray(_step8.value, 2),\n          _k4 = _step8$value[0],\n          v = _step8$value[1];\n        if ((_k4.version & 254) !== v[v.length - 1]) throw new Error('validateInput: tapLeafScript version mimatch');\n        if (v[v.length - 1] & 1) throw new Error('validateInput: tapLeafScript version has parity bit!');\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n  }\n  // Validate txid for nonWitnessUtxo is correct\n  if (i.nonWitnessUtxo && i.index && i.txid) {\n    var outputs = i.nonWitnessUtxo.outputs;\n    if (outputs.length - 1 < i.index) throw new Error('nonWitnessUtxo: incorect output index');\n    var tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo));\n    var txid = hex.encode(i.txid);\n    if (tx.id !== txid) throw new Error(\"nonWitnessUtxo: wrong txid, exp=\".concat(txid, \" got=\").concat(tx.id));\n  }\n  return i;\n});\nvar PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), function (o) {\n  if (o.bip32Derivation) {\n    var _iterator9 = _createForOfIteratorHelper(o.bip32Derivation),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _step9$value = _slicedToArray(_step9.value, 1),\n          k = _step9$value[0];\n        validatePubkey(k, PubT.ecdsa);\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n  return o;\n});\nvar PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), function (g) {\n  var version = g.version || 0;\n  if (version === 0) {\n    if (!g.unsignedTx) throw new Error('PSBTv0: missing unsignedTx');\n    if (g.unsignedTx.segwitFlag || g.unsignedTx.witnesses) throw new Error('PSBTv0: witness in unsingedTx');\n    var _iterator10 = _createForOfIteratorHelper(g.unsignedTx.inputs),\n      _step10;\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var inp = _step10.value;\n        if (inp.finalScriptSig && inp.finalScriptSig.length) throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n  }\n  return g;\n});\nexport var _RawPSBTV0 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n  outputs: P.array(null, PSBTOutputCoder)\n});\nexport var _RawPSBTV2 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/inputCount', PSBTInputCoder),\n  outputs: P.array('global/outputCount', PSBTOutputCoder)\n});\nexport var _DebugPSBT = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  items: P.array(null, P.apply(P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])), P.coders.dict()))\n});\nfunction validatePSBTFields(version, info, lst) {\n  for (var k in lst) {\n    if (k === 'unknown') continue;\n    if (!info[k]) continue;\n    var _PSBTKeyInfo = PSBTKeyInfo(info[k]),\n      allowInc = _PSBTKeyInfo.allowInc;\n    if (!allowInc.includes(version)) throw new Error(\"PSBTv\".concat(version, \": field \").concat(k, \" is not allowed\"));\n  }\n  for (var _k5 in info) {\n    var _PSBTKeyInfo2 = PSBTKeyInfo(info[_k5]),\n      reqInc = _PSBTKeyInfo2.reqInc;\n    if (reqInc.includes(version) && lst[_k5] === undefined) throw new Error(\"PSBTv\".concat(version, \": missing required field \").concat(_k5));\n  }\n}\nfunction cleanPSBTFields(version, info, lst) {\n  var out = {};\n  for (var _k in lst) {\n    var k = _k;\n    if (k !== 'unknown') {\n      if (!info[k]) continue;\n      var _PSBTKeyInfo3 = PSBTKeyInfo(info[k]),\n        allowInc = _PSBTKeyInfo3.allowInc,\n        silentIgnore = _PSBTKeyInfo3.silentIgnore;\n      if (!allowInc.includes(version)) {\n        if (silentIgnore) continue;\n        throw new Error(\"Failed to serialize in PSBTv\".concat(version, \": \").concat(k, \" but versions allows inclusion=\").concat(allowInc));\n      }\n    }\n    out[k] = lst[k];\n  }\n  return out;\n}\nfunction validatePSBT(tx) {\n  var version = tx && tx.global && tx.global.version || 0;\n  validatePSBTFields(version, PSBTGlobal, tx.global);\n  var _iterator11 = _createForOfIteratorHelper(tx.inputs),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var i = _step11.value;\n      validatePSBTFields(version, PSBTInput, i);\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  var _iterator12 = _createForOfIteratorHelper(tx.outputs),\n    _step12;\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var o = _step12.value;\n      validatePSBTFields(version, PSBTOutput, o);\n    }\n    // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n  var inputCount = !version ? tx.global.unsignedTx.inputs.length : tx.global.inputCount;\n  if (tx.inputs.length < inputCount) throw new Error('Not enough inputs');\n  var inputsLeft = tx.inputs.slice(inputCount);\n  if (inputsLeft.length > 1 || inputsLeft.length && Object.keys(inputsLeft[0]).length) throw new Error(\"Unexpected inputs left in tx=\".concat(inputsLeft));\n  // Same for inputs\n  var outputCount = !version ? tx.global.unsignedTx.outputs.length : tx.global.outputCount;\n  if (tx.outputs.length < outputCount) throw new Error('Not outputs inputs');\n  var outputsLeft = tx.outputs.slice(outputCount);\n  if (outputsLeft.length > 1 || outputsLeft.length && Object.keys(outputsLeft[0]).length) throw new Error(\"Unexpected outputs left in tx=\".concat(outputsLeft));\n  return tx;\n}\nfunction mergeKeyMap(psbtEnum, val, cur, allowedFields) {\n  var res = _objectSpread(_objectSpread({}, cur), val);\n  // All arguments can be provided as hex\n  var _loop2 = function _loop2(k) {\n    var key = k;\n    var _psbtEnum$key = _slicedToArray(psbtEnum[key], 3),\n      _ = _psbtEnum$key[0],\n      kC = _psbtEnum$key[1],\n      vC = _psbtEnum$key[2];\n    var cannotChange = allowedFields && !allowedFields.includes(k);\n    if (val[k] === undefined && k in val) {\n      if (cannotChange) throw new Error(\"Cannot remove signed field=\".concat(k));\n      delete res[k];\n    } else if (kC) {\n      var oldKV = cur && cur[k] ? cur[k] : [];\n      var newKV = val[key];\n      if (newKV) {\n        if (!Array.isArray(newKV)) throw new Error(\"keyMap(\".concat(k, \"): KV pairs should be [k, v][]\"));\n        // Decode hex in k-v\n        newKV = newKV.map(function (val) {\n          if (val.length !== 2) throw new Error(\"keyMap(\".concat(k, \"): KV pairs should be [k, v][]\"));\n          return [typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0], typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1]];\n        });\n        var map = {};\n        var add = function add(kStr, k, v) {\n          if (map[kStr] === undefined) {\n            map[kStr] = [k, v];\n            return;\n          }\n          var oldVal = hex.encode(vC.encode(map[kStr][1]));\n          var newVal = hex.encode(vC.encode(v));\n          if (oldVal !== newVal) throw new Error(\"keyMap(\".concat(key, \"): same key=\").concat(kStr, \" oldVal=\").concat(oldVal, \" newVal=\").concat(newVal));\n        };\n        var _iterator13 = _createForOfIteratorHelper(oldKV),\n          _step13;\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var _step13$value = _slicedToArray(_step13.value, 2),\n              _k7 = _step13$value[0],\n              v = _step13$value[1];\n            var kStr = hex.encode(kC.encode(_k7));\n            add(kStr, _k7, v);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n        var _iterator14 = _createForOfIteratorHelper(newKV),\n          _step14;\n        try {\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var _step14$value = _slicedToArray(_step14.value, 2),\n              _k8 = _step14$value[0],\n              _v = _step14$value[1];\n            var _kStr = hex.encode(kC.encode(_k8));\n            // undefined removes previous value\n            if (_v === undefined) {\n              if (cannotChange) throw new Error(\"Cannot remove signed field=\".concat(key, \"/\").concat(_k8));\n              delete map[_kStr];\n            } else add(_kStr, _k8, _v);\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n        res[key] = Object.values(map);\n      }\n    } else if (typeof res[k] === 'string') {\n      res[k] = vC.decode(hex.decode(res[k]));\n    } else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n      if (!P.equalBytes(vC.encode(val[k]), vC.encode(cur[k]))) throw new Error(\"Cannot change signed field=\".concat(k));\n    }\n  };\n  for (var k in psbtEnum) {\n    _loop2(k);\n  }\n  // Remove unknown keys\n  for (var _k6 in res) if (!psbtEnum[_k6]) delete res[_k6];\n  return res;\n}\nexport var RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport var RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n// (TxHash, Idx)\nvar TxHashIdx = P.struct({\n  txid: P.bytes(32, true),\n  index: P.U32LE\n});\nvar OutPK = {\n  encode: function encode(from) {\n    if (from.length !== 2 || !isBytes(from[0]) || !isValidPubkey(from[0], PubT.ecdsa) || from[1] !== 'CHECKSIG') return;\n    return {\n      type: 'pk',\n      pubkey: from[0]\n    };\n  },\n  decode: function decode(to) {\n    return to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined;\n  }\n};\n// @ts-ignore\nexport var p2pk = function p2pk(pubkey) {\n  var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NETWORK;\n  // network is unused\n  if (!isValidPubkey(pubkey, PubT.ecdsa)) throw new Error('P2PK: invalid publicKey');\n  return {\n    type: 'pk',\n    script: OutScript.encode({\n      type: 'pk',\n      pubkey: pubkey\n    })\n  };\n};\nvar OutPKH = {\n  encode: function encode(from) {\n    if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !isBytes(from[2])) return;\n    if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG') return;\n    return {\n      type: 'pkh',\n      hash: from[2]\n    };\n  },\n  decode: function decode(to) {\n    return to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined;\n  }\n};\nexport var p2pkh = function p2pkh(publicKey) {\n  var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NETWORK;\n  if (!isValidPubkey(publicKey, PubT.ecdsa)) throw new Error('P2PKH: invalid publicKey');\n  var hash = hash160(publicKey);\n  return {\n    type: 'pkh',\n    script: OutScript.encode({\n      type: 'pkh',\n      hash: hash\n    }),\n    address: Address(network).encode({\n      type: 'pkh',\n      hash: hash\n    })\n  };\n};\nvar OutSH = {\n  encode: function encode(from) {\n    if (from.length !== 3 || from[0] !== 'HASH160' || !isBytes(from[1]) || from[2] !== 'EQUAL') return;\n    return {\n      type: 'sh',\n      hash: from[1]\n    };\n  },\n  decode: function decode(to) {\n    return to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined;\n  }\n};\nexport var p2sh = function p2sh(child) {\n  var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NETWORK;\n  // It is already tested inside noble-hashes and checkScript\n  var cs = child.script;\n  if (!isBytes(cs)) throw new Error(\"Wrong script: \".concat(typeof child.script, \", expected Uint8Array\"));\n  var hash = hash160(cs);\n  var script = OutScript.encode({\n    type: 'sh',\n    hash: hash\n  });\n  checkScript(script, cs, child.witnessScript);\n  var res = {\n    type: 'sh',\n    redeemScript: cs,\n    script: OutScript.encode({\n      type: 'sh',\n      hash: hash\n    }),\n    address: Address(network).encode({\n      type: 'sh',\n      hash: hash\n    })\n  };\n  if (child.witnessScript) res.witnessScript = child.witnessScript;\n  return res;\n};\nvar OutWSH = {\n  encode: function encode(from) {\n    if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1])) return;\n    if (from[1].length !== 32) return;\n    return {\n      type: 'wsh',\n      hash: from[1]\n    };\n  },\n  decode: function decode(to) {\n    return to.type === 'wsh' ? [0, to.hash] : undefined;\n  }\n};\nexport var p2wsh = function p2wsh(child) {\n  var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NETWORK;\n  var cs = child.script;\n  if (!isBytes(cs)) throw new Error(\"Wrong script: \".concat(typeof cs, \", expected Uint8Array\"));\n  var hash = sha256(cs);\n  var script = OutScript.encode({\n    type: 'wsh',\n    hash: hash\n  });\n  checkScript(script, undefined, cs);\n  return {\n    type: 'wsh',\n    witnessScript: cs,\n    script: OutScript.encode({\n      type: 'wsh',\n      hash: hash\n    }),\n    address: Address(network).encode({\n      type: 'wsh',\n      hash: hash\n    })\n  };\n};\nvar OutWPKH = {\n  encode: function encode(from) {\n    if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1])) return;\n    if (from[1].length !== 20) return;\n    return {\n      type: 'wpkh',\n      hash: from[1]\n    };\n  },\n  decode: function decode(to) {\n    return to.type === 'wpkh' ? [0, to.hash] : undefined;\n  }\n};\nexport var p2wpkh = function p2wpkh(publicKey) {\n  var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NETWORK;\n  if (!isValidPubkey(publicKey, PubT.ecdsa)) throw new Error('P2WPKH: invalid publicKey');\n  if (publicKey.length === 65) throw new Error('P2WPKH: uncompressed public key');\n  var hash = hash160(publicKey);\n  return {\n    type: 'wpkh',\n    script: OutScript.encode({\n      type: 'wpkh',\n      hash: hash\n    }),\n    address: Address(network).encode({\n      type: 'wpkh',\n      hash: hash\n    })\n  };\n};\nvar OutMS = {\n  encode: function encode(from) {\n    var last = from.length - 1;\n    if (from[last] !== 'CHECKMULTISIG') return;\n    var m = from[0];\n    var n = from[last - 1];\n    if (typeof m !== 'number' || typeof n !== 'number') return;\n    var pubkeys = from.slice(1, -2);\n    if (n !== pubkeys.length) return;\n    var _iterator15 = _createForOfIteratorHelper(pubkeys),\n      _step15;\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var pub = _step15.value;\n        if (!isBytes(pub)) return;\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n    return {\n      type: 'ms',\n      m: m,\n      pubkeys: pubkeys\n    }; // we don't need n, since it is the same as pubkeys\n  },\n\n  // checkmultisig(n, ..pubkeys, m)\n  decode: function decode(to) {\n    return to.type === 'ms' ? [to.m].concat(_toConsumableArray(to.pubkeys), [to.pubkeys.length, 'CHECKMULTISIG']) : undefined;\n  }\n};\nexport var p2ms = function p2ms(m, pubkeys) {\n  var allowSamePubkeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'ms',\n    script: OutScript.encode({\n      type: 'ms',\n      pubkeys: pubkeys,\n      m: m\n    })\n  };\n};\nvar OutTR = {\n  encode: function encode(from) {\n    if (from.length !== 2 || from[0] !== 1 || !isBytes(from[1])) return;\n    return {\n      type: 'tr',\n      pubkey: from[1]\n    };\n  },\n  decode: function decode(to) {\n    return to.type === 'tr' ? [1, to.pubkey] : undefined;\n  }\n};\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList) {\n  // Clone input in order to not corrupt it\n  var lst = Array.from(taprootList);\n  // We have at least 2 elements => can create branch\n  while (lst.length >= 2) {\n    // Sort: elements with smallest weight are in the end of queue\n    lst.sort(function (a, b) {\n      return (b.weight || 1) - (a.weight || 1);\n    });\n    var b = lst.pop();\n    var a = lst.pop();\n    var weight = ((a === null || a === void 0 ? void 0 : a.weight) || 1) + ((b === null || b === void 0 ? void 0 : b.weight) || 1);\n    lst.push({\n      weight: weight,\n      // Unwrap children array\n      // TODO: Very hard to remove any here\n      childs: [(a === null || a === void 0 ? void 0 : a.childs) || a, (b === null || b === void 0 ? void 0 : b.childs) || b]\n    });\n  }\n  // At this point there is always 1 element in lst\n  var last = lst[0];\n  return (last === null || last === void 0 ? void 0 : last.childs) || last;\n}\nfunction checkTaprootScript(script, internalPubKey) {\n  var allowUnknownOutputs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var out = OutScript.decode(script);\n  if (out.type === 'unknown' && allowUnknownOutputs) return;\n  if (!['tr_ns', 'tr_ms'].includes(out.type)) throw new Error(\"P2TR: invalid leaf script=\".concat(out.type));\n  var outms = out;\n  if (!allowUnknownOutputs && outms.pubkeys) {\n    var _iterator16 = _createForOfIteratorHelper(outms.pubkeys),\n      _step16;\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var p = _step16.value;\n        if (P.equalBytes(p, TAPROOT_UNSPENDABLE_KEY)) throw new Error('Unspendable taproot key in leaf script');\n        // It's likely a mistake at this point:\n        // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n        // but will take more space and fees.\n        // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n        // User creates 2 of 3 multisig of keys [A, B, C],\n        // but key A always can spend whole output without signatures from other keys.\n        // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n        if (P.equalBytes(p, internalPubKey)) {\n          throw new Error('Using P2TR with leaf script with same key as internal key is not supported');\n        }\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n  }\n}\nfunction taprootHashTree(tree, internalPubKey) {\n  var allowUnknownOutputs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!tree) throw new Error('taprootHashTree: empty tree');\n  if (Array.isArray(tree) && tree.length === 1) tree = tree[0];\n  // Terminal node (leaf)\n  if (!Array.isArray(tree)) {\n    var _tree = tree,\n      version = _tree.leafVersion,\n      leafScript = _tree.script;\n    // Earliest tree walk where we can validate tapScripts\n    if (tree.tapLeafScript || tree.tapMerkleRoot && !P.equalBytes(tree.tapMerkleRoot, P.EMPTY)) throw new Error('P2TR: tapRoot leafScript cannot have tree');\n    var script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n    if (!isBytes(script)) throw new Error(\"checkScript: wrong script type=\".concat(script));\n    checkTaprootScript(script, internalPubKey, allowUnknownOutputs);\n    return {\n      type: 'leaf',\n      version: version,\n      script: script,\n      hash: tapLeafHash(script, version)\n    };\n  }\n  // If tree / branch is not binary tree, convert it\n  if (tree.length !== 2) tree = taprootListToTree(tree);\n  if (tree.length !== 2) throw new Error('hashTree: non binary tree!');\n  // branch\n  // Both nodes should exist\n  var left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs);\n  var right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs);\n  // We cannot swap left/right here, since it will change structure of tree\n  var _ref5 = [left.hash, right.hash],\n    lH = _ref5[0],\n    rH = _ref5[1];\n  if (_cmpBytes(rH, lH) === -1) {\n    var _ref6 = [rH, lH];\n    lH = _ref6[0];\n    rH = _ref6[1];\n  }\n  return {\n    type: 'branch',\n    left: left,\n    right: right,\n    hash: schnorr.utils.taggedHash('TapBranch', lH, rH)\n  };\n}\nfunction taprootAddPath(tree) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (!tree) throw new Error(\"taprootAddPath: empty tree\");\n  if (tree.type === 'leaf') return _objectSpread(_objectSpread({}, tree), {}, {\n    path: path\n  });\n  if (tree.type !== 'branch') throw new Error(\"taprootAddPath: wrong type=\".concat(tree));\n  return _objectSpread(_objectSpread({}, tree), {}, {\n    path: path,\n    // Left element has right hash in path and otherwise\n    left: taprootAddPath(tree.left, [tree.right.hash].concat(_toConsumableArray(path))),\n    right: taprootAddPath(tree.right, [tree.left.hash].concat(_toConsumableArray(path)))\n  });\n}\nfunction taprootWalkTree(tree) {\n  if (!tree) throw new Error(\"taprootAddPath: empty tree\");\n  if (tree.type === 'leaf') return [tree];\n  if (tree.type !== 'branch') throw new Error(\"taprootWalkTree: wrong type=\".concat(tree));\n  return [].concat(_toConsumableArray(taprootWalkTree(tree.left)), _toConsumableArray(taprootWalkTree(tree.right)));\n}\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport var TAPROOT_UNSPENDABLE_KEY = sha256(ProjPoint.BASE.toRawBytes(false));\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport function p2tr(internalPubKey, tree) {\n  var network = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NETWORK;\n  var allowUnknownOutputs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Unspendable\n  if (!internalPubKey && !tree) throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n  var pubKey = typeof internalPubKey === 'string' ? hex.decode(internalPubKey) : internalPubKey || TAPROOT_UNSPENDABLE_KEY;\n  if (!isValidPubkey(pubKey, PubT.schnorr)) throw new Error('p2tr: non-schnorr pubkey');\n  var hashedTree = tree ? taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs)) : undefined;\n  var tapMerkleRoot = hashedTree ? hashedTree.hash : undefined;\n  var _taprootTweakPubkey = taprootTweakPubkey(pubKey, tapMerkleRoot || P.EMPTY),\n    _taprootTweakPubkey2 = _slicedToArray(_taprootTweakPubkey, 2),\n    tweakedPubkey = _taprootTweakPubkey2[0],\n    parity = _taprootTweakPubkey2[1];\n  var leaves;\n  if (hashedTree) {\n    leaves = taprootWalkTree(hashedTree).map(function (l) {\n      return _objectSpread(_objectSpread({}, l), {}, {\n        controlBlock: TaprootControlBlock.encode({\n          version: (l.version || TAP_LEAF_VERSION) + parity,\n          internalKey: pubKey,\n          merklePath: l.path\n        })\n      });\n    });\n  }\n  var tapLeafScript;\n  if (leaves) {\n    tapLeafScript = leaves.map(function (l) {\n      return [TaprootControlBlock.decode(l.controlBlock), concat(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION]))];\n    });\n  }\n  var res = {\n    type: 'tr',\n    script: OutScript.encode({\n      type: 'tr',\n      pubkey: tweakedPubkey\n    }),\n    address: Address(network).encode({\n      type: 'tr',\n      pubkey: tweakedPubkey\n    }),\n    // For tests\n    tweakedPubkey: tweakedPubkey,\n    // PSBT stuff\n    tapInternalKey: pubKey\n  };\n  // Just in case someone would want to select a specific script\n  if (leaves) res.leaves = leaves;\n  if (tapLeafScript) res.tapLeafScript = tapLeafScript;\n  if (tapMerkleRoot) res.tapMerkleRoot = tapMerkleRoot;\n  return res;\n}\nvar OutTRNS = {\n  encode: function encode(from) {\n    var last = from.length - 1;\n    if (from[last] !== 'CHECKSIG') return;\n    var pubkeys = [];\n    // On error return, since it can be different script\n    for (var i = 0; i < last; i++) {\n      var elm = from[i];\n      if (i & 1) {\n        if (elm !== 'CHECKSIGVERIFY' || i === last - 1) return;\n        continue;\n      }\n      if (!isBytes(elm)) return;\n      pubkeys.push(elm);\n    }\n    return {\n      type: 'tr_ns',\n      pubkeys: pubkeys\n    };\n  },\n  decode: function decode(to) {\n    if (to.type !== 'tr_ns') return;\n    var out = [];\n    for (var i = 0; i < to.pubkeys.length - 1; i++) out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n    out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n    return out;\n  }\n};\n// Returns all combinations of size M from lst\nexport function combinations(m, list) {\n  var res = [];\n  if (!Array.isArray(list)) throw new Error('combinations: lst arg should be array');\n  var n = list.length;\n  if (m > n) throw new Error('combinations: m > lst.length, no combinations possible');\n  /*\n  Basically works as M nested loops like:\n  for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n  but since we cannot create nested loops dynamically, we unroll it to a single loop\n  */\n  var idx = Array.from({\n    length: m\n  }, function (_, i) {\n    return i;\n  });\n  var last = idx.length - 1;\n  main: for (;;) {\n    res.push(idx.map(function (i) {\n      return list[i];\n    }));\n    idx[last] += 1;\n    var i = last;\n    // Propagate increment\n    // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n    for (; i >= 0 && idx[i] > n - m + i; i--) {\n      idx[i] = 0;\n      // Overflow in idx[0], break\n      if (i === 0) break main;\n      idx[i - 1] += 1;\n    }\n    // Propagate: idx[i+1] = idx[idx]+1\n    for (i += 1; i < idx.length; i++) idx[i] = idx[i - 1] + 1;\n  }\n  return res;\n}\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport var p2tr_ns = function p2tr_ns(m, pubkeys) {\n  var allowSamePubkeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return combinations(m, pubkeys).map(function (i) {\n    return {\n      type: 'tr_ns',\n      script: OutScript.encode({\n        type: 'tr_ns',\n        pubkeys: i\n      })\n    };\n  });\n};\n// Taproot public key (case of p2tr_ns)\nexport var p2tr_pk = function p2tr_pk(pubkey) {\n  return p2tr_ns(1, [pubkey], undefined)[0];\n};\nvar OutTRMS = {\n  encode: function encode(from) {\n    var last = from.length - 1;\n    if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG') return;\n    var pubkeys = [];\n    var m = OpToNum(from[last - 1]);\n    if (typeof m !== 'number') return;\n    for (var i = 0; i < last - 1; i++) {\n      var elm = from[i];\n      if (i & 1) {\n        if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD')) throw new Error('OutScript.encode/tr_ms: wrong element');\n        continue;\n      }\n      if (!isBytes(elm)) throw new Error('OutScript.encode/tr_ms: wrong key element');\n      pubkeys.push(elm);\n    }\n    return {\n      type: 'tr_ms',\n      pubkeys: pubkeys,\n      m: m\n    };\n  },\n  decode: function decode(to) {\n    if (to.type !== 'tr_ms') return;\n    var out = [to.pubkeys[0], 'CHECKSIG'];\n    for (var i = 1; i < to.pubkeys.length; i++) out.push(to.pubkeys[i], 'CHECKSIGADD');\n    out.push(to.m, 'NUMEQUAL');\n    return out;\n  }\n};\nexport function p2tr_ms(m, pubkeys) {\n  var allowSamePubkeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'tr_ms',\n    script: OutScript.encode({\n      type: 'tr_ms',\n      pubkeys: pubkeys,\n      m: m\n    })\n  };\n}\nvar OutUnknown = {\n  encode: function encode(from) {\n    return {\n      type: 'unknown',\n      script: Script.encode(from)\n    };\n  },\n  decode: function decode(to) {\n    return to.type === 'unknown' ? Script.decode(to.script) : undefined;\n  }\n};\n// /Payments\nvar OutScripts = [OutPK, OutPKH, OutSH, OutWSH, OutWPKH, OutMS, OutTR, OutTRNS, OutTRMS, OutUnknown];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nvar _OutScript = P.apply(Script, P.coders.match(OutScripts));\n// We can validate this once, because of packed & coders\nexport var OutScript = P.validate(_OutScript, function (i) {\n  if (i.type === 'pk' && !isValidPubkey(i.pubkey, PubT.ecdsa)) throw new Error('OutScript/pk: wrong key');\n  if ((i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') && (!isBytes(i.hash) || i.hash.length !== 20)) throw new Error(\"OutScript/\".concat(i.type, \": wrong hash\"));\n  if (i.type === 'wsh' && (!isBytes(i.hash) || i.hash.length !== 32)) throw new Error(\"OutScript/wsh: wrong hash\");\n  if (i.type === 'tr' && (!isBytes(i.pubkey) || !isValidPubkey(i.pubkey, PubT.schnorr))) throw new Error('OutScript/tr: wrong taproot public key');\n  if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms') if (!Array.isArray(i.pubkeys)) throw new Error('OutScript/multisig: wrong pubkeys array');\n  if (i.type === 'ms') {\n    var n = i.pubkeys.length;\n    var _iterator17 = _createForOfIteratorHelper(i.pubkeys),\n      _step17;\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var p = _step17.value;\n        if (!isValidPubkey(p, PubT.ecdsa)) throw new Error('OutScript/multisig: wrong pubkey');\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n    if (i.m <= 0 || n > 16 || i.m > n) throw new Error('OutScript/multisig: invalid params');\n  }\n  if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n    var _iterator18 = _createForOfIteratorHelper(i.pubkeys),\n      _step18;\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var _p = _step18.value;\n        if (!isValidPubkey(_p, PubT.schnorr)) throw new Error(\"OutScript/\".concat(i.type, \": wrong pubkey\"));\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n  }\n  if (i.type === 'tr_ms') {\n    var _n = i.pubkeys.length;\n    if (i.m <= 0 || _n > 999 || i.m > _n) throw new Error('OutScript/tr_ms: invalid params');\n  }\n  return i;\n});\n// Address\nfunction validateWitness(version, data) {\n  if (data.length < 2 || data.length > 40) throw new Error('Witness: invalid length');\n  if (version > 16) throw new Error('Witness: invalid version');\n  if (version === 0 && !(data.length === 20 || data.length === 32)) throw new Error('Witness: invalid length for version');\n}\nexport function programToWitness(version, data) {\n  var network = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NETWORK;\n  validateWitness(version, data);\n  var coder = version === 0 ? bech32 : bech32m;\n  return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\nfunction formatKey(hashed, prefix) {\n  return base58check.encode(concat(Uint8Array.from(prefix), hashed));\n}\nexport function WIF() {\n  var network = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NETWORK;\n  return {\n    encode: function encode(privKey) {\n      var compressed = concat(privKey, new Uint8Array([0x01]));\n      return formatKey(compressed.subarray(0, 33), [network.wif]);\n    },\n    decode: function decode(wif) {\n      var parsed = base58check.decode(wif);\n      if (parsed[0] !== network.wif) throw new Error('Wrong WIF prefix');\n      parsed = parsed.subarray(1);\n      // Check what it is. Compressed flag?\n      if (parsed.length !== 33) throw new Error('Wrong WIF length');\n      if (parsed[32] !== 0x01) throw new Error('Wrong WIF postfix');\n      return parsed.subarray(0, -1);\n    }\n  };\n}\n// Returns OutType, which can be used to create outscript\nexport function Address() {\n  var network = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NETWORK;\n  return {\n    encode: function encode(from) {\n      var type = from.type;\n      if (type === 'wpkh') return programToWitness(0, from.hash, network);else if (type === 'wsh') return programToWitness(0, from.hash, network);else if (type === 'tr') return programToWitness(1, from.pubkey, network);else if (type === 'pkh') return formatKey(from.hash, [network.pubKeyHash]);else if (type === 'sh') return formatKey(from.hash, [network.scriptHash]);\n      throw new Error(\"Unknown address type=\".concat(type));\n    },\n    decode: function decode(address) {\n      if (address.length < 14 || address.length > 74) throw new Error('Invalid address length');\n      // Bech32\n      if (network.bech32 && address.toLowerCase().startsWith(network.bech32)) {\n        var res;\n        try {\n          res = bech32.decode(address);\n          if (res.words[0] !== 0) throw new Error(\"bech32: wrong version=\".concat(res.words[0]));\n        } catch (_) {\n          // Starting from version 1 it is decoded as bech32m\n          res = bech32m.decode(address);\n          if (res.words[0] === 0) throw new Error(\"bech32m: wrong version=\".concat(res.words[0]));\n        }\n        if (res.prefix !== network.bech32) throw new Error(\"wrong bech32 prefix=\".concat(res.prefix));\n        var _res$words = _toArray(res.words),\n          version = _res$words[0],\n          program = _res$words.slice(1);\n        var _data = bech32.fromWords(program);\n        validateWitness(version, _data);\n        if (version === 0 && _data.length === 32) return {\n          type: 'wsh',\n          hash: _data\n        };else if (version === 0 && _data.length === 20) return {\n          type: 'wpkh',\n          hash: _data\n        };else if (version === 1 && _data.length === 32) return {\n          type: 'tr',\n          pubkey: _data\n        };else throw new Error('Unknown witness program');\n      }\n      var data = base58check.decode(address);\n      if (data.length !== 21) throw new Error('Invalid base58 address');\n      // Pay To Public Key Hash\n      if (data[0] === network.pubKeyHash) {\n        return {\n          type: 'pkh',\n          hash: data.slice(1)\n        };\n      } else if (data[0] === network.scriptHash) {\n        return {\n          type: 'sh',\n          hash: data.slice(1)\n        };\n      }\n      throw new Error(\"Invalid address prefix=\".concat(data[0]));\n    }\n  };\n}\n// /Address\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport var SignatureHash;\n(function (SignatureHash) {\n  SignatureHash[SignatureHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SignatureHash[SignatureHash[\"ALL\"] = 1] = \"ALL\";\n  SignatureHash[SignatureHash[\"NONE\"] = 2] = \"NONE\";\n  SignatureHash[SignatureHash[\"SINGLE\"] = 3] = \"SINGLE\";\n  SignatureHash[SignatureHash[\"ANYONECANPAY\"] = 128] = \"ANYONECANPAY\";\n})(SignatureHash || (SignatureHash = {}));\nexport var SigHash;\n(function (SigHash) {\n  SigHash[SigHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SigHash[SigHash[\"ALL\"] = 1] = \"ALL\";\n  SigHash[SigHash[\"NONE\"] = 2] = \"NONE\";\n  SigHash[SigHash[\"SINGLE\"] = 3] = \"SINGLE\";\n  SigHash[SigHash[\"DEFAULT_ANYONECANPAY\"] = 128] = \"DEFAULT_ANYONECANPAY\";\n  SigHash[SigHash[\"ALL_ANYONECANPAY\"] = 129] = \"ALL_ANYONECANPAY\";\n  SigHash[SigHash[\"NONE_ANYONECANPAY\"] = 130] = \"NONE_ANYONECANPAY\";\n  SigHash[SigHash[\"SINGLE_ANYONECANPAY\"] = 131] = \"SINGLE_ANYONECANPAY\";\n})(SigHash || (SigHash = {}));\nfunction validateSigHash(s) {\n  if (typeof s !== 'number' || typeof SigHash[s] !== 'string') throw new Error(\"Invalid SigHash=\".concat(s));\n  return s;\n}\nfunction unpackSighash(hashType) {\n  var masked = hashType & 31;\n  return {\n    isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n    isNone: masked === SignatureHash.NONE,\n    isSingle: masked === SignatureHash.SINGLE\n  };\n}\nexport var _sortPubkeys = function _sortPubkeys(pubkeys) {\n  return Array.from(pubkeys).sort(_cmpBytes);\n};\n// Force check index/txid/sequence\nfunction inputBeforeSign(i) {\n  if (i.txid === undefined || i.index === undefined) throw new Error('Transaction/input: txid and index required');\n  return {\n    txid: i.txid,\n    index: i.index,\n    sequence: def(i.sequence, DEFAULT_SEQUENCE),\n    finalScriptSig: def(i.finalScriptSig, P.EMPTY)\n  };\n}\nfunction cleanFinalInput(i) {\n  for (var _k in i) {\n    var k = _k;\n    if (!PSBTInputFinalKeys.includes(k)) delete i[k];\n  }\n}\n// Force check amount/script\nfunction outputBeforeSign(i) {\n  if (i.script === undefined || i.amount === undefined) throw new Error('Transaction/output: script and amount required');\n  return {\n    script: i.script,\n    amount: i.amount\n  };\n}\nexport var TAP_LEAF_VERSION = 0xc0;\nexport var tapLeafHash = function tapLeafHash(script) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TAP_LEAF_VERSION;\n  return schnorr.utils.taggedHash('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\n};\nfunction getTaprootKeys(privKey, pubKey, internalKey) {\n  var merkleRoot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : P.EMPTY;\n  if (P.equalBytes(internalKey, pubKey)) {\n    privKey = taprootTweakPrivKey(privKey, merkleRoot);\n    pubKey = schnorr.getPublicKey(privKey);\n  }\n  return {\n    privKey: privKey,\n    pubKey: pubKey\n  };\n}\nvar toStr = {}.toString;\nfunction validateOpts(opts) {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error(\"Wrong object type for transaction options: \".concat(opts));\n  var _opts = _objectSpread(_objectSpread({}, opts), {}, {\n    // Defaults\n    version: def(opts.version, DEFAULT_VERSION),\n    lockTime: def(opts.lockTime, 0),\n    PSBTVersion: def(opts.PSBTVersion, 0)\n  });\n  if (typeof _opts.allowUnknowInput !== 'undefined') opts.allowUnknownInputs = _opts.allowUnknowInput;\n  if (typeof _opts.allowUnknowOutput !== 'undefined') opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n  // 0 and -1 happens in tests\n  if (![-1, 0, 1, 2].includes(_opts.version)) throw new Error(\"Unknown version: \".concat(_opts.version));\n  if (typeof _opts.lockTime !== 'number') throw new Error('Transaction lock time should be number');\n  P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n  // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n  // can lead to constructing broken transactions\n  if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2) throw new Error(\"Unknown PSBT version \".concat(_opts.PSBTVersion));\n  // Flags\n  for (var _i2 = 0, _arr = ['allowUnknownOutputs', 'allowUnknownInputs', 'disableScriptCheck', 'bip174jsCompat', 'allowLegacyWitnessUtxo', 'lowR']; _i2 < _arr.length; _i2++) {\n    var k = _arr[_i2];\n    var v = _opts[k];\n    if (v === undefined) continue; // optional\n    if (typeof v !== 'boolean') throw new Error(\"Transation options wrong type: \".concat(k, \"=\").concat(v, \" (\").concat(typeof v, \")\"));\n  }\n  return Object.freeze(_opts);\n}\nexport var Transaction = /*#__PURE__*/function () {\n  function Transaction() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Transaction);\n    this.global = {};\n    this.inputs = []; // use getInput()\n    this.outputs = []; // use getOutput()\n    var _opts = this.opts = validateOpts(opts);\n    // Merge with global structure of PSBTv2\n    if (_opts.lockTime !== DEFAULT_LOCKTIME) this.global.fallbackLocktime = _opts.lockTime;\n    this.global.txVersion = _opts.version;\n  }\n  // Import\n  _createClass(Transaction, [{\n    key: \"toPSBT\",\n    value: function toPSBT() {\n      var PSBTVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.opts.PSBTVersion;\n      if (PSBTVersion !== 0 && PSBTVersion !== 2) throw new Error(\"Wrong PSBT version=\".concat(PSBTVersion));\n      var inputs = this.inputs.map(function (i) {\n        return cleanPSBTFields(PSBTVersion, PSBTInput, i);\n      });\n      var _iterator19 = _createForOfIteratorHelper(inputs),\n        _step19;\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var inp = _step19.value;\n          // Don't serialize empty fields\n          if (inp.partialSig && !inp.partialSig.length) delete inp.partialSig;\n          if (inp.finalScriptSig && !inp.finalScriptSig.length) delete inp.finalScriptSig;\n          if (inp.finalScriptWitness && !inp.finalScriptWitness.length) delete inp.finalScriptWitness;\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n      var outputs = this.outputs.map(function (i) {\n        return cleanPSBTFields(PSBTVersion, PSBTOutput, i);\n      });\n      var global = _objectSpread({}, this.global);\n      if (PSBTVersion === 0) {\n        global.unsignedTx = RawTx.decode(this.unsignedTx);\n        delete global.fallbackLocktime;\n        delete global.txVersion;\n      } else {\n        global.version = PSBTVersion;\n        global.txVersion = this.version;\n        global.inputCount = this.inputs.length;\n        global.outputCount = this.outputs.length;\n        if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME) delete global.fallbackLocktime;\n      }\n      if (this.opts.bip174jsCompat) {\n        if (!inputs.length) inputs.push({});\n        if (!outputs.length) outputs.push({});\n      }\n      return (PSBTVersion === 0 ? RawPSBTV0 : RawPSBTV2).encode({\n        global: global,\n        inputs: inputs,\n        outputs: outputs\n      });\n    }\n    // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n  }, {\n    key: \"lockTime\",\n    get: function get() {\n      var height = DEFAULT_LOCKTIME;\n      var heightCnt = 0;\n      var time = DEFAULT_LOCKTIME;\n      var timeCnt = 0;\n      var _iterator20 = _createForOfIteratorHelper(this.inputs),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var i = _step20.value;\n          if (i.requiredHeightLocktime) {\n            height = Math.max(height, i.requiredHeightLocktime);\n            heightCnt++;\n          }\n          if (i.requiredTimeLocktime) {\n            time = Math.max(time, i.requiredTimeLocktime);\n            timeCnt++;\n          }\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      if (heightCnt && heightCnt >= timeCnt) return height;\n      if (time !== DEFAULT_LOCKTIME) return time;\n      return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      // Should be not possible\n      if (this.global.txVersion === undefined) throw new Error('No global.txVersion');\n      return this.global.txVersion;\n    }\n  }, {\n    key: \"inputStatus\",\n    value: function inputStatus(idx) {\n      this.checkInputIdx(idx);\n      var input = this.inputs[idx];\n      // Finalized\n      if (input.finalScriptSig && input.finalScriptSig.length) return 'finalized';\n      if (input.finalScriptWitness && input.finalScriptWitness.length) return 'finalized';\n      // Signed taproot\n      if (input.tapKeySig) return 'signed';\n      if (input.tapScriptSig && input.tapScriptSig.length) return 'signed';\n      // Signed\n      if (input.partialSig && input.partialSig.length) return 'signed';\n      return 'unsigned';\n    }\n    // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n    // We will lose some vectors -> smaller test coverage of preimages (very important!)\n  }, {\n    key: \"inputSighash\",\n    value: function inputSighash(idx) {\n      this.checkInputIdx(idx);\n      var sighash = this.inputType(this.inputs[idx]).sighash;\n      // ALL or DEFAULT -- everything signed\n      // NONE           -- all inputs + no outputs\n      // SINGLE         -- all inputs + output with same index\n      // ALL + ANYONE   -- specific input + all outputs\n      // NONE + ANYONE  -- specific input + no outputs\n      // SINGLE         -- specific inputs + output with same index\n      var sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 3;\n      var sigInputs = sighash & SignatureHash.ANYONECANPAY;\n      return {\n        sigInputs: sigInputs,\n        sigOutputs: sigOutputs\n      };\n    }\n    // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n    // Some cache will be nice, but there chance to have bugs with cache invalidation\n  }, {\n    key: \"signStatus\",\n    value: function signStatus() {\n      // if addInput or addOutput is not possible, then all inputs or outputs are signed\n      var addInput = true,\n        addOutput = true;\n      var inputs = [],\n        outputs = [];\n      for (var idx = 0; idx < this.inputs.length; idx++) {\n        var status = this.inputStatus(idx);\n        // Unsigned input doesn't affect anything\n        if (status === 'unsigned') continue;\n        var _this$inputSighash = this.inputSighash(idx),\n          sigInputs = _this$inputSighash.sigInputs,\n          sigOutputs = _this$inputSighash.sigOutputs;\n        // Input type\n        if (sigInputs === SignatureHash.ANYONECANPAY) inputs.push(idx);else addInput = false;\n        // Output type\n        if (sigOutputs === SignatureHash.ALL) addOutput = false;else if (sigOutputs === SignatureHash.SINGLE) outputs.push(idx);else if (sigOutputs === SignatureHash.NONE) {\n          // Doesn't affect any outputs at all\n        } else throw new Error(\"Wrong signature hash output type: \".concat(sigOutputs));\n      }\n      return {\n        addInput: addInput,\n        addOutput: addOutput,\n        inputs: inputs,\n        outputs: outputs\n      };\n    }\n  }, {\n    key: \"isFinal\",\n    get: function get() {\n      for (var idx = 0; idx < this.inputs.length; idx++) if (this.inputStatus(idx) !== 'finalized') return false;\n      return true;\n    }\n    // Info utils\n  }, {\n    key: \"hasWitnesses\",\n    get: function get() {\n      var out = false;\n      var _iterator21 = _createForOfIteratorHelper(this.inputs),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var i = _step21.value;\n          if (i.finalScriptWitness && i.finalScriptWitness.length) out = true;\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      return out;\n    }\n    // https://en.bitcoin.it/wiki/Weight_units\n  }, {\n    key: \"weight\",\n    get: function get() {\n      if (!this.isFinal) throw new Error('Transaction is not finalized');\n      // TODO: Can we find out how much witnesses/script will be used before signing?\n      var out = 32;\n      var outputs = this.outputs.map(outputBeforeSign);\n      if (this.hasWitnesses) out += 2;\n      out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n      out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n      var _iterator22 = _createForOfIteratorHelper(this.inputs),\n        _step22;\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var _i3 = _step22.value;\n          out += 160 + 4 * VarBytes.encode(_i3.finalScriptSig || P.EMPTY).length;\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n      var _iterator23 = _createForOfIteratorHelper(outputs),\n        _step23;\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var o = _step23.value;\n          out += 32 + 4 * VarBytes.encode(o.script).length;\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n      if (this.hasWitnesses) {\n        var _iterator24 = _createForOfIteratorHelper(this.inputs),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var i = _step24.value;\n            if (i.finalScriptWitness) out += RawWitness.encode(i.finalScriptWitness).length;\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      }\n      return out;\n    }\n  }, {\n    key: \"vsize\",\n    get: function get() {\n      return Math.ceil(this.weight / 4);\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      var withScriptSig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var withWitness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return RawTx.encode({\n        version: this.version,\n        lockTime: this.lockTime,\n        inputs: this.inputs.map(inputBeforeSign).map(function (i) {\n          return _objectSpread(_objectSpread({}, i), {}, {\n            finalScriptSig: withScriptSig && i.finalScriptSig || P.EMPTY\n          });\n        }),\n        outputs: this.outputs.map(outputBeforeSign),\n        witnesses: this.inputs.map(function (i) {\n          return i.finalScriptWitness || [];\n        }),\n        segwitFlag: withWitness && this.hasWitnesses\n      });\n    }\n  }, {\n    key: \"unsignedTx\",\n    get: function get() {\n      return this.toBytes(false, false);\n    }\n  }, {\n    key: \"hex\",\n    get: function get() {\n      return hex.encode(this.toBytes(true, this.hasWitnesses));\n    }\n  }, {\n    key: \"hash\",\n    get: function get() {\n      if (!this.isFinal) throw new Error('Transaction is not finalized');\n      return hex.encode(sha256x2(this.toBytes(true)));\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      if (!this.isFinal) throw new Error('Transaction is not finalized');\n      return hex.encode(sha256x2(this.toBytes(true)).reverse());\n    }\n    // Input stuff\n  }, {\n    key: \"checkInputIdx\",\n    value: function checkInputIdx(idx) {\n      if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length) throw new Error(\"Wrong input index=\".concat(idx));\n    }\n  }, {\n    key: \"getInput\",\n    value: function getInput(idx) {\n      this.checkInputIdx(idx);\n      return cloneDeep(this.inputs[idx]);\n    }\n  }, {\n    key: \"inputsLength\",\n    get: function get() {\n      return this.inputs.length;\n    }\n    // Modification\n  }, {\n    key: \"normalizeInput\",\n    value: function normalizeInput(i, cur, allowedFields) {\n      var nonWitnessUtxo = i.nonWitnessUtxo,\n        txid = i.txid;\n      // String support for common fields. We usually prefer Uint8Array to avoid errors (like hex looking string accidentally passed),\n      // however in case of nonWitnessUtxo it is better to expect string, since constructing this complex object will be difficult for user\n      if (typeof nonWitnessUtxo === 'string') nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n      if (isBytes(nonWitnessUtxo)) nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n      if (nonWitnessUtxo === undefined) nonWitnessUtxo = cur === null || cur === void 0 ? void 0 : cur.nonWitnessUtxo;\n      if (typeof txid === 'string') txid = hex.decode(txid);\n      if (txid === undefined) txid = cur === null || cur === void 0 ? void 0 : cur.txid;\n      var res = _objectSpread(_objectSpread(_objectSpread({}, cur), i), {}, {\n        nonWitnessUtxo: nonWitnessUtxo,\n        txid: txid\n      });\n      if (res.nonWitnessUtxo === undefined) delete res.nonWitnessUtxo;\n      if (res.sequence === undefined) res.sequence = DEFAULT_SEQUENCE;\n      if (res.tapMerkleRoot === null) delete res.tapMerkleRoot;\n      res = mergeKeyMap(PSBTInput, res, cur, allowedFields);\n      PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n      var prevOut;\n      if (res.nonWitnessUtxo && res.index !== undefined) prevOut = res.nonWitnessUtxo.outputs[res.index];else if (res.witnessUtxo) prevOut = res.witnessUtxo;\n      if (prevOut && !this.opts.disableScriptCheck) checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n      return res;\n    }\n  }, {\n    key: \"addInput\",\n    value: function addInput(input) {\n      var _ignoreSignStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!_ignoreSignStatus && !this.signStatus().addInput) throw new Error('Tx has signed inputs, cannot add new one');\n      this.inputs.push(this.normalizeInput(input));\n      return this.inputs.length - 1;\n    }\n  }, {\n    key: \"updateInput\",\n    value: function updateInput(idx, input) {\n      var _ignoreSignStatus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.checkInputIdx(idx);\n      var allowedFields = undefined;\n      if (!_ignoreSignStatus) {\n        var status = this.signStatus();\n        if (!status.addInput || status.inputs.includes(idx)) allowedFields = PSBTInputUnsignedKeys;\n      }\n      this.inputs[idx] = this.normalizeInput(input, this.inputs[idx], allowedFields);\n    }\n    // Output stuff\n  }, {\n    key: \"checkOutputIdx\",\n    value: function checkOutputIdx(idx) {\n      if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length) throw new Error(\"Wrong output index=\".concat(idx));\n    }\n  }, {\n    key: \"getOutput\",\n    value: function getOutput(idx) {\n      this.checkOutputIdx(idx);\n      return cloneDeep(this.outputs[idx]);\n    }\n  }, {\n    key: \"outputsLength\",\n    get: function get() {\n      return this.outputs.length;\n    }\n  }, {\n    key: \"normalizeOutput\",\n    value: function normalizeOutput(o, cur, allowedFields) {\n      var amount = o.amount,\n        script = o.script;\n      if (amount === undefined) amount = cur === null || cur === void 0 ? void 0 : cur.amount;\n      if (typeof amount !== 'bigint') throw new Error('amount must be bigint sats');\n      if (typeof script === 'string') script = hex.decode(script);\n      if (script === undefined) script = cur === null || cur === void 0 ? void 0 : cur.script;\n      var res = _objectSpread(_objectSpread(_objectSpread({}, cur), o), {}, {\n        amount: amount,\n        script: script\n      });\n      if (res.amount === undefined) delete res.amount;\n      res = mergeKeyMap(PSBTOutput, res, cur, allowedFields);\n      PSBTOutputCoder.encode(res);\n      if (res.script && !this.opts.allowUnknownOutputs && OutScript.decode(res.script).type === 'unknown') {\n        throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownScript=true, if you sure');\n      }\n      if (!this.opts.disableScriptCheck) checkScript(res.script, res.redeemScript, res.witnessScript);\n      return res;\n    }\n  }, {\n    key: \"addOutput\",\n    value: function addOutput(o) {\n      var _ignoreSignStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!_ignoreSignStatus && !this.signStatus().addOutput) throw new Error('Tx has signed outputs, cannot add new one');\n      this.outputs.push(this.normalizeOutput(o));\n      return this.outputs.length - 1;\n    }\n  }, {\n    key: \"updateOutput\",\n    value: function updateOutput(idx, output) {\n      var _ignoreSignStatus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.checkOutputIdx(idx);\n      var allowedFields = undefined;\n      if (!_ignoreSignStatus) {\n        var status = this.signStatus();\n        if (!status.addOutput || status.outputs.includes(idx)) allowedFields = PSBTOutputUnsignedKeys;\n      }\n      this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n    }\n  }, {\n    key: \"addOutputAddress\",\n    value: function addOutputAddress(address, amount) {\n      var network = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NETWORK;\n      return this.addOutput({\n        script: OutScript.encode(Address(network).decode(address)),\n        amount: amount\n      });\n    }\n    // Utils\n  }, {\n    key: \"fee\",\n    get: function get() {\n      var res = 0n;\n      var _iterator25 = _createForOfIteratorHelper(this.inputs),\n        _step25;\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var i = _step25.value;\n          var prevOut = this.prevOut(i);\n          if (!prevOut) throw new Error('Empty input amount');\n          res += prevOut.amount;\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n      var outputs = this.outputs.map(outputBeforeSign);\n      var _iterator26 = _createForOfIteratorHelper(outputs),\n        _step26;\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var o = _step26.value;\n          res -= o.amount;\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n      return res;\n    }\n    // Signing\n    // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n    // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n    // but we are trying to be less complicated for audit purpose for now.\n  }, {\n    key: \"preimageLegacy\",\n    value: function preimageLegacy(idx, prevOutScript, hashType) {\n      var _unpackSighash = unpackSighash(hashType),\n        isAny = _unpackSighash.isAny,\n        isNone = _unpackSighash.isNone,\n        isSingle = _unpackSighash.isSingle;\n      if (idx < 0 || !Number.isSafeInteger(idx)) throw new Error(\"Invalid input idx=\".concat(idx));\n      if (isSingle && idx >= this.outputs.length || idx >= this.inputs.length) return P.U256BE.encode(1n);\n      prevOutScript = Script.encode(Script.decode(prevOutScript).filter(function (i) {\n        return i !== 'CODESEPARATOR';\n      }));\n      var inputs = this.inputs.map(inputBeforeSign).map(function (input, inputIdx) {\n        return _objectSpread(_objectSpread({}, input), {}, {\n          finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY\n        });\n      });\n      if (isAny) inputs = [inputs[idx]];else if (isNone || isSingle) {\n        inputs = inputs.map(function (input, inputIdx) {\n          return _objectSpread(_objectSpread({}, input), {}, {\n            sequence: inputIdx === idx ? input.sequence : 0\n          });\n        });\n      }\n      var outputs = this.outputs.map(outputBeforeSign);\n      if (isNone) outputs = [];else if (isSingle) {\n        outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n      }\n      var tmpTx = RawTx.encode({\n        lockTime: this.lockTime,\n        version: this.version,\n        segwitFlag: false,\n        inputs: inputs,\n        outputs: outputs\n      });\n      return sha256x2(tmpTx, P.I32LE.encode(hashType));\n    }\n  }, {\n    key: \"preimageWitnessV0\",\n    value: function preimageWitnessV0(idx, prevOutScript, hashType, amount) {\n      var _unpackSighash2 = unpackSighash(hashType),\n        isAny = _unpackSighash2.isAny,\n        isNone = _unpackSighash2.isNone,\n        isSingle = _unpackSighash2.isSingle;\n      var inputHash = EMPTY32;\n      var sequenceHash = EMPTY32;\n      var outputHash = EMPTY32;\n      var inputs = this.inputs.map(inputBeforeSign);\n      var outputs = this.outputs.map(outputBeforeSign);\n      if (!isAny) inputHash = sha256x2.apply(void 0, _toConsumableArray(inputs.map(TxHashIdx.encode)));\n      if (!isAny && !isSingle && !isNone) sequenceHash = sha256x2.apply(void 0, _toConsumableArray(inputs.map(function (i) {\n        return P.U32LE.encode(i.sequence);\n      })));\n      if (!isSingle && !isNone) {\n        outputHash = sha256x2.apply(void 0, _toConsumableArray(outputs.map(RawOutput.encode)));\n      } else if (isSingle && idx < outputs.length) outputHash = sha256x2(RawOutput.encode(outputs[idx]));\n      var input = inputs[idx];\n      return sha256x2(P.I32LE.encode(this.version), inputHash, sequenceHash, P.bytes(32, true).encode(input.txid), P.U32LE.encode(input.index), VarBytes.encode(prevOutScript), P.U64LE.encode(amount), P.U32LE.encode(input.sequence), outputHash, P.U32LE.encode(this.lockTime), P.U32LE.encode(hashType));\n    }\n  }, {\n    key: \"preimageWitnessV1\",\n    value: function preimageWitnessV1(idx, prevOutScript, hashType, amount) {\n      var _schnorr$utils;\n      var codeSeparator = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n      var leafScript = arguments.length > 5 ? arguments[5] : undefined;\n      var leafVer = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0xc0;\n      var annex = arguments.length > 7 ? arguments[7] : undefined;\n      if (!Array.isArray(amount) || this.inputs.length !== amount.length) throw new Error(\"Invalid amounts array=\".concat(amount));\n      if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length) throw new Error(\"Invalid prevOutScript array=\".concat(prevOutScript));\n      var out = [P.U8.encode(0), P.U8.encode(hashType), P.I32LE.encode(this.version), P.U32LE.encode(this.lockTime)];\n      var outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 3;\n      var inType = hashType & SignatureHash.ANYONECANPAY;\n      var inputs = this.inputs.map(inputBeforeSign);\n      var outputs = this.outputs.map(outputBeforeSign);\n      if (inType !== SignatureHash.ANYONECANPAY) {\n        out.push.apply(out, _toConsumableArray([inputs.map(TxHashIdx.encode), amount.map(P.U64LE.encode), prevOutScript.map(VarBytes.encode), inputs.map(function (i) {\n          return P.U32LE.encode(i.sequence);\n        })].map(function (i) {\n          return sha256(concat.apply(void 0, _toConsumableArray(i)));\n        })));\n      }\n      if (outType === SignatureHash.ALL) {\n        out.push(sha256(concat.apply(void 0, _toConsumableArray(outputs.map(RawOutput.encode)))));\n      }\n      var spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n      out.push(new Uint8Array([spendType]));\n      if (inType === SignatureHash.ANYONECANPAY) {\n        var inp = inputs[idx];\n        out.push(TxHashIdx.encode(inp), P.U64LE.encode(amount[idx]), VarBytes.encode(prevOutScript[idx]), P.U32LE.encode(inp.sequence));\n      } else out.push(P.U32LE.encode(idx));\n      if (spendType & 1) out.push(sha256(VarBytes.encode(annex || P.EMPTY)));\n      if (outType === SignatureHash.SINGLE) out.push(idx < outputs.length ? sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n      if (leafScript) out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n      return (_schnorr$utils = schnorr.utils).taggedHash.apply(_schnorr$utils, ['TapSighash'].concat(out));\n    }\n    // Utils for sign/finalize\n    // Used pretty often, should be fast\n  }, {\n    key: \"prevOut\",\n    value: function prevOut(input) {\n      if (input.nonWitnessUtxo) {\n        if (input.index === undefined) throw new Error('Unknown input index');\n        return input.nonWitnessUtxo.outputs[input.index];\n      } else if (input.witnessUtxo) return input.witnessUtxo;else throw new Error('Cannot find previous output info');\n    }\n  }, {\n    key: \"inputType\",\n    value: function inputType(input) {\n      var txType = 'legacy';\n      var defaultSighash = SignatureHash.ALL;\n      var prevOut = this.prevOut(input);\n      var first = OutScript.decode(prevOut.script);\n      var type = first.type;\n      var cur = first;\n      var stack = [first];\n      if (first.type === 'tr') {\n        defaultSighash = SignatureHash.DEFAULT;\n        return {\n          txType: 'taproot',\n          type: 'tr',\n          last: first,\n          lastScript: prevOut.script,\n          defaultSighash: defaultSighash,\n          sighash: input.sighashType || defaultSighash\n        };\n      } else {\n        if (first.type === 'wpkh' || first.type === 'wsh') txType = 'segwit';\n        if (first.type === 'sh') {\n          if (!input.redeemScript) throw new Error('inputType: sh without redeemScript');\n          var child = OutScript.decode(input.redeemScript);\n          if (child.type === 'wpkh' || child.type === 'wsh') txType = 'segwit';\n          stack.push(child);\n          cur = child;\n          type += \"-\".concat(child.type);\n        }\n        // wsh can be inside sh\n        if (cur.type === 'wsh') {\n          if (!input.witnessScript) throw new Error('inputType: wsh without witnessScript');\n          var _child = OutScript.decode(input.witnessScript);\n          if (_child.type === 'wsh') txType = 'segwit';\n          stack.push(_child);\n          cur = _child;\n          type += \"-\".concat(_child.type);\n        }\n        var last = stack[stack.length - 1];\n        if (last.type === 'sh' || last.type === 'wsh') throw new Error('inputType: sh/wsh cannot be terminal type');\n        var lastScript = OutScript.encode(last);\n        var res = {\n          type: type,\n          txType: txType,\n          last: last,\n          lastScript: lastScript,\n          defaultSighash: defaultSighash,\n          sighash: input.sighashType || defaultSighash\n        };\n        if (txType === 'legacy' && !this.opts.allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n          throw new Error(\"Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure\");\n        }\n        return res;\n      }\n    }\n    // Signer can be privateKey OR instance of bip32 HD stuff\n  }, {\n    key: \"signIdx\",\n    value: function signIdx(privateKey, idx, allowedSighash, _auxRand) {\n      this.checkInputIdx(idx);\n      var input = this.inputs[idx];\n      var inputType = this.inputType(input);\n      // Handle BIP32 HDKey\n      if (!isBytes(privateKey)) {\n        if (!input.bip32Derivation || !input.bip32Derivation.length) throw new Error('bip32Derivation: empty');\n        var signers = input.bip32Derivation.filter(function (i) {\n          return i[1].fingerprint == privateKey.fingerprint;\n        }).map(function (_ref7) {\n          var _ref8 = _slicedToArray(_ref7, 2),\n            pubKey = _ref8[0],\n            path = _ref8[1].path;\n          var s = privateKey;\n          var _iterator27 = _createForOfIteratorHelper(path),\n            _step27;\n          try {\n            for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n              var i = _step27.value;\n              s = s.deriveChild(i);\n            }\n          } catch (err) {\n            _iterator27.e(err);\n          } finally {\n            _iterator27.f();\n          }\n          if (!P.equalBytes(s.publicKey, pubKey)) throw new Error('bip32Derivation: wrong pubKey');\n          if (!s.privateKey) throw new Error('bip32Derivation: no privateKey');\n          return s;\n        });\n        if (!signers.length) throw new Error(\"bip32Derivation: no items with fingerprint=\".concat(privateKey.fingerprint));\n        var signed = false;\n        var _iterator28 = _createForOfIteratorHelper(signers),\n          _step28;\n        try {\n          for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n            var s = _step28.value;\n            if (this.signIdx(s.privateKey, idx)) signed = true;\n          }\n        } catch (err) {\n          _iterator28.e(err);\n        } finally {\n          _iterator28.f();\n        }\n        return signed;\n      }\n      // Sighash checks\n      // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n      if (!allowedSighash) allowedSighash = [inputType.defaultSighash];else allowedSighash.forEach(validateSigHash);\n      var sighash = inputType.sighash;\n      if (!allowedSighash.includes(sighash)) {\n        throw new Error(\"Input with not allowed sigHash=\".concat(sighash, \". Allowed: \").concat(allowedSighash.join(', ')));\n      }\n      // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n      // however this was because of bug in bitcoin-core, which remains here because of consensus.\n      // If this is absolutely neccessary for your case, please open issue.\n      // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n      var _this$inputSighash2 = this.inputSighash(idx),\n        sigOutputs = _this$inputSighash2.sigOutputs;\n      if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n        throw new Error(\"Input with sighash SINGLE, but there is no output with corresponding index=\".concat(idx));\n      }\n      // Actual signing\n      // Taproot\n      var prevOut = this.prevOut(input);\n      if (inputType.txType === 'taproot') {\n        if (input.tapBip32Derivation) throw new Error('tapBip32Derivation unsupported');\n        var prevOuts = this.inputs.map(this.prevOut);\n        var prevOutScript = prevOuts.map(function (i) {\n          return i.script;\n        });\n        var amount = prevOuts.map(function (i) {\n          return i.amount;\n        });\n        var _signed = false;\n        var schnorrPub = schnorr.getPublicKey(privateKey);\n        var merkleRoot = input.tapMerkleRoot || P.EMPTY;\n        if (input.tapInternalKey) {\n          // internal + tweak = tweaked key\n          // if internal key == current public key, we need to tweak private key,\n          // otherwise sign as is. bitcoinjs implementation always wants tweaked\n          // priv key to be provided\n          var _getTaprootKeys = getTaprootKeys(privateKey, schnorrPub, input.tapInternalKey, merkleRoot),\n            pubKey = _getTaprootKeys.pubKey,\n            privKey = _getTaprootKeys.privKey;\n          var _taprootTweakPubkey3 = taprootTweakPubkey(input.tapInternalKey, merkleRoot),\n            _taprootTweakPubkey4 = _slicedToArray(_taprootTweakPubkey3, 2),\n            taprootPubKey = _taprootTweakPubkey4[0],\n            _ = _taprootTweakPubkey4[1];\n          if (P.equalBytes(taprootPubKey, pubKey)) {\n            var hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n            var sig = concat(schnorr.sign(hash, privKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n            this.updateInput(idx, {\n              tapKeySig: sig\n            }, true);\n            _signed = true;\n          }\n        }\n        if (input.tapLeafScript) {\n          input.tapScriptSig = input.tapScriptSig || [];\n          var _iterator29 = _createForOfIteratorHelper(input.tapLeafScript),\n            _step29;\n          try {\n            for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n              var _step29$value = _slicedToArray(_step29.value, 2),\n                _2 = _step29$value[0],\n                _script = _step29$value[1];\n              var script = _script.subarray(0, -1);\n              var scriptDecoded = Script.decode(script);\n              var ver = _script[_script.length - 1];\n              var _hash = tapLeafHash(script, ver);\n              // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n              var pos = scriptDecoded.findIndex(function (i) {\n                return isBytes(i) && P.equalBytes(i, schnorrPub);\n              });\n              // Skip if there is no public key in tapLeafScript\n              if (pos === -1) continue;\n              var msg = this.preimageWitnessV1(idx, prevOutScript, sighash, amount, undefined, script, ver);\n              var _sig = concat(schnorr.sign(msg, privateKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n              this.updateInput(idx, {\n                tapScriptSig: [[{\n                  pubKey: schnorrPub,\n                  leafHash: _hash\n                }, _sig]]\n              }, true);\n              _signed = true;\n            }\n          } catch (err) {\n            _iterator29.e(err);\n          } finally {\n            _iterator29.f();\n          }\n        }\n        if (!_signed) throw new Error('No taproot scripts signed');\n        return true;\n      } else {\n        // only compressed keys are supported for now\n        var _pubKey = _pubECDSA(privateKey);\n        // TODO: replace with explicit checks\n        // Check if script has public key or its has inside\n        var hasPubkey = false;\n        var pubKeyHash = hash160(_pubKey);\n        var _iterator30 = _createForOfIteratorHelper(Script.decode(inputType.lastScript)),\n          _step30;\n        try {\n          for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n            var i = _step30.value;\n            if (isBytes(i) && (P.equalBytes(i, _pubKey) || P.equalBytes(i, pubKeyHash))) hasPubkey = true;\n          }\n        } catch (err) {\n          _iterator30.e(err);\n        } finally {\n          _iterator30.f();\n        }\n        if (!hasPubkey) throw new Error(\"Input script doesn't have pubKey: \".concat(inputType.lastScript));\n        var _hash2;\n        if (inputType.txType === 'legacy') {\n          _hash2 = this.preimageLegacy(idx, inputType.lastScript, sighash);\n        } else if (inputType.txType === 'segwit') {\n          var _script2 = inputType.lastScript;\n          // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n          if (inputType.last.type === 'wpkh') _script2 = OutScript.encode({\n            type: 'pkh',\n            hash: inputType.last.hash\n          });\n          _hash2 = this.preimageWitnessV0(idx, _script2, sighash, prevOut.amount);\n        } else throw new Error(\"Transaction/sign: unknown tx type: \".concat(inputType.txType));\n        var _sig2 = signECDSA(_hash2, privateKey, this.opts.lowR);\n        this.updateInput(idx, {\n          partialSig: [[_pubKey, concat(_sig2, new Uint8Array([sighash]))]]\n        }, true);\n      }\n      return true;\n    }\n    // This is bad API. Will work if user creates and signs tx, but if\n    // there is some complex workflow with exchanging PSBT and signing them,\n    // then it is better to validate which output user signs. How could a better API look like?\n    // Example: user adds input, sends to another party, then signs received input (mixer etc),\n    // another user can add different input for same key and user will sign it.\n    // Even worse: another user can add bip32 derivation, and spend money from different address.\n    // Better api: signIdx\n  }, {\n    key: \"sign\",\n    value: function sign(privateKey, allowedSighash, _auxRand) {\n      var num = 0;\n      for (var i = 0; i < this.inputs.length; i++) {\n        try {\n          if (this.signIdx(privateKey, i, allowedSighash, _auxRand)) num++;\n        } catch (e) {}\n      }\n      if (!num) throw new Error('No inputs signed');\n      return num;\n    }\n  }, {\n    key: \"finalizeIdx\",\n    value: function finalizeIdx(idx) {\n      var _this = this;\n      this.checkInputIdx(idx);\n      if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n      var input = this.inputs[idx];\n      var inputType = this.inputType(input);\n      // Taproot finalize\n      if (inputType.txType === 'taproot') {\n        if (input.tapKeySig) input.finalScriptWitness = [input.tapKeySig];else if (input.tapLeafScript && input.tapScriptSig) {\n          // Sort leafs by control block length.\n          var leafs = input.tapLeafScript.sort(function (a, b) {\n            return TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length;\n          });\n          var _iterator31 = _createForOfIteratorHelper(leafs),\n            _step31;\n          try {\n            var _loop3 = function _loop3() {\n                var _step31$value = _slicedToArray(_step31.value, 2),\n                  cb = _step31$value[0],\n                  _script = _step31$value[1];\n                // Last byte is version\n                var script = _script.slice(0, -1);\n                var ver = _script[_script.length - 1];\n                var outScript = OutScript.decode(script);\n                var hash = tapLeafHash(script, ver);\n                var scriptSig = input.tapScriptSig.filter(function (i) {\n                  return P.equalBytes(i[0].leafHash, hash);\n                });\n                var signatures = [];\n                if (outScript.type === 'tr_ms') {\n                  var m = outScript.m;\n                  var pubkeys = outScript.pubkeys;\n                  var added = 0;\n                  var _iterator32 = _createForOfIteratorHelper(pubkeys),\n                    _step32;\n                  try {\n                    var _loop4 = function _loop4() {\n                      var pub = _step32.value;\n                      var sigIdx = scriptSig.findIndex(function (i) {\n                        return P.equalBytes(i[0].pubKey, pub);\n                      });\n                      // Should have exact amount of signatures (more -- will fail)\n                      if (added === m || sigIdx === -1) {\n                        signatures.push(P.EMPTY);\n                        return 1; // continue\n                      }\n                      signatures.push(scriptSig[sigIdx][1]);\n                      added++;\n                    };\n                    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                      if (_loop4()) continue;\n                    }\n                    // Should be exact same as m\n                  } catch (err) {\n                    _iterator32.e(err);\n                  } finally {\n                    _iterator32.f();\n                  }\n                  if (added !== m) return 0; // continue\n                } else if (outScript.type === 'tr_ns') {\n                  var _iterator33 = _createForOfIteratorHelper(outScript.pubkeys),\n                    _step33;\n                  try {\n                    var _loop5 = function _loop5() {\n                      var pub = _step33.value;\n                      var sigIdx = scriptSig.findIndex(function (i) {\n                        return P.equalBytes(i[0].pubKey, pub);\n                      });\n                      if (sigIdx === -1) return 1; // continue\n                      signatures.push(scriptSig[sigIdx][1]);\n                    };\n                    for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n                      if (_loop5()) continue;\n                    }\n                  } catch (err) {\n                    _iterator33.e(err);\n                  } finally {\n                    _iterator33.f();\n                  }\n                  if (signatures.length !== outScript.pubkeys.length) return 0; // continue\n                } else if (outScript.type === 'unknown' && _this.opts.allowUnknownInputs) {\n                  // Trying our best to sign what we can\n                  var scriptDecoded = Script.decode(script);\n                  signatures = scriptSig.map(function (_ref9) {\n                    var _ref10 = _slicedToArray(_ref9, 2),\n                      pubKey = _ref10[0].pubKey,\n                      signature = _ref10[1];\n                    var pos = scriptDecoded.findIndex(function (i) {\n                      return isBytes(i) && P.equalBytes(i, pubKey);\n                    });\n                    if (pos === -1) throw new Error('finalize/taproot: cannot find position of pubkey in script');\n                    return {\n                      signature: signature,\n                      pos: pos\n                    };\n                  })\n                  // Reverse order (because witness is stack and we take last element first from it)\n                  .sort(function (a, b) {\n                    return a.pos - b.pos;\n                  }).map(function (i) {\n                    return i.signature;\n                  });\n                  if (!signatures.length) return 0; // continue\n                } else throw new Error('Finalize: Unknown tapLeafScript');\n                // Witness is stack, so last element will be used first\n                input.finalScriptWitness = signatures.reverse().concat([script, TaprootControlBlock.encode(cb)]);\n                return 1; // break\n              },\n              _ret;\n            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n              _ret = _loop3();\n              if (_ret === 0) continue;\n              if (_ret === 1) break;\n            }\n          } catch (err) {\n            _iterator31.e(err);\n          } finally {\n            _iterator31.f();\n          }\n          if (!input.finalScriptWitness) throw new Error('finalize/taproot: empty witness');\n        } else throw new Error('finalize/taproot: unknown input');\n        input.finalScriptSig = P.EMPTY;\n        cleanFinalInput(input);\n        return;\n      }\n      if (!input.partialSig || !input.partialSig.length) throw new Error('Not enough partial sign');\n      var inputScript = P.EMPTY;\n      var witness = [];\n      // TODO: move input scripts closer to payments/output scripts\n      // Multisig\n      if (inputType.last.type === 'ms') {\n        var m = inputType.last.m;\n        var pubkeys = inputType.last.pubkeys;\n        var signatures = [];\n        // partial: [pubkey, sign]\n        var _iterator34 = _createForOfIteratorHelper(pubkeys),\n          _step34;\n        try {\n          var _loop6 = function _loop6() {\n            var pub = _step34.value;\n            var sign = input.partialSig.find(function (s) {\n              return P.equalBytes(pub, s[0]);\n            });\n            if (!sign) return 1; // continue\n            signatures.push(sign[1]);\n          };\n          for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n            if (_loop6()) continue;\n          }\n        } catch (err) {\n          _iterator34.e(err);\n        } finally {\n          _iterator34.f();\n        }\n        signatures = signatures.slice(0, m);\n        if (signatures.length !== m) {\n          throw new Error(\"Multisig: wrong signatures count, m=\".concat(m, \" n=\").concat(pubkeys.length, \" signatures=\").concat(signatures.length));\n        }\n        inputScript = Script.encode([0].concat(_toConsumableArray(signatures)));\n      } else if (inputType.last.type === 'pk') {\n        inputScript = Script.encode([input.partialSig[0][1]]);\n      } else if (inputType.last.type === 'pkh') {\n        inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n      } else if (inputType.last.type === 'wpkh') {\n        inputScript = P.EMPTY;\n        witness = [input.partialSig[0][1], input.partialSig[0][0]];\n      } else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs) throw new Error('Unknown inputs not allowed');\n      // Create final scripts (generic part)\n      var finalScriptSig, finalScriptWitness;\n      if (inputType.type.includes('wsh-')) {\n        // P2WSH\n        if (inputScript.length && inputType.lastScript.length) {\n          witness = Script.decode(inputScript).map(function (i) {\n            if (i === 0) return P.EMPTY;\n            if (isBytes(i)) return i;\n            throw new Error(\"Wrong witness op=\".concat(i));\n          });\n        }\n        witness = witness.concat(inputType.lastScript);\n      }\n      if (inputType.txType === 'segwit') finalScriptWitness = witness;\n      if (inputType.type.startsWith('sh-wsh-')) {\n        finalScriptSig = Script.encode([Script.encode([0, sha256(inputType.lastScript)])]);\n      } else if (inputType.type.startsWith('sh-')) {\n        finalScriptSig = Script.encode([].concat(_toConsumableArray(Script.decode(inputScript)), [inputType.lastScript]));\n      } else if (inputType.type.startsWith('wsh-')) {} else if (inputType.txType !== 'segwit') finalScriptSig = inputScript;\n      if (!finalScriptSig && !finalScriptWitness) throw new Error('Unknown error finalizing input');\n      if (finalScriptSig) input.finalScriptSig = finalScriptSig;\n      if (finalScriptWitness) input.finalScriptWitness = finalScriptWitness;\n      cleanFinalInput(input);\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      for (var i = 0; i < this.inputs.length; i++) this.finalizeIdx(i);\n    }\n  }, {\n    key: \"extract\",\n    value: function extract() {\n      if (!this.isFinal) throw new Error('Transaction has unfinalized inputs');\n      if (!this.outputs.length) throw new Error('Transaction has no outputs');\n      if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n      return this.toBytes(true, true);\n    }\n  }, {\n    key: \"combine\",\n    value: function combine(other) {\n      for (var _i4 = 0, _arr2 = ['PSBTVersion', 'version', 'lockTime']; _i4 < _arr2.length; _i4++) {\n        var k = _arr2[_i4];\n        if (this.opts[k] !== other.opts[k]) {\n          throw new Error(\"Transaction/combine: different \".concat(k, \" this=\").concat(this.opts[k], \" other=\").concat(other.opts[k]));\n        }\n      }\n      for (var _i5 = 0, _arr3 = ['inputs', 'outputs']; _i5 < _arr3.length; _i5++) {\n        var _k9 = _arr3[_i5];\n        if (this[_k9].length !== other[_k9].length) {\n          throw new Error(\"Transaction/combine: different \".concat(_k9, \" length this=\").concat(this[_k9].length, \" other=\").concat(other[_k9].length));\n        }\n      }\n      var thisUnsigned = this.global.unsignedTx ? RawTx.encode(this.global.unsignedTx) : P.EMPTY;\n      var otherUnsigned = other.global.unsignedTx ? RawTx.encode(other.global.unsignedTx) : P.EMPTY;\n      if (!P.equalBytes(thisUnsigned, otherUnsigned)) throw new Error(\"Transaction/combine: different unsigned tx\");\n      this.global = mergeKeyMap(PSBTGlobal, this.global, other.global);\n      for (var i = 0; i < this.inputs.length; i++) this.updateInput(i, other.inputs[i], true);\n      for (var _i6 = 0; _i6 < this.outputs.length; _i6++) this.updateOutput(_i6, other.outputs[_i6], true);\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      // deepClone probably faster, but this enforces that encoding is valid\n      return Transaction.fromPSBT(this.toPSBT(2), this.opts);\n    }\n  }], [{\n    key: \"fromRaw\",\n    value: function fromRaw(raw) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var parsed = RawTx.decode(raw);\n      var tx = new Transaction(_objectSpread(_objectSpread({}, opts), {}, {\n        version: parsed.version,\n        lockTime: parsed.lockTime\n      }));\n      var _iterator35 = _createForOfIteratorHelper(parsed.outputs),\n        _step35;\n      try {\n        for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n          var o = _step35.value;\n          tx.addOutput(o);\n        }\n      } catch (err) {\n        _iterator35.e(err);\n      } finally {\n        _iterator35.f();\n      }\n      tx.outputs = parsed.outputs;\n      tx.inputs = parsed.inputs;\n      if (parsed.witnesses) {\n        for (var i = 0; i < parsed.witnesses.length; i++) tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n      }\n      return tx;\n    }\n    // PSBT\n  }, {\n    key: \"fromPSBT\",\n    value: function fromPSBT(psbt) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var parsed;\n      try {\n        parsed = RawPSBTV0.decode(psbt);\n      } catch (e0) {\n        try {\n          parsed = RawPSBTV2.decode(psbt);\n        } catch (e2) {\n          // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n          throw e0;\n        }\n      }\n      var PSBTVersion = parsed.global.version || 0;\n      if (PSBTVersion !== 0 && PSBTVersion !== 2) throw new Error(\"Wrong PSBT version=\".concat(PSBTVersion));\n      var unsigned = parsed.global.unsignedTx;\n      var version = PSBTVersion === 0 ? unsigned === null || unsigned === void 0 ? void 0 : unsigned.version : parsed.global.txVersion;\n      var lockTime = PSBTVersion === 0 ? unsigned === null || unsigned === void 0 ? void 0 : unsigned.lockTime : parsed.global.fallbackLocktime;\n      var tx = new Transaction(_objectSpread(_objectSpread({}, opts), {}, {\n        version: version,\n        lockTime: lockTime,\n        PSBTVersion: PSBTVersion\n      }));\n      // We need slice here, because otherwise\n      var inputCount = PSBTVersion === 0 ? unsigned === null || unsigned === void 0 ? void 0 : unsigned.inputs.length : parsed.global.inputCount;\n      tx.inputs = parsed.inputs.slice(0, inputCount).map(function (i, j) {\n        var _parsed$global$unsign;\n        return _objectSpread(_objectSpread({\n          finalScriptSig: P.EMPTY\n        }, (_parsed$global$unsign = parsed.global.unsignedTx) === null || _parsed$global$unsign === void 0 ? void 0 : _parsed$global$unsign.inputs[j]), i);\n      });\n      var outputCount = PSBTVersion === 0 ? unsigned === null || unsigned === void 0 ? void 0 : unsigned.outputs.length : parsed.global.outputCount;\n      tx.outputs = parsed.outputs.slice(0, outputCount).map(function (i, j) {\n        var _parsed$global$unsign2;\n        return _objectSpread(_objectSpread({}, i), (_parsed$global$unsign2 = parsed.global.unsignedTx) === null || _parsed$global$unsign2 === void 0 ? void 0 : _parsed$global$unsign2.outputs[j]);\n      });\n      tx.global = _objectSpread(_objectSpread({}, parsed.global), {}, {\n        txVersion: version\n      }); // just in case proprietary/unknown fields\n      if (lockTime !== DEFAULT_LOCKTIME) tx.global.fallbackLocktime = lockTime;\n      return tx;\n    }\n  }]);\n  return Transaction;\n}();\n// User facing API?\n// Simple pubkey address, without complex scripts\nexport function getAddress(type, privKey) {\n  var network = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NETWORK;\n  if (type === 'tr') {\n    return p2tr(schnorr.getPublicKey(privKey), undefined, network).address;\n  }\n  var pubKey = _pubECDSA(privKey);\n  if (type === 'pkh') return p2pkh(pubKey, network).address;\n  if (type === 'wpkh') return p2wpkh(pubKey, network).address;\n  throw new Error(\"getAddress: unknown type=\".concat(type));\n}\nexport function multisig(m, pubkeys) {\n  var sorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var witness = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n  return witness ? p2wsh(ms) : p2sh(ms);\n}\nexport function sortedMultisig(m, pubkeys) {\n  var witness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return multisig(m, pubkeys, true, witness);\n}\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nvar HARDENED_OFFSET = 0x80000000;\nexport function bip32Path(path) {\n  var out = [];\n  if (!/^[mM]'?/.test(path)) throw new Error('Path must start with \"m\" or \"M\"');\n  if (/^[mM]'?$/.test(path)) return out;\n  var parts = path.replace(/^[mM]'?\\//, '').split('/');\n  var _iterator36 = _createForOfIteratorHelper(parts),\n    _step36;\n  try {\n    for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n      var c = _step36.value;\n      var m = /^(\\d+)('?)$/.exec(c);\n      if (!m || m.length !== 3) throw new Error(\"Invalid child index: \".concat(c));\n      var idx = +m[1];\n      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) throw new Error('Invalid index');\n      // hardened key\n      if (m[2] === \"'\") idx += HARDENED_OFFSET;\n      out.push(idx);\n    }\n  } catch (err) {\n    _iterator36.e(err);\n  } finally {\n    _iterator36.f();\n  }\n  return out;\n}\nexport function PSBTCombine(psbts) {\n  if (!psbts || !Array.isArray(psbts) || !psbts.length) throw new Error('PSBTCombine: wrong PSBT list');\n  var tx = Transaction.fromPSBT(psbts[0]);\n  for (var i = 1; i < psbts.length; i++) tx.combine(Transaction.fromPSBT(psbts[i]));\n  return tx.toPSBT();\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}