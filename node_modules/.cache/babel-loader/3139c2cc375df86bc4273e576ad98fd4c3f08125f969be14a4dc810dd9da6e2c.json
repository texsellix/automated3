{"ast":null,"code":"\"use strict\";\n\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nvar _objectSpread = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _regeneratorRuntime = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createClass = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;\nvar nodeCrypto = require(\"crypto\");\nvar _0n = BigInt(0);\nvar _1n = BigInt(1);\nvar _2n = BigInt(2);\nvar _3n = BigInt(3);\nvar _8n = BigInt(8);\nvar CURVE = Object.freeze({\n  a: _0n,\n  b: BigInt(7),\n  P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n});\nexports.CURVE = CURVE;\nvar divNearest = function divNearest(a, b) {\n  return (a + b / _2n) / b;\n};\nvar endo = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  splitScalar: function splitScalar(k) {\n    var n = CURVE.n;\n    var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    var b2 = a1;\n    var POW_2_128 = BigInt('0x100000000000000000000000000000000');\n    var c1 = divNearest(b2 * k, n);\n    var c2 = divNearest(-b1 * k, n);\n    var k1 = mod(k - c1 * a1 - c2 * a2, n);\n    var k2 = mod(-c1 * b1 - c2 * b2, n);\n    var k1neg = k1 > POW_2_128;\n    var k2neg = k2 > POW_2_128;\n    if (k1neg) k1 = n - k1;\n    if (k2neg) k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n      throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return {\n      k1neg: k1neg,\n      k1: k1,\n      k2neg: k2neg,\n      k2: k2\n    };\n  }\n};\nvar fieldLen = 32;\nvar groupLen = 32;\nvar hashLen = 32;\nvar compressedLen = fieldLen + 1;\nvar uncompressedLen = 2 * fieldLen + 1;\nfunction weierstrass(x) {\n  var a = CURVE.a,\n    b = CURVE.b;\n  var x2 = mod(x * x);\n  var x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\nvar USE_ENDOMORPHISM = CURVE.a === _0n;\nvar ShaError = /*#__PURE__*/function (_Error) {\n  _inherits(ShaError, _Error);\n  var _super = _createSuper(ShaError);\n  function ShaError(message) {\n    _classCallCheck(this, ShaError);\n    return _super.call(this, message);\n  }\n  return _createClass(ShaError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nfunction assertJacPoint(other) {\n  if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n}\nvar JacobianPoint = /*#__PURE__*/function () {\n  function JacobianPoint(x, y, z) {\n    _classCallCheck(this, JacobianPoint);\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  _createClass(JacobianPoint, [{\n    key: \"equals\",\n    value: function equals(other) {\n      assertJacPoint(other);\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var X2 = other.x,\n        Y2 = other.y,\n        Z2 = other.z;\n      var Z1Z1 = mod(Z1 * Z1);\n      var Z2Z2 = mod(Z2 * Z2);\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(mod(Y1 * Z2) * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      return U1 === U2 && S1 === S2;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var A = mod(X1 * X1);\n      var B = mod(Y1 * Y1);\n      var C = mod(B * B);\n      var x1b = X1 + B;\n      var D = mod(_2n * (mod(x1b * x1b) - A - C));\n      var E = mod(_3n * A);\n      var F = mod(E * E);\n      var X3 = mod(F - _2n * D);\n      var Y3 = mod(E * (D - X3) - _8n * C);\n      var Z3 = mod(_2n * Y1 * Z1);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      assertJacPoint(other);\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var X2 = other.x,\n        Y2 = other.y,\n        Z2 = other.z;\n      if (X2 === _0n || Y2 === _0n) return this;\n      if (X1 === _0n || Y1 === _0n) return other;\n      var Z1Z1 = mod(Z1 * Z1);\n      var Z2Z2 = mod(Z2 * Z2);\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(mod(Y1 * Z2) * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      var H = mod(U2 - U1);\n      var r = mod(S2 - S1);\n      if (H === _0n) {\n        if (r === _0n) {\n          return this.double();\n        } else {\n          return JacobianPoint.ZERO;\n        }\n      }\n      var HH = mod(H * H);\n      var HHH = mod(H * HH);\n      var V = mod(U1 * HH);\n      var X3 = mod(r * r - HHH - _2n * V);\n      var Y3 = mod(r * (V - X3) - S1 * HHH);\n      var Z3 = mod(Z1 * Z2 * H);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiplyUnsafe\",\n    value: function multiplyUnsafe(scalar) {\n      var P0 = JacobianPoint.ZERO;\n      if (typeof scalar === 'bigint' && scalar === _0n) return P0;\n      var n = normalizeScalar(scalar);\n      if (n === _1n) return this;\n      if (!USE_ENDOMORPHISM) {\n        var p = P0;\n        var _d = this;\n        while (n > _0n) {\n          if (n & _1n) p = p.add(_d);\n          _d = _d.double();\n          n >>= _1n;\n        }\n        return p;\n      }\n      var _endo$splitScalar = endo.splitScalar(n),\n        k1neg = _endo$splitScalar.k1neg,\n        k1 = _endo$splitScalar.k1,\n        k2neg = _endo$splitScalar.k2neg,\n        k2 = _endo$splitScalar.k2;\n      var k1p = P0;\n      var k2p = P0;\n      var d = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n      return k1p.add(k2p);\n    }\n  }, {\n    key: \"precomputeWindow\",\n    value: function precomputeWindow(W) {\n      var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n      var points = [];\n      var p = this;\n      var base = p;\n      for (var window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        for (var i = 1; i < Math.pow(2, W - 1); i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    }\n  }, {\n    key: \"wNAF\",\n    value: function wNAF(n, affinePoint) {\n      if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n      var W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n      if (256 % W) {\n        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n      }\n      var precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n      if (!precomputes) {\n        precomputes = this.precomputeWindow(W);\n        if (affinePoint && W !== 1) {\n          precomputes = JacobianPoint.normalizeZ(precomputes);\n          pointPrecomputes.set(affinePoint, precomputes);\n        }\n      }\n      var p = JacobianPoint.ZERO;\n      var f = JacobianPoint.BASE;\n      var windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n      var windowSize = Math.pow(2, W - 1);\n      var mask = BigInt(Math.pow(2, W) - 1);\n      var maxNumber = Math.pow(2, W);\n      var shiftBy = BigInt(W);\n      for (var window = 0; window < windows; window++) {\n        var offset = window * windowSize;\n        var wbits = Number(n & mask);\n        n >>= shiftBy;\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        var offset1 = offset;\n        var offset2 = offset + Math.abs(wbits) - 1;\n        var cond1 = window % 2 !== 0;\n        var cond2 = wbits < 0;\n        if (wbits === 0) {\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      return {\n        p: p,\n        f: f\n      };\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar, affinePoint) {\n      var n = normalizeScalar(scalar);\n      var point;\n      var fake;\n      if (USE_ENDOMORPHISM) {\n        var _endo$splitScalar2 = endo.splitScalar(n),\n          k1neg = _endo$splitScalar2.k1neg,\n          k1 = _endo$splitScalar2.k1,\n          k2neg = _endo$splitScalar2.k2neg,\n          k2 = _endo$splitScalar2.k2;\n        var _this$wNAF = this.wNAF(k1, affinePoint),\n          k1p = _this$wNAF.p,\n          f1p = _this$wNAF.f;\n        var _this$wNAF2 = this.wNAF(k2, affinePoint),\n          k2p = _this$wNAF2.p,\n          f2p = _this$wNAF2.f;\n        k1p = constTimeNegate(k1neg, k1p);\n        k2p = constTimeNegate(k2neg, k2p);\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        var _this$wNAF3 = this.wNAF(n, affinePoint),\n          p = _this$wNAF3.p,\n          f = _this$wNAF3.f;\n        point = p;\n        fake = f;\n      }\n      return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n  }, {\n    key: \"toAffine\",\n    value: function toAffine(invZ) {\n      var x = this.x,\n        y = this.y,\n        z = this.z;\n      var is0 = this.equals(JacobianPoint.ZERO);\n      if (invZ == null) invZ = is0 ? _8n : invert(z);\n      var iz1 = invZ;\n      var iz2 = mod(iz1 * iz1);\n      var iz3 = mod(iz2 * iz1);\n      var ax = mod(x * iz2);\n      var ay = mod(y * iz3);\n      var zz = mod(z * iz1);\n      if (is0) return Point.ZERO;\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return new Point(ax, ay);\n    }\n  }], [{\n    key: \"fromAffine\",\n    value: function fromAffine(p) {\n      if (!(p instanceof Point)) {\n        throw new TypeError('JacobianPoint#fromAffine: expected Point');\n      }\n      if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;\n      return new JacobianPoint(p.x, p.y, _1n);\n    }\n  }, {\n    key: \"toAffineBatch\",\n    value: function toAffineBatch(points) {\n      var toInv = invertBatch(points.map(function (p) {\n        return p.z;\n      }));\n      return points.map(function (p, i) {\n        return p.toAffine(toInv[i]);\n      });\n    }\n  }, {\n    key: \"normalizeZ\",\n    value: function normalizeZ(points) {\n      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n  }]);\n  return JacobianPoint;\n}();\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n  var neg = item.negate();\n  return condition ? neg : item;\n}\nvar pointPrecomputes = new WeakMap();\nvar Point = /*#__PURE__*/function () {\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n    this.x = x;\n    this.y = y;\n  }\n  _createClass(Point, [{\n    key: \"_setWindowSize\",\n    value: function _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n  }, {\n    key: \"hasEvenY\",\n    value: function hasEvenY() {\n      return this.y % _2n === _0n;\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return hexToBytes(this.toHex(isCompressed));\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var x = numTo32bStr(this.x);\n      if (isCompressed) {\n        var prefix = this.hasEvenY() ? '02' : '03';\n        return \"\".concat(prefix).concat(x);\n      } else {\n        return \"04\".concat(x).concat(numTo32bStr(this.y));\n      }\n    }\n  }, {\n    key: \"toHexX\",\n    value: function toHexX() {\n      return this.toHex(true).slice(2);\n    }\n  }, {\n    key: \"toRawX\",\n    value: function toRawX() {\n      return this.toRawBytes(true).slice(1);\n    }\n  }, {\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var msg = 'Point is not on elliptic curve';\n      var x = this.x,\n        y = this.y;\n      if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n      var left = mod(y * y);\n      var right = weierstrass(x);\n      if (mod(left - right) !== _0n) throw new Error(msg);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new Point(this.x, mod(-this.y));\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar) {\n      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n  }, {\n    key: \"multiplyAndAddUnsafe\",\n    value: function multiplyAndAddUnsafe(Q, a, b) {\n      var P = JacobianPoint.fromAffine(this);\n      var aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n      var bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n      var sum = aP.add(bQ);\n      return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n  }], [{\n    key: \"fromCompressedHex\",\n    value: function fromCompressedHex(bytes) {\n      var isShort = bytes.length === 32;\n      var x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n      if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n      var y2 = weierstrass(x);\n      var y = sqrtMod(y2);\n      var isYOdd = (y & _1n) === _1n;\n      if (isShort) {\n        if (isYOdd) y = mod(-y);\n      } else {\n        var isFirstByteOdd = (bytes[0] & 1) === 1;\n        if (isFirstByteOdd !== isYOdd) y = mod(-y);\n      }\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromUncompressedHex\",\n    value: function fromUncompressedHex(bytes) {\n      var x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n      var y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      var len = bytes.length;\n      var header = bytes[0];\n      if (len === fieldLen) return this.fromCompressedHex(bytes);\n      if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n        return this.fromCompressedHex(bytes);\n      }\n      if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);\n      throw new Error(\"Point.fromHex: received invalid point. Expected 32-\".concat(compressedLen, \" compressed bytes or \").concat(uncompressedLen, \" uncompressed bytes, not \").concat(len));\n    }\n  }, {\n    key: \"fromPrivateKey\",\n    value: function fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n  }, {\n    key: \"fromSignature\",\n    value: function fromSignature(msgHash, signature, recovery) {\n      var _normalizeSignature = normalizeSignature(signature),\n        r = _normalizeSignature.r,\n        s = _normalizeSignature.s;\n      if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');\n      var h = truncateHash(ensureBytes(msgHash));\n      var n = CURVE.n;\n      var radj = recovery === 2 || recovery === 3 ? r + n : r;\n      var rinv = invert(radj, n);\n      var u1 = mod(-h * rinv, n);\n      var u2 = mod(s * rinv, n);\n      var prefix = recovery & 1 ? '03' : '02';\n      var R = Point.fromHex(prefix + numTo32bStr(radj));\n      var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n      if (!Q) throw new Error('Cannot recover signature: point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n  }]);\n  return Point;\n}();\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(\"Invalid signature integer tag: \".concat(bytesToHex(data)));\n  }\n  var len = data[1];\n  var res = data.subarray(2, len + 2);\n  if (!len || res.length !== len) {\n    throw new Error(\"Invalid signature integer: wrong length\");\n  }\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(\"Invalid signature tag: \".concat(bytesToHex(data)));\n  }\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n  var _parseDERInt = parseDERInt(data.subarray(2)),\n    r = _parseDERInt.data,\n    sBytes = _parseDERInt.left;\n  var _parseDERInt2 = parseDERInt(sBytes),\n    s = _parseDERInt2.data,\n    rBytesLeft = _parseDERInt2.left;\n  if (rBytesLeft.length) {\n    throw new Error(\"Invalid signature: left bytes after parsing: \".concat(bytesToHex(rBytesLeft)));\n  }\n  return {\n    r: r,\n    s: s\n  };\n}\nvar Signature = /*#__PURE__*/function () {\n  function Signature(r, s) {\n    _classCallCheck(this, Signature);\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  _createClass(Signature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n        s = this.s;\n      if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n      if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n  }, {\n    key: \"hasHighS\",\n    value: function hasHighS() {\n      var HALF = CURVE.n >> _1n;\n      return this.s > HALF;\n    }\n  }, {\n    key: \"normalizeS\",\n    value: function normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n  }, {\n    key: \"toDERRawBytes\",\n    value: function toDERRawBytes() {\n      return hexToBytes(this.toDERHex());\n    }\n  }, {\n    key: \"toDERHex\",\n    value: function toDERHex() {\n      var sHex = sliceDER(numberToHexUnpadded(this.s));\n      var rHex = sliceDER(numberToHexUnpadded(this.r));\n      var sHexL = sHex.length / 2;\n      var rHexL = rHex.length / 2;\n      var sLen = numberToHexUnpadded(sHexL);\n      var rLen = numberToHexUnpadded(rHexL);\n      var length = numberToHexUnpadded(rHexL + sHexL + 4);\n      return \"30\".concat(length, \"02\").concat(rLen).concat(rHex, \"02\").concat(sLen).concat(sHex);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return this.toDERRawBytes();\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return this.toDERHex();\n    }\n  }, {\n    key: \"toCompactRawBytes\",\n    value: function toCompactRawBytes() {\n      return hexToBytes(this.toCompactHex());\n    }\n  }, {\n    key: \"toCompactHex\",\n    value: function toCompactHex() {\n      return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n  }], [{\n    key: \"fromCompact\",\n    value: function fromCompact(hex) {\n      var arr = hex instanceof Uint8Array;\n      var name = 'Signature.fromCompact';\n      if (typeof hex !== 'string' && !arr) throw new TypeError(\"\".concat(name, \": Expected string or Uint8Array\"));\n      var str = arr ? bytesToHex(hex) : hex;\n      if (str.length !== 128) throw new Error(\"\".concat(name, \": Expected 64-byte hex\"));\n      return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n  }, {\n    key: \"fromDER\",\n    value: function fromDER(hex) {\n      var arr = hex instanceof Uint8Array;\n      if (typeof hex !== 'string' && !arr) throw new TypeError(\"Signature.fromDER: Expected string or Uint8Array\");\n      var _parseDERSignature = parseDERSignature(arr ? hex : hexToBytes(hex)),\n        r = _parseDERSignature.r,\n        s = _parseDERSignature.s;\n      return new Signature(r, s);\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      return this.fromDER(hex);\n    }\n  }]);\n  return Signature;\n}();\nexports.Signature = Signature;\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  if (!arrays.every(function (b) {\n    return b instanceof Uint8Array;\n  })) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nvar hexes = Array.from({\n  length: 256\n}, function (v, i) {\n  return i.toString(16).padStart(2, '0');\n});\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  var hex = '';\n  for (var i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\nvar POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n  var b = hexToBytes(numTo32bStr(num));\n  if (b.length !== 32) throw new Error('Error: expected 32 bytes');\n  return b;\n}\nfunction numberToHexUnpadded(num) {\n  var hex = num.toString(16);\n  return hex.length & 1 ? \"0\".concat(hex) : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n  return BigInt(\"0x\".concat(hex));\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  var array = new Uint8Array(hex.length / 2);\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    var hexByte = hex.slice(j, j + 2);\n    var byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var result = a % b;\n  return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n  var P = CURVE.P;\n  var res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n  return res;\n}\nfunction sqrtMod(x) {\n  var P = CURVE.P;\n  var _6n = BigInt(6);\n  var _11n = BigInt(11);\n  var _22n = BigInt(22);\n  var _23n = BigInt(23);\n  var _44n = BigInt(44);\n  var _88n = BigInt(88);\n  var b2 = x * x * x % P;\n  var b3 = b2 * b2 * x % P;\n  var b6 = pow2(b3, _3n) * b3 % P;\n  var b9 = pow2(b6, _3n) * b3 % P;\n  var b11 = pow2(b9, _2n) * b2 % P;\n  var b22 = pow2(b11, _11n) * b11 % P;\n  var b44 = pow2(b22, _22n) * b22 % P;\n  var b88 = pow2(b44, _44n) * b44 % P;\n  var b176 = pow2(b88, _88n) * b88 % P;\n  var b220 = pow2(b176, _44n) * b44 % P;\n  var b223 = pow2(b220, _3n) * b3 % P;\n  var t1 = pow2(b223, _23n) * b22 % P;\n  var t2 = pow2(t1, _6n) * b2 % P;\n  var rt = pow2(t2, _2n);\n  var xc = rt * rt % P;\n  if (xc !== x) throw new Error('Cannot find square root');\n  return rt;\n}\nfunction invert(number) {\n  var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(\"invert: expected positive integers, got n=\".concat(number, \" mod=\").concat(modulo));\n  }\n  var a = mod(number, modulo);\n  var b = modulo;\n  var x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    var q = b / a;\n    var r = b % a;\n    var m = x - u * q;\n    var n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  var gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\nfunction invertBatch(nums) {\n  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var scratch = new Array(nums.length);\n  var lastMultiplied = nums.reduce(function (acc, num, i) {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  var inverted = invert(lastMultiplied, p);\n  nums.reduceRight(function (acc, num, i) {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\nfunction bits2int_2(bytes) {\n  var delta = bytes.length * 8 - groupLen * 8;\n  var num = bytesToNumber(bytes);\n  return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash) {\n  var truncateOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var h = bits2int_2(hash);\n  if (truncateOnly) return h;\n  var n = CURVE.n;\n  return h >= n ? h - n : h;\n}\nvar _sha256Sync;\nvar _hmacSha256Sync;\nvar HmacDrbg = /*#__PURE__*/function () {\n  function HmacDrbg(hashLen, qByteLen) {\n    _classCallCheck(this, HmacDrbg);\n    this.hashLen = hashLen;\n    this.qByteLen = qByteLen;\n    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n    this.v = new Uint8Array(hashLen).fill(1);\n    this.k = new Uint8Array(hashLen).fill(0);\n    this.counter = 0;\n  }\n  _createClass(HmacDrbg, [{\n    key: \"hmac\",\n    value: function hmac() {\n      var _exports$utils;\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n      return (_exports$utils = exports.utils).hmacSha256.apply(_exports$utils, [this.k].concat(values));\n    }\n  }, {\n    key: \"hmacSync\",\n    value: function hmacSync() {\n      for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        values[_key3] = arguments[_key3];\n      }\n      return _hmacSha256Sync.apply(void 0, [this.k].concat(values));\n    }\n  }, {\n    key: \"checkSync\",\n    value: function checkSync() {\n      if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');\n    }\n  }, {\n    key: \"incr\",\n    value: function incr() {\n      if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');\n      this.counter += 1;\n    }\n  }, {\n    key: \"reseed\",\n    value: function () {\n      var _reseed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var seed,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              seed = _args.length > 0 && _args[0] !== undefined ? _args[0] : new Uint8Array();\n              _context.next = 3;\n              return this.hmac(this.v, Uint8Array.from([0x00]), seed);\n            case 3:\n              this.k = _context.sent;\n              _context.next = 6;\n              return this.hmac(this.v);\n            case 6:\n              this.v = _context.sent;\n              if (!(seed.length === 0)) {\n                _context.next = 9;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 9:\n              _context.next = 11;\n              return this.hmac(this.v, Uint8Array.from([0x01]), seed);\n            case 11:\n              this.k = _context.sent;\n              _context.next = 14;\n              return this.hmac(this.v);\n            case 14:\n              this.v = _context.sent;\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function reseed() {\n        return _reseed.apply(this, arguments);\n      }\n      return reseed;\n    }()\n  }, {\n    key: \"reseedSync\",\n    value: function reseedSync() {\n      var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n      this.checkSync();\n      this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n      this.v = this.hmacSync(this.v);\n      if (seed.length === 0) return;\n      this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n      this.v = this.hmacSync(this.v);\n    }\n  }, {\n    key: \"generate\",\n    value: function () {\n      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var len, out, sl;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.incr();\n              len = 0;\n              out = [];\n            case 3:\n              if (!(len < this.qByteLen)) {\n                _context2.next = 12;\n                break;\n              }\n              _context2.next = 6;\n              return this.hmac(this.v);\n            case 6:\n              this.v = _context2.sent;\n              sl = this.v.slice();\n              out.push(sl);\n              len += this.v.length;\n              _context2.next = 3;\n              break;\n            case 12:\n              return _context2.abrupt(\"return\", concatBytes.apply(void 0, out));\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function generate() {\n        return _generate.apply(this, arguments);\n      }\n      return generate;\n    }()\n  }, {\n    key: \"generateSync\",\n    value: function generateSync() {\n      this.checkSync();\n      this.incr();\n      var len = 0;\n      var out = [];\n      while (len < this.qByteLen) {\n        this.v = this.hmacSync(this.v);\n        var sl = this.v.slice();\n        out.push(sl);\n        len += this.v.length;\n      }\n      return concatBytes.apply(void 0, out);\n    }\n  }]);\n  return HmacDrbg;\n}();\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n  var lowS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var n = CURVE.n;\n  var k = truncateHash(kBytes, true);\n  if (!isWithinCurveOrder(k)) return;\n  var kinv = invert(k, n);\n  var q = Point.BASE.multiply(k);\n  var r = mod(q.x, n);\n  if (r === _0n) return;\n  var s = mod(kinv * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  var sig = new Signature(r, s);\n  var recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n  if (lowS && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n  return {\n    sig: sig,\n    recovery: recovery\n  };\n}\nfunction normalizePrivateKey(key) {\n  var num;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\nfunction getPublicKey(privateKey) {\n  var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery) {\n  var isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isProbPub(item) {\n  var arr = item instanceof Uint8Array;\n  var str = typeof item === 'string';\n  var len = (arr || str) && item.length;\n  if (arr) return len === compressedLen || len === uncompressedLen;\n  if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;\n  if (item instanceof Point) return true;\n  return false;\n}\nfunction getSharedSecret(privateA, publicB) {\n  var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  var b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction bits2int(bytes) {\n  var slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n  return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n  var z1 = bits2int(bytes);\n  var z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n  return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(\"sign: expected valid message hash, not \\\"\".concat(msgHash, \"\\\"\"));\n  var h1 = ensureBytes(msgHash);\n  var d = normalizePrivateKey(privateKey);\n  var seedArgs = [int2octets(d), bits2octets(h1)];\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = exports.utils.randomBytes(fieldLen);\n    var e = ensureBytes(extraEntropy);\n    if (e.length !== fieldLen) throw new Error(\"sign: Expected \".concat(fieldLen, \" bytes of extra data\"));\n    seedArgs.push(e);\n  }\n  var seed = concatBytes.apply(void 0, seedArgs);\n  var m = bits2int(h1);\n  return {\n    seed: seed,\n    m: m,\n    d: d\n  };\n}\nfunction finalizeSig(recSig, opts) {\n  var sig = recSig.sig,\n    recovery = recSig.recovery;\n  var _Object$assign = Object.assign({\n      canonical: true,\n      der: true\n    }, opts),\n    der = _Object$assign.der,\n    recovered = _Object$assign.recovered;\n  var hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\nfunction sign(_x, _x2) {\n  return _sign.apply(this, arguments);\n}\nfunction _sign() {\n  _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(msgHash, privKey) {\n    var opts,\n      _initSigArgs2,\n      seed,\n      m,\n      d,\n      drbg,\n      sig,\n      _args7 = arguments;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          opts = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};\n          _initSigArgs2 = initSigArgs(msgHash, privKey, opts.extraEntropy), seed = _initSigArgs2.seed, m = _initSigArgs2.m, d = _initSigArgs2.d;\n          drbg = new HmacDrbg(hashLen, groupLen);\n          _context7.next = 5;\n          return drbg.reseed(seed);\n        case 5:\n          _context7.t0 = kmdToSig;\n          _context7.next = 8;\n          return drbg.generate();\n        case 8:\n          _context7.t1 = _context7.sent;\n          _context7.t2 = m;\n          _context7.t3 = d;\n          _context7.t4 = opts.canonical;\n          if (sig = (0, _context7.t0)(_context7.t1, _context7.t2, _context7.t3, _context7.t4)) {\n            _context7.next = 17;\n            break;\n          }\n          _context7.next = 15;\n          return drbg.reseed();\n        case 15:\n          _context7.next = 5;\n          break;\n        case 17:\n          return _context7.abrupt(\"return\", finalizeSig(sig, opts));\n        case 18:\n        case \"end\":\n          return _context7.stop();\n      }\n    }, _callee7);\n  }));\n  return _sign.apply(this, arguments);\n}\nexports.sign = sign;\nfunction signSync(msgHash, privKey) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _initSigArgs = initSigArgs(msgHash, privKey, opts.extraEntropy),\n    seed = _initSigArgs.seed,\n    m = _initSigArgs.m,\n    d = _initSigArgs.d;\n  var drbg = new HmacDrbg(hashLen, groupLen);\n  drbg.reseedSync(seed);\n  var sig;\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();\n  return finalizeSig(sig, opts);\n}\nexports.signSync = signSync;\nvar vopts = {\n  strict: true\n};\nfunction verify(signature, msgHash, publicKey) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;\n  var sig;\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n  var _sig = sig,\n    r = _sig.r,\n    s = _sig.s;\n  if (opts.strict && sig.hasHighS()) return false;\n  var h = truncateHash(msgHash);\n  var P;\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n  var n = CURVE.n;\n  var sinv = invert(s, n);\n  var u1 = mod(h * sinv, n);\n  var u2 = mod(r * sinv, n);\n  var R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  var v = mod(R.x, n);\n  return v === r;\n}\nexports.verify = verify;\nfunction schnorrChallengeFinalize(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\nvar SchnorrSignature = /*#__PURE__*/function () {\n  function SchnorrSignature(r, s) {\n    _classCallCheck(this, SchnorrSignature);\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  _createClass(SchnorrSignature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n        s = this.s;\n      if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return hexToBytes(this.toHex());\n    }\n  }], [{\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      if (bytes.length !== 64) throw new TypeError(\"SchnorrSignature.fromHex: expected 64 bytes, not \".concat(bytes.length));\n      var r = bytesToNumber(bytes.subarray(0, 32));\n      var s = bytesToNumber(bytes.subarray(32, 64));\n      return new SchnorrSignature(r, s);\n    }\n  }]);\n  return SchnorrSignature;\n}();\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\nvar InternalSchnorrSignature = /*#__PURE__*/function () {\n  function InternalSchnorrSignature(message, privateKey) {\n    var auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.utils.randomBytes();\n    _classCallCheck(this, InternalSchnorrSignature);\n    if (message == null) throw new TypeError(\"sign: Expected valid message, not \\\"\".concat(message, \"\\\"\"));\n    this.m = ensureBytes(message);\n    var _this$getScalar = this.getScalar(normalizePrivateKey(privateKey)),\n      x = _this$getScalar.x,\n      scalar = _this$getScalar.scalar;\n    this.px = x;\n    this.d = scalar;\n    this.rand = ensureBytes(auxRand);\n    if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  }\n  _createClass(InternalSchnorrSignature, [{\n    key: \"getScalar\",\n    value: function getScalar(priv) {\n      var point = Point.fromPrivateKey(priv);\n      var scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n      return {\n        point: point,\n        scalar: scalar,\n        x: point.toRawX()\n      };\n    }\n  }, {\n    key: \"initNonce\",\n    value: function initNonce(d, t0h) {\n      return numTo32b(d ^ bytesToNumber(t0h));\n    }\n  }, {\n    key: \"finalizeNonce\",\n    value: function finalizeNonce(k0h) {\n      var k0 = mod(bytesToNumber(k0h), CURVE.n);\n      if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n      var _this$getScalar2 = this.getScalar(k0),\n        R = _this$getScalar2.point,\n        rx = _this$getScalar2.x,\n        k = _this$getScalar2.scalar;\n      return {\n        R: R,\n        rx: rx,\n        k: k\n      };\n    }\n  }, {\n    key: \"finalizeSig\",\n    value: function finalizeSig(R, k, e, d) {\n      return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      throw new Error('sign: Invalid signature produced');\n    }\n  }, {\n    key: \"calc\",\n    value: function () {\n      var _calc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var m, d, px, rand, tag, t, _this$finalizeNonce, R, rx, k, e, sig;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              m = this.m, d = this.d, px = this.px, rand = this.rand;\n              tag = exports.utils.taggedHash;\n              _context3.t0 = this;\n              _context3.t1 = d;\n              _context3.next = 6;\n              return tag(TAGS.aux, rand);\n            case 6:\n              _context3.t2 = _context3.sent;\n              t = _context3.t0.initNonce.call(_context3.t0, _context3.t1, _context3.t2);\n              _context3.t3 = this;\n              _context3.next = 11;\n              return tag(TAGS.nonce, t, px, m);\n            case 11:\n              _context3.t4 = _context3.sent;\n              _this$finalizeNonce = _context3.t3.finalizeNonce.call(_context3.t3, _context3.t4);\n              R = _this$finalizeNonce.R;\n              rx = _this$finalizeNonce.rx;\n              k = _this$finalizeNonce.k;\n              _context3.t5 = schnorrChallengeFinalize;\n              _context3.next = 19;\n              return tag(TAGS.challenge, rx, px, m);\n            case 19:\n              _context3.t6 = _context3.sent;\n              e = (0, _context3.t5)(_context3.t6);\n              sig = this.finalizeSig(R, k, e, d);\n              _context3.next = 24;\n              return schnorrVerify(sig, m, px);\n            case 24:\n              if (_context3.sent) {\n                _context3.next = 26;\n                break;\n              }\n              this.error();\n            case 26:\n              return _context3.abrupt(\"return\", sig);\n            case 27:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function calc() {\n        return _calc.apply(this, arguments);\n      }\n      return calc;\n    }()\n  }, {\n    key: \"calcSync\",\n    value: function calcSync() {\n      var m = this.m,\n        d = this.d,\n        px = this.px,\n        rand = this.rand;\n      var tag = exports.utils.taggedHashSync;\n      var t = this.initNonce(d, tag(TAGS.aux, rand));\n      var _this$finalizeNonce2 = this.finalizeNonce(tag(TAGS.nonce, t, px, m)),\n        R = _this$finalizeNonce2.R,\n        rx = _this$finalizeNonce2.rx,\n        k = _this$finalizeNonce2.k;\n      var e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n      var sig = this.finalizeSig(R, k, e, d);\n      if (!schnorrVerifySync(sig, m, px)) this.error();\n      return sig;\n    }\n  }]);\n  return InternalSchnorrSignature;\n}();\nfunction schnorrSign(_x3, _x4, _x5) {\n  return _schnorrSign.apply(this, arguments);\n}\nfunction _schnorrSign() {\n  _schnorrSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(msg, privKey, auxRand) {\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          return _context8.abrupt(\"return\", new InternalSchnorrSignature(msg, privKey, auxRand).calc());\n        case 1:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return _schnorrSign.apply(this, arguments);\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n  return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n  var raw = signature instanceof SchnorrSignature;\n  var sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return _objectSpread(_objectSpread({}, sig), {}, {\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  });\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  var R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !R.hasEvenY() || R.x !== r) return false;\n  return true;\n}\nfunction schnorrVerify(_x6, _x7, _x8) {\n  return _schnorrVerify.apply(this, arguments);\n}\nfunction _schnorrVerify() {\n  _schnorrVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(signature, message, publicKey) {\n    var _initSchnorrVerify2, r, s, m, P, e;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          _context9.prev = 0;\n          _initSchnorrVerify2 = initSchnorrVerify(signature, message, publicKey), r = _initSchnorrVerify2.r, s = _initSchnorrVerify2.s, m = _initSchnorrVerify2.m, P = _initSchnorrVerify2.P;\n          _context9.t0 = schnorrChallengeFinalize;\n          _context9.next = 5;\n          return exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m);\n        case 5:\n          _context9.t1 = _context9.sent;\n          e = (0, _context9.t0)(_context9.t1);\n          return _context9.abrupt(\"return\", finalizeSchnorrVerify(r, P, s, e));\n        case 10:\n          _context9.prev = 10;\n          _context9.t2 = _context9[\"catch\"](0);\n          return _context9.abrupt(\"return\", false);\n        case 13:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9, null, [[0, 10]]);\n  }));\n  return _schnorrVerify.apply(this, arguments);\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    var _initSchnorrVerify = initSchnorrVerify(signature, message, publicKey),\n      r = _initSchnorrVerify.r,\n      s = _initSchnorrVerify.s,\n      m = _initSchnorrVerify.m,\n      P = _initSchnorrVerify.P;\n    var e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    if (error instanceof ShaError) throw error;\n    return false;\n  }\n}\nexports.schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nvar crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nvar TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nvar TAGGED_HASH_PREFIXES = {};\nexports.utils = {\n  bytesToHex: bytesToHex,\n  hexToBytes: hexToBytes,\n  concatBytes: concatBytes,\n  mod: mod,\n  invert: invert,\n  isValidPrivateKey: function isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  _bigintTo32Bytes: numTo32b,\n  _normalizePrivateKey: normalizePrivateKey,\n  hashToPrivateKey: function hashToPrivateKey(hash) {\n    hash = ensureBytes(hash);\n    var minLen = groupLen + 8;\n    if (hash.length < minLen || hash.length > 1024) {\n      throw new Error(\"Expected valid bytes of private key as per FIPS 186\");\n    }\n    var num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n    return numTo32b(num);\n  },\n  randomBytes: function randomBytes() {\n    var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      var randomBytes = crypto.node.randomBytes;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: function randomPrivateKey() {\n    return exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8));\n  },\n  precompute: function precompute() {\n    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    var cached = point === Point.BASE ? point : new Point(point.x, point.y);\n    cached._setWindowSize(windowSize);\n    cached.multiply(_3n);\n    return cached;\n  },\n  sha256: function () {\n    var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var _len4,\n        messages,\n        _key4,\n        buffer,\n        createHash,\n        hash,\n        _args4 = arguments;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            for (_len4 = _args4.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              messages[_key4] = _args4[_key4];\n            }\n            if (!crypto.web) {\n              _context4.next = 8;\n              break;\n            }\n            _context4.next = 4;\n            return crypto.web.subtle.digest('SHA-256', concatBytes.apply(void 0, messages));\n          case 4:\n            buffer = _context4.sent;\n            return _context4.abrupt(\"return\", new Uint8Array(buffer));\n          case 8:\n            if (!crypto.node) {\n              _context4.next = 15;\n              break;\n            }\n            createHash = crypto.node.createHash;\n            hash = createHash('sha256');\n            messages.forEach(function (m) {\n              return hash.update(m);\n            });\n            return _context4.abrupt(\"return\", Uint8Array.from(hash.digest()));\n          case 15:\n            throw new Error(\"The environment doesn't have sha256 function\");\n          case 16:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    function sha256() {\n      return _sha.apply(this, arguments);\n    }\n    return sha256;\n  }(),\n  hmacSha256: function () {\n    var _hmacSha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {\n      var _len5,\n        messages,\n        _key5,\n        ckey,\n        message,\n        buffer,\n        createHmac,\n        hash,\n        _args5 = arguments;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            for (_len5 = _args5.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n              messages[_key5 - 1] = _args5[_key5];\n            }\n            if (!crypto.web) {\n              _context5.next = 12;\n              break;\n            }\n            _context5.next = 4;\n            return crypto.web.subtle.importKey('raw', key, {\n              name: 'HMAC',\n              hash: {\n                name: 'SHA-256'\n              }\n            }, false, ['sign']);\n          case 4:\n            ckey = _context5.sent;\n            message = concatBytes.apply(void 0, messages);\n            _context5.next = 8;\n            return crypto.web.subtle.sign('HMAC', ckey, message);\n          case 8:\n            buffer = _context5.sent;\n            return _context5.abrupt(\"return\", new Uint8Array(buffer));\n          case 12:\n            if (!crypto.node) {\n              _context5.next = 19;\n              break;\n            }\n            createHmac = crypto.node.createHmac;\n            hash = createHmac('sha256', key);\n            messages.forEach(function (m) {\n              return hash.update(m);\n            });\n            return _context5.abrupt(\"return\", Uint8Array.from(hash.digest()));\n          case 19:\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n          case 20:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    function hmacSha256(_x9) {\n      return _hmacSha.apply(this, arguments);\n    }\n    return hmacSha256;\n  }(),\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: function () {\n    var _taggedHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(tag) {\n      var _exports$utils2;\n      var tagP,\n        tagH,\n        _len6,\n        messages,\n        _key6,\n        _args6 = arguments;\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            tagP = TAGGED_HASH_PREFIXES[tag];\n            if (!(tagP === undefined)) {\n              _context6.next = 7;\n              break;\n            }\n            _context6.next = 4;\n            return exports.utils.sha256(Uint8Array.from(tag, function (c) {\n              return c.charCodeAt(0);\n            }));\n          case 4:\n            tagH = _context6.sent;\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n          case 7:\n            for (_len6 = _args6.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n              messages[_key6 - 1] = _args6[_key6];\n            }\n            return _context6.abrupt(\"return\", (_exports$utils2 = exports.utils).sha256.apply(_exports$utils2, [tagP].concat(messages)));\n          case 9:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n    function taggedHash(_x10) {\n      return _taggedHash.apply(this, arguments);\n    }\n    return taggedHash;\n  }(),\n  taggedHashSync: function taggedHashSync(tag) {\n    if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');\n    var tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n      var tagH = _sha256Sync(Uint8Array.from(tag, function (c) {\n        return c.charCodeAt(0);\n      }));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      messages[_key7 - 1] = arguments[_key7];\n    }\n    return _sha256Sync.apply(void 0, [tagP].concat(messages));\n  },\n  _JacobianPoint: JacobianPoint\n};\nObject.defineProperties(exports.utils, {\n  sha256Sync: {\n    configurable: false,\n    get: function get() {\n      return _sha256Sync;\n    },\n    set: function set(val) {\n      if (!_sha256Sync) _sha256Sync = val;\n    }\n  },\n  hmacSha256Sync: {\n    configurable: false,\n    get: function get() {\n      return _hmacSha256Sync;\n    },\n    set: function set(val) {\n      if (!_hmacSha256Sync) _hmacSha256Sync = val;\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}