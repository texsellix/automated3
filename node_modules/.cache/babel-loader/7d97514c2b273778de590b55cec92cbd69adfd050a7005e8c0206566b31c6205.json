{"ast":null,"code":"\"use strict\";\n\n//  NOTICE\n//  Copyright 2015 D2L Corporation\n//\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joseToDer = exports.derToJose = void 0;\n// The following code is adapted from https://github.com/Brightspace/node-ecdsa-sig-formatter\nconst base64_js_1 = require(\"base64-js\");\nconst base64Url_1 = require(\"./base64Url\");\nfunction getParamSize(keySize) {\n  return (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);\n}\nconst paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n};\nfunction getParamBytesForAlg(alg) {\n  const paramBytes = paramBytesForAlg[alg];\n  if (paramBytes) {\n    return paramBytes;\n  }\n  throw new Error(`Unknown algorithm \"${alg}\"`);\n}\nconst MAX_OCTET = 0x80;\nconst CLASS_UNIVERSAL = 0;\nconst PRIMITIVE_BIT = 0x20;\nconst TAG_SEQ = 0x10;\nconst TAG_INT = 0x02;\nconst ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;\nconst ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\nfunction signatureAsBytes(signature) {\n  if (signature instanceof Uint8Array) {\n    return signature;\n  } else if ('string' === typeof signature) {\n    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(signature));\n  }\n  throw new TypeError('ECDSA signature must be a Base64 string or a Uint8Array');\n}\nfunction derToJose(signature, alg) {\n  const signatureBytes = signatureAsBytes(signature);\n  const paramBytes = getParamBytesForAlg(alg);\n  // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n  const maxEncodedParamLength = paramBytes + 1;\n  const inputLength = signatureBytes.length;\n  let offset = 0;\n  if (signatureBytes[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"');\n  }\n  let seqLength = signatureBytes[offset++];\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signatureBytes[offset++];\n  }\n  if (inputLength - offset < seqLength) {\n    throw new Error(`\"seq\" specified length of \"${seqLength}\", only \"${inputLength - offset}\" remaining`);\n  }\n  if (signatureBytes[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  }\n  const rLength = signatureBytes[offset++];\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", only \"${inputLength - offset - 2}\" available`);\n  }\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", max of \"${maxEncodedParamLength}\" is acceptable`);\n  }\n  const rOffset = offset;\n  offset += rLength;\n  if (signatureBytes[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  }\n  const sLength = signatureBytes[offset++];\n  if (inputLength - offset !== sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", expected \"${inputLength - offset}\"`);\n  }\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", max of \"${maxEncodedParamLength}\" is acceptable`);\n  }\n  const sOffset = offset;\n  offset += sLength;\n  if (offset !== inputLength) {\n    throw new Error(`Expected to consume entire array, but \"${inputLength - offset}\" bytes remain`);\n  }\n  const rPadding = paramBytes - rLength;\n  const sPadding = paramBytes - sLength;\n  const dst = new Uint8Array(rPadding + rLength + sPadding + sLength);\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  dst.set(signatureBytes.subarray(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);\n  offset = paramBytes;\n  for (const o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  dst.set(signatureBytes.subarray(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);\n  return (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(dst));\n}\nexports.derToJose = derToJose;\nfunction countPadding(buf, start, stop) {\n  let padding = 0;\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n  const needsSign = buf[start + padding] >= MAX_OCTET;\n  if (needsSign) {\n    --padding;\n  }\n  return padding;\n}\nfunction joseToDer(signature, alg) {\n  signature = signatureAsBytes(signature);\n  const paramBytes = getParamBytesForAlg(alg);\n  const signatureBytes = signature.length;\n  if (signatureBytes !== paramBytes * 2) {\n    throw new TypeError(`\"${alg}\" signatures must be \"${paramBytes * 2}\" bytes, saw \"${signatureBytes}\"`);\n  }\n  const rPadding = countPadding(signature, 0, paramBytes);\n  const sPadding = countPadding(signature, paramBytes, signature.length);\n  const rLength = paramBytes - rPadding;\n  const sLength = paramBytes - sPadding;\n  const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n  const shortLength = rsBytes < MAX_OCTET;\n  const dst = new Uint8Array((shortLength ? 2 : 3) + rsBytes);\n  let offset = 0;\n  dst[offset++] = ENCODED_TAG_SEQ;\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes;\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET | 1;\n    // length, base 256\n    dst[offset++] = rsBytes & 0xff;\n  }\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = rLength;\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    dst.set(signature.subarray(0, paramBytes), offset);\n    offset += paramBytes;\n  } else {\n    dst.set(signature.subarray(rPadding, paramBytes), offset);\n    offset += paramBytes - rPadding;\n  }\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = sLength;\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    dst.set(signature.subarray(paramBytes), offset);\n  } else {\n    dst.set(signature.subarray(paramBytes + sPadding), offset);\n  }\n  return dst;\n}\nexports.joseToDer = joseToDer;\n//# sourceMappingURL=ecdsaSigFormatter.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}