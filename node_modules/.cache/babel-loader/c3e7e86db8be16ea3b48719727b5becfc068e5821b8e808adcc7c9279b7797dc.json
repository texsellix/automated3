{"ast":null,"code":"import _slicedToArray from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/metehan/Downloads/ord/sats-connect-example-main 2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as base from '@scure/base';\nexport var EMPTY = new Uint8Array();\nexport var NULL = new Uint8Array([0]);\nexport function equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\nexport function concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nexport var isBytes = function isBytes(b) {\n  return b instanceof Uint8Array;\n};\nexport var Reader = /*#__PURE__*/function () {\n  function Reader(data) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var fieldPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    _classCallCheck(this, Reader);\n    this.data = data;\n    this.path = path;\n    this.fieldPath = fieldPath;\n    this.pos = 0;\n    this.hasPtr = false;\n    this.bitBuf = 0;\n    this.bitPos = 0;\n  }\n  _createClass(Reader, [{\n    key: \"err\",\n    value: function err(msg) {\n      return new Error(\"Reader(\".concat(this.fieldPath.join('/'), \"): \").concat(msg));\n    }\n  }, {\n    key: \"absBytes\",\n    value: function absBytes(n) {\n      if (n > this.data.length) throw new Error('absBytes: Unexpected end of buffer');\n      return this.data.subarray(n);\n    }\n  }, {\n    key: \"bytes\",\n    value: function bytes(n) {\n      var peek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.bitPos) throw this.err('readBytes: bitPos not empty');\n      if (!Number.isFinite(n)) throw this.err(\"readBytes: wrong length=\".concat(n));\n      if (this.pos + n > this.data.length) throw this.err('readBytes: Unexpected end of buffer');\n      var slice = this.data.subarray(this.pos, this.pos + n);\n      if (!peek) this.pos += n;\n      return slice;\n    }\n  }, {\n    key: \"byte\",\n    value: function byte() {\n      var peek = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.bitPos) throw this.err('readByte: bitPos not empty');\n      return this.data[peek ? this.pos : this.pos++];\n    }\n  }, {\n    key: \"leftBytes\",\n    get: function get() {\n      return this.data.length - this.pos;\n    }\n  }, {\n    key: \"isEnd\",\n    value: function isEnd() {\n      return this.pos >= this.data.length && !this.bitPos;\n    }\n  }, {\n    key: \"length\",\n    value: function length(len) {\n      var byteLen;\n      if (isCoder(len)) byteLen = Number(len.decodeStream(this));else if (typeof len === 'number') byteLen = len;else if (typeof len === 'string') byteLen = getPath(this.path, len.split('/'));\n      if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n      if (typeof byteLen !== 'number') throw this.err(\"Wrong length: \".concat(byteLen));\n      return byteLen;\n    }\n  }, {\n    key: \"bits\",\n    value: function bits(_bits) {\n      if (_bits > 32) throw this.err('BitReader: cannot read more than 32 bits in single call');\n      var out = 0;\n      while (_bits) {\n        if (!this.bitPos) {\n          this.bitBuf = this.data[this.pos++];\n          this.bitPos = 8;\n        }\n        var take = Math.min(_bits, this.bitPos);\n        this.bitPos -= take;\n        out = out << take | this.bitBuf >> this.bitPos & Math.pow(2, take) - 1;\n        this.bitBuf &= Math.pow(2, this.bitPos) - 1;\n        _bits -= take;\n      }\n      return out >>> 0;\n    }\n  }, {\n    key: \"find\",\n    value: function find(needle) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.pos;\n      if (!isBytes(needle)) throw this.err(\"find: needle is not bytes! \".concat(needle));\n      if (this.bitPos) throw this.err('findByte: bitPos not empty');\n      if (!needle.length) throw this.err(\"find: needle is empty\");\n      for (var idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n        if (idx === -1) return;\n        var leftBytes = this.data.length - idx;\n        if (leftBytes < needle.length) return;\n        if (equalBytes(needle, this.data.subarray(idx, idx + needle.length))) return idx;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      if (this.isEnd() || this.hasPtr) return;\n      throw this.err(\"\".concat(this.leftBytes, \" bytes \").concat(this.bitPos, \" bits left after unpack: \").concat(base.hex.encode(this.data.slice(this.pos))));\n    }\n  }, {\n    key: \"fieldPathPush\",\n    value: function fieldPathPush(s) {\n      this.fieldPath.push(s);\n    }\n  }, {\n    key: \"fieldPathPop\",\n    value: function fieldPathPop() {\n      this.fieldPath.pop();\n    }\n  }]);\n  return Reader;\n}();\nexport var Writer = /*#__PURE__*/function () {\n  function Writer() {\n    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var fieldPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _classCallCheck(this, Writer);\n    this.path = path;\n    this.fieldPath = fieldPath;\n    this.buffers = [];\n    this.pos = 0;\n    this.ptrs = [];\n    this.bitBuf = 0;\n    this.bitPos = 0;\n  }\n  _createClass(Writer, [{\n    key: \"err\",\n    value: function err(msg) {\n      return new Error(\"Writer(\".concat(this.fieldPath.join('/'), \"): \").concat(msg));\n    }\n  }, {\n    key: \"bytes\",\n    value: function bytes(b) {\n      if (this.bitPos) throw this.err('writeBytes: ends with non-empty bit buffer');\n      this.buffers.push(b);\n      this.pos += b.length;\n    }\n  }, {\n    key: \"byte\",\n    value: function byte(b) {\n      if (this.bitPos) throw this.err('writeByte: ends with non-empty bit buffer');\n      this.buffers.push(new Uint8Array([b]));\n      this.pos++;\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      if (this.bitPos) throw this.err('buffer: ends with non-empty bit buffer');\n      var buf = concatBytes.apply(void 0, _toConsumableArray(this.buffers));\n      var _iterator = _createForOfIteratorHelper(this.ptrs),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ptr = _step.value;\n          var pos = buf.length;\n          buf = concatBytes(buf, ptr.buffer);\n          var val = ptr.ptr.encode(pos);\n          for (var i = 0; i < val.length; i++) buf[ptr.pos + i] = val[i];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return buf;\n    }\n  }, {\n    key: \"length\",\n    value: function length(len, value) {\n      if (len === null) return;\n      if (isCoder(len)) return len.encodeStream(this, value);\n      var byteLen;\n      if (typeof len === 'number') byteLen = len;else if (typeof len === 'string') byteLen = getPath(this.path, len.split('/'));\n      if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n      if (byteLen === undefined || byteLen !== value) throw this.err(\"Wrong length: \".concat(byteLen, \" len=\").concat(len, \" exp=\").concat(value));\n    }\n  }, {\n    key: \"bits\",\n    value: function bits(value, _bits2) {\n      if (_bits2 > 32) throw this.err('writeBits: cannot write more than 32 bits in single call');\n      if (value >= Math.pow(2, _bits2)) throw this.err(\"writeBits: value (\".concat(value, \") >= 2**bits (\").concat(_bits2, \")\"));\n      while (_bits2) {\n        var take = Math.min(_bits2, 8 - this.bitPos);\n        this.bitBuf = this.bitBuf << take | value >> _bits2 - take;\n        this.bitPos += take;\n        _bits2 -= take;\n        value &= Math.pow(2, _bits2) - 1;\n        if (this.bitPos === 8) {\n          this.bitPos = 0;\n          this.buffers.push(new Uint8Array([this.bitBuf]));\n          this.pos++;\n        }\n      }\n    }\n  }, {\n    key: \"fieldPathPush\",\n    value: function fieldPathPush(s) {\n      this.fieldPath.push(s);\n    }\n  }, {\n    key: \"fieldPathPop\",\n    value: function fieldPathPop() {\n      this.fieldPath.pop();\n    }\n  }]);\n  return Writer;\n}();\nvar swap = function swap(b) {\n  return Uint8Array.from(b).reverse();\n};\nexport function checkBounds(p, value, bits, signed) {\n  if (signed) {\n    var signBit = Math.pow(2n, bits - 1n);\n    if (value < -signBit || value >= signBit) throw p.err('sInt: value out of bounds');\n  } else {\n    if (0n > value || value >= Math.pow(2n, bits)) throw p.err('uInt: value out of bounds');\n  }\n}\nexport function wrap(inner) {\n  return _objectSpread(_objectSpread({}, inner), {}, {\n    encode: function encode(value) {\n      var w = new Writer();\n      inner.encodeStream(w, value);\n      return w.buffer;\n    },\n    decode: function decode(data) {\n      var r = new Reader(data);\n      var res = inner.decodeStream(r);\n      r.finish();\n      return res;\n    }\n  });\n}\nfunction getPath(objPath, path) {\n  objPath = Array.from(objPath);\n  var i = 0;\n  for (; i < path.length; i++) {\n    if (path[i] === '..') objPath.pop();else break;\n  }\n  var cur = objPath.pop();\n  for (; i < path.length; i++) {\n    if (!cur || cur[path[i]] === undefined) return undefined;\n    cur = cur[path[i]];\n  }\n  return cur;\n}\nexport function isCoder(elm) {\n  return typeof elm.encode === 'function' && typeof elm.encodeStream === 'function' && typeof elm.decode === 'function' && typeof elm.decodeStream === 'function';\n}\nfunction dict() {\n  return {\n    encode: function encode(from) {\n      var to = {};\n      var _iterator2 = _createForOfIteratorHelper(from),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            name = _step2$value[0],\n            value = _step2$value[1];\n          if (to[name] !== undefined) throw new Error(\"coders.dict: same key(\".concat(name, \") appears twice in struct\"));\n          to[name] = value;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return to;\n    },\n    decode: function decode(to) {\n      return Object.entries(to);\n    }\n  };\n}\nvar number = {\n  encode: function encode(from) {\n    if (from > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(\"coders.number: element bigger than MAX_SAFE_INTEGER=\".concat(from));\n    return Number(from);\n  },\n  decode: function decode(to) {\n    return BigInt(to);\n  }\n};\nfunction tsEnum(e) {\n  return {\n    encode: function encode(from) {\n      return e[from];\n    },\n    decode: function decode(to) {\n      return e[to];\n    }\n  };\n}\nfunction decimal(precision) {\n  var decimalMask = Math.pow(10n, BigInt(precision));\n  return {\n    encode: function encode(from) {\n      var s = (from < 0n ? -from : from).toString(10);\n      var sep = s.length - precision;\n      if (sep < 0) {\n        s = s.padStart(s.length - sep, '0');\n        sep = 0;\n      }\n      var i = s.length - 1;\n      for (; i >= sep && s[i] === '0'; i--);\n      var _ref = [s.slice(0, sep), s.slice(sep, i + 1)],\n        int = _ref[0],\n        frac = _ref[1];\n      if (!int) int = '0';\n      if (from < 0n) int = '-' + int;\n      if (!frac) return int;\n      return \"\".concat(int, \".\").concat(frac);\n    },\n    decode: function decode(to) {\n      var neg = false;\n      if (to.startsWith('-')) {\n        neg = true;\n        to = to.slice(1);\n      }\n      var sep = to.indexOf('.');\n      sep = sep === -1 ? to.length : sep;\n      var _ref2 = [to.slice(0, sep), to.slice(sep + 1)],\n        intS = _ref2[0],\n        fracS = _ref2[1];\n      var int = BigInt(intS) * decimalMask;\n      var fracLen = Math.min(fracS.length, precision);\n      var frac = BigInt(fracS.slice(0, fracLen)) * Math.pow(10n, BigInt(precision - fracLen));\n      var value = int + frac;\n      return neg ? -value : value;\n    }\n  };\n}\nfunction match(lst) {\n  return {\n    encode: function encode(from) {\n      var _iterator3 = _createForOfIteratorHelper(lst),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var c = _step3.value;\n          var elm = c.encode(from);\n          if (elm !== undefined) return elm;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      throw new Error(\"match/encode: cannot find match in \".concat(from));\n    },\n    decode: function decode(to) {\n      var _iterator4 = _createForOfIteratorHelper(lst),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var c = _step4.value;\n          var elm = c.decode(to);\n          if (elm !== undefined) return elm;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      throw new Error(\"match/decode: cannot find match in \".concat(to));\n    }\n  };\n}\nexport var coders = {\n  dict: dict,\n  number: number,\n  tsEnum: tsEnum,\n  decimal: decimal,\n  match: match\n};\nexport var bits = function bits(len) {\n  return wrap({\n    encodeStream: function encodeStream(w, value) {\n      return w.bits(value, len);\n    },\n    decodeStream: function decodeStream(r) {\n      return r.bits(len);\n    }\n  });\n};\nexport var bigint = function bigint(size) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var signed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return wrap({\n    size: size,\n    encodeStream: function encodeStream(w, value) {\n      if (typeof value !== 'number' && typeof value !== 'bigint') throw w.err(\"bigint: invalid value: \".concat(value));\n      var _value = BigInt(value);\n      var bLen = BigInt(size);\n      checkBounds(w, _value, 8n * bLen, !!signed);\n      var signBit = Math.pow(2n, 8n * bLen - 1n);\n      if (signed && _value < 0) _value = _value | signBit;\n      var b = [];\n      for (var i = 0; i < size; i++) {\n        b.push(Number(_value & 255n));\n        _value >>= 8n;\n      }\n      var res = new Uint8Array(b).reverse();\n      w.bytes(le ? res.reverse() : res);\n    },\n    decodeStream: function decodeStream(r) {\n      var bLen = BigInt(size);\n      var value = r.bytes(size);\n      if (le) value = swap(value);\n      var b = swap(value);\n      var signBit = Math.pow(2n, 8n * bLen - 1n);\n      var res = 0n;\n      for (var i = 0; i < b.length; i++) res |= BigInt(b[i]) << 8n * BigInt(i);\n      if (signed && res & signBit) res = (res ^ signBit) - signBit;\n      checkBounds(r, res, 8n * bLen, !!signed);\n      return res;\n    }\n  });\n};\nexport var U256LE = bigint(32, true);\nexport var U256BE = bigint(32, false);\nexport var I256LE = bigint(32, true, true);\nexport var I256BE = bigint(32, false, true);\nexport var U128LE = bigint(16, true);\nexport var U128BE = bigint(16, false);\nexport var I128LE = bigint(16, true, true);\nexport var I128BE = bigint(16, false, true);\nexport var U64LE = bigint(8, true);\nexport var U64BE = bigint(8, false);\nexport var I64LE = bigint(8, true, true);\nexport var I64BE = bigint(8, false, true);\nexport var int = function int(size) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var signed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (size > 6) throw new Error('int supports size up to 6 bytes (48 bits), for other use bigint');\n  return apply(bigint(size, le, signed), coders.number);\n};\nexport var U32LE = int(4, true);\nexport var U32BE = int(4, false);\nexport var I32LE = int(4, true, true);\nexport var I32BE = int(4, false, true);\nexport var U16LE = int(2, true);\nexport var U16BE = int(2, false);\nexport var I16LE = int(2, true, true);\nexport var I16BE = int(2, false, true);\nexport var U8 = int(1, false);\nexport var I8 = int(1, false, true);\nexport var bool = wrap({\n  size: 1,\n  encodeStream: function encodeStream(w, value) {\n    return w.byte(value ? 1 : 0);\n  },\n  decodeStream: function decodeStream(r) {\n    var value = r.byte();\n    if (value !== 0 && value !== 1) throw r.err(\"bool: invalid value \".concat(value));\n    return value === 1;\n  }\n});\nexport var bytes = function bytes(len) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: function encodeStream(w, value) {\n      if (!isBytes(value)) throw w.err(\"bytes: invalid value \".concat(value));\n      if (!isBytes(len)) w.length(len, value.length);\n      w.bytes(le ? swap(value) : value);\n      if (isBytes(len)) w.bytes(len);\n    },\n    decodeStream: function decodeStream(r) {\n      var bytes;\n      if (isBytes(len)) {\n        var tPos = r.find(len);\n        if (!tPos) throw r.err(\"bytes: cannot find terminator\");\n        bytes = r.bytes(tPos - r.pos);\n        r.bytes(len.length);\n      } else bytes = r.bytes(len === null ? r.leftBytes : r.length(len));\n      return le ? swap(bytes) : bytes;\n    }\n  });\n};\nexport var string = function string(len) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: function encodeStream(w, value) {\n      return inner.encodeStream(w, base.utf8.decode(value));\n    },\n    decodeStream: function decodeStream(r) {\n      return base.utf8.encode(inner.decodeStream(r));\n    }\n  });\n};\nexport var cstring = string(NULL);\nexport var hex = function hex(len) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var withZero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: function encodeStream(w, value) {\n      if (withZero && !value.startsWith('0x')) throw new Error('hex(withZero=true).encode input should start with 0x');\n      var bytes = base.hex.decode(withZero ? value.slice(2) : value);\n      return inner.encodeStream(w, bytes);\n    },\n    decodeStream: function decodeStream(r) {\n      return (withZero ? '0x' : '') + base.hex.encode(inner.decodeStream(r));\n    }\n  });\n};\nexport function apply(inner, b) {\n  if (!isCoder(inner)) throw new Error(\"apply: invalid inner value \".concat(inner));\n  return wrap({\n    size: inner.size,\n    encodeStream: function encodeStream(w, value) {\n      var innerValue;\n      try {\n        innerValue = b.decode(value);\n      } catch (e) {\n        throw w.err('' + e);\n      }\n      return inner.encodeStream(w, innerValue);\n    },\n    decodeStream: function decodeStream(r) {\n      var innerValue = inner.decodeStream(r);\n      try {\n        return b.encode(innerValue);\n      } catch (e) {\n        throw r.err('' + e);\n      }\n    }\n  });\n}\nexport function validate(inner, fn) {\n  if (!isCoder(inner)) throw new Error(\"validate: invalid inner value \".concat(inner));\n  return wrap({\n    size: inner.size,\n    encodeStream: function encodeStream(w, value) {\n      return inner.encodeStream(w, fn(value));\n    },\n    decodeStream: function decodeStream(r) {\n      return fn(inner.decodeStream(r));\n    }\n  });\n}\nexport function lazy(fn) {\n  return wrap({\n    encodeStream: function encodeStream(w, value) {\n      return fn().encodeStream(w, value);\n    },\n    decodeStream: function decodeStream(r) {\n      return fn().decodeStream(r);\n    }\n  });\n}\nexport var bytesFormatted = function bytesFormatted(len, fmt) {\n  var le = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: function encodeStream(w, value) {\n      return inner.encodeStream(w, base.bytes(fmt, value));\n    },\n    decodeStream: function decodeStream(r) {\n      return base.str(fmt, inner.decodeStream(r));\n    }\n  });\n};\nexport var flag = function flag(flagValue) {\n  var xor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return wrap({\n    size: flagValue.length,\n    encodeStream: function encodeStream(w, value) {\n      if (!!value !== xor) w.bytes(flagValue);\n    },\n    decodeStream: function decodeStream(r) {\n      var hasFlag = r.leftBytes >= flagValue.length;\n      if (hasFlag) {\n        hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n        if (hasFlag) r.bytes(flagValue.length);\n      }\n      return hasFlag !== xor;\n    }\n  });\n};\nexport function flagged(path, inner, def) {\n  if (!isCoder(inner)) throw new Error(\"flagged: invalid inner value \".concat(inner));\n  return wrap({\n    encodeStream: function encodeStream(w, value) {\n      if (typeof path === 'string') {\n        if (getPath(w.path, path.split('/'))) inner.encodeStream(w, value);else if (def) inner.encodeStream(w, def);\n      } else {\n        path.encodeStream(w, !!value);\n        if (!!value) inner.encodeStream(w, value);else if (def) inner.encodeStream(w, def);\n      }\n    },\n    decodeStream: function decodeStream(r) {\n      var hasFlag = false;\n      if (typeof path === 'string') hasFlag = getPath(r.path, path.split('/'));else hasFlag = path.decodeStream(r);\n      if (hasFlag) return inner.decodeStream(r);else if (def) inner.decodeStream(r);\n    }\n  });\n}\nexport function optional(flag, inner, def) {\n  if (!isCoder(flag) || !isCoder(inner)) throw new Error(\"optional: invalid flag or inner value flag=\".concat(flag, \" inner=\").concat(inner));\n  return wrap({\n    size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n    encodeStream: function encodeStream(w, value) {\n      flag.encodeStream(w, !!value);\n      if (value) inner.encodeStream(w, value);else if (def !== undefined) inner.encodeStream(w, def);\n    },\n    decodeStream: function decodeStream(r) {\n      if (flag.decodeStream(r)) return inner.decodeStream(r);else if (def !== undefined) inner.decodeStream(r);\n    }\n  });\n}\nexport function magic(inner, constant) {\n  var check = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!isCoder(inner)) throw new Error(\"flagged: invalid inner value \".concat(inner));\n  return wrap({\n    size: inner.size,\n    encodeStream: function encodeStream(w, value) {\n      return inner.encodeStream(w, constant);\n    },\n    decodeStream: function decodeStream(r) {\n      var value = inner.decodeStream(r);\n      if (check && typeof value !== 'object' && value !== constant || isBytes(constant) && !equalBytes(constant, value)) {\n        throw r.err(\"magic: invalid value: \".concat(value, \" !== \").concat(constant));\n      }\n      return;\n    }\n  });\n}\nexport var magicBytes = function magicBytes(constant) {\n  var c = typeof constant === 'string' ? base.utf8.decode(constant) : constant;\n  return magic(bytes(c.length), c);\n};\nexport function constant(c) {\n  return wrap({\n    encodeStream: function encodeStream(w, value) {\n      if (value !== c) throw new Error(\"constant: invalid value \".concat(value, \" (exp: \").concat(c, \")\"));\n    },\n    decodeStream: function decodeStream(r) {\n      return c;\n    }\n  });\n}\nfunction sizeof(fields) {\n  var size = 0;\n  var _iterator5 = _createForOfIteratorHelper(fields),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var f = _step5.value;\n      if (!f.size) return;\n      size += f.size;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return size;\n}\nexport function struct(fields) {\n  if (Array.isArray(fields)) throw new Error('Packed.Struct: got array instead of object');\n  return wrap({\n    size: sizeof(Object.values(fields)),\n    encodeStream: function encodeStream(w, value) {\n      if (typeof value !== 'object' || value === null) throw w.err(\"struct: invalid value \".concat(value));\n      w.path.push(value);\n      for (var name in fields) {\n        w.fieldPathPush(name);\n        var field = fields[name];\n        field.encodeStream(w, value[name]);\n        w.fieldPathPop();\n      }\n      w.path.pop();\n    },\n    decodeStream: function decodeStream(r) {\n      var res = {};\n      r.path.push(res);\n      for (var name in fields) {\n        r.fieldPathPush(name);\n        res[name] = fields[name].decodeStream(r);\n        r.fieldPathPop();\n      }\n      r.path.pop();\n      return res;\n    }\n  });\n}\nexport function tuple(fields) {\n  if (!Array.isArray(fields)) throw new Error(\"Packed.Tuple: got \".concat(typeof fields, \" instead of array\"));\n  return wrap({\n    size: sizeof(fields),\n    encodeStream: function encodeStream(w, value) {\n      if (!Array.isArray(value)) throw w.err(\"tuple: invalid value \".concat(value));\n      w.path.push(value);\n      for (var i = 0; i < fields.length; i++) {\n        w.fieldPathPush('' + i);\n        fields[i].encodeStream(w, value[i]);\n        w.fieldPathPop();\n      }\n      w.path.pop();\n    },\n    decodeStream: function decodeStream(r) {\n      var res = [];\n      r.path.push(res);\n      for (var i = 0; i < fields.length; i++) {\n        r.fieldPathPush('' + i);\n        res.push(fields[i].decodeStream(r));\n        r.fieldPathPop();\n      }\n      r.path.pop();\n      return res;\n    }\n  });\n}\nexport function prefix(len, inner) {\n  if (!isCoder(inner)) throw new Error(\"prefix: invalid inner value \".concat(inner));\n  if (isBytes(len)) throw new Error(\"prefix: len cannot be Uint8Array\");\n  var b = bytes(len);\n  return wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: function encodeStream(w, value) {\n      var wChild = new Writer(w.path, w.fieldPath);\n      inner.encodeStream(wChild, value);\n      b.encodeStream(w, wChild.buffer);\n    },\n    decodeStream: function decodeStream(r) {\n      var data = b.decodeStream(r);\n      return inner.decodeStream(new Reader(data, r.path, r.fieldPath));\n    }\n  });\n}\nexport function array(len, inner) {\n  if (!isCoder(inner)) throw new Error(\"array: invalid inner value \".concat(inner));\n  return wrap({\n    size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n    encodeStream: function encodeStream(w, value) {\n      if (!Array.isArray(value)) throw w.err(\"array: invalid value \".concat(value));\n      if (!isBytes(len)) w.length(len, value.length);\n      w.path.push(value);\n      for (var i = 0; i < value.length; i++) {\n        w.fieldPathPush('' + i);\n        var elm = value[i];\n        var startPos = w.pos;\n        inner.encodeStream(w, elm);\n        if (isBytes(len)) {\n          if (len.length > w.pos - startPos) continue;\n          var data = w.buffer.subarray(startPos, w.pos);\n          if (equalBytes(data.subarray(0, len.length), len)) throw w.err(\"array: inner element encoding same as separator. elm=\".concat(elm, \" data=\").concat(data));\n        }\n        w.fieldPathPop();\n      }\n      w.path.pop();\n      if (isBytes(len)) w.bytes(len);\n    },\n    decodeStream: function decodeStream(r) {\n      var res = [];\n      if (len === null) {\n        var i = 0;\n        r.path.push(res);\n        while (!r.isEnd()) {\n          r.fieldPathPush('' + i++);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n          if (inner.size && r.leftBytes < inner.size) break;\n        }\n        r.path.pop();\n      } else if (isBytes(len)) {\n        var _i = 0;\n        r.path.push(res);\n        while (true) {\n          if (equalBytes(r.bytes(len.length, true), len)) {\n            r.bytes(len.length);\n            break;\n          }\n          r.fieldPathPush('' + _i++);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n        }\n        r.path.pop();\n      } else {\n        r.fieldPathPush('arrayLen');\n        var length = r.length(len);\n        r.fieldPathPop();\n        r.path.push(res);\n        for (var _i2 = 0; _i2 < length; _i2++) {\n          r.fieldPathPush('' + _i2);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n        }\n        r.path.pop();\n      }\n      return res;\n    }\n  });\n}\nexport function map(inner, variants) {\n  if (!isCoder(inner)) throw new Error(\"map: invalid inner value \".concat(inner));\n  var variantNames = new Map();\n  for (var k in variants) variantNames.set(variants[k], k);\n  return wrap({\n    size: inner.size,\n    encodeStream: function encodeStream(w, value) {\n      if (typeof value !== 'string') throw w.err(\"map: invalid value \".concat(value));\n      if (!(value in variants)) throw w.err(\"Map: unknown variant: \".concat(value));\n      inner.encodeStream(w, variants[value]);\n    },\n    decodeStream: function decodeStream(r) {\n      var variant = inner.decodeStream(r);\n      var name = variantNames.get(variant);\n      if (name === undefined) throw r.err(\"Enum: unknown value: \".concat(variant, \" \").concat(Array.from(variantNames.keys())));\n      return name;\n    }\n  });\n}\nexport function tag(tag, variants) {\n  if (!isCoder(tag)) throw new Error(\"tag: invalid tag value \".concat(tag));\n  return wrap({\n    size: tag.size,\n    encodeStream: function encodeStream(w, value) {\n      var TAG = value.TAG,\n        data = value.data;\n      var dataType = variants[TAG];\n      if (!dataType) throw w.err(\"Tag: invalid tag \".concat(TAG.toString()));\n      tag.encodeStream(w, TAG);\n      dataType.encodeStream(w, data);\n    },\n    decodeStream: function decodeStream(r) {\n      var TAG = tag.decodeStream(r);\n      var dataType = variants[TAG];\n      if (!dataType) throw r.err(\"Tag: invalid tag \".concat(TAG));\n      return {\n        TAG: TAG,\n        data: dataType.decodeStream(r)\n      };\n    }\n  });\n}\nexport function mappedTag(tagCoder, variants) {\n  if (!isCoder(tagCoder)) throw new Error(\"mappedTag: invalid tag value \".concat(tag));\n  var mapValue = {};\n  var tagValue = {};\n  for (var key in variants) {\n    mapValue[key] = variants[key][0];\n    tagValue[key] = variants[key][1];\n  }\n  return tag(map(tagCoder, mapValue), tagValue);\n}\nexport function bitset(names) {\n  var pad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return wrap({\n    encodeStream: function encodeStream(w, value) {\n      if (typeof value !== 'object' || value === null) throw w.err(\"bitset: invalid value \".concat(value));\n      for (var i = 0; i < names.length; i++) w.bits(+value[names[i]], 1);\n      if (pad && names.length % 8) w.bits(0, 8 - names.length % 8);\n    },\n    decodeStream: function decodeStream(r) {\n      var out = {};\n      for (var i = 0; i < names.length; i++) out[names[i]] = !!r.bits(1);\n      if (pad && names.length % 8) r.bits(8 - names.length % 8);\n      return out;\n    }\n  });\n}\nexport var ZeroPad = function ZeroPad(_) {\n  return 0;\n};\nfunction padLength(blockSize, len) {\n  if (len % blockSize === 0) return 0;\n  return blockSize - len % blockSize;\n}\nexport function padLeft(blockSize, inner, padFn) {\n  if (!isCoder(inner)) throw new Error(\"padLeft: invalid inner value \".concat(inner));\n  var _padFn = padFn || ZeroPad;\n  if (!inner.size) throw new Error('padLeft with dynamic size argument is impossible');\n  return wrap({\n    size: inner.size + padLength(blockSize, inner.size),\n    encodeStream: function encodeStream(w, value) {\n      var padBytes = padLength(blockSize, inner.size);\n      for (var i = 0; i < padBytes; i++) w.byte(_padFn(i));\n      inner.encodeStream(w, value);\n    },\n    decodeStream: function decodeStream(r) {\n      r.bytes(padLength(blockSize, inner.size));\n      return inner.decodeStream(r);\n    }\n  });\n}\nexport function padRight(blockSize, inner, padFn) {\n  if (!isCoder(inner)) throw new Error(\"padRight: invalid inner value \".concat(inner));\n  var _padFn = padFn || ZeroPad;\n  return wrap({\n    size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n    encodeStream: function encodeStream(w, value) {\n      var pos = w.pos;\n      inner.encodeStream(w, value);\n      var padBytes = padLength(blockSize, w.pos - pos);\n      for (var i = 0; i < padBytes; i++) w.byte(_padFn(i));\n    },\n    decodeStream: function decodeStream(r) {\n      var start = r.pos;\n      var res = inner.decodeStream(r);\n      r.bytes(padLength(blockSize, r.pos - start));\n      return res;\n    }\n  });\n}\nexport function pointer(ptr, inner) {\n  var sized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!isCoder(ptr)) throw new Error(\"pointer: invalid ptr value \".concat(ptr));\n  if (!isCoder(inner)) throw new Error(\"pointer: invalid inner value \".concat(inner));\n  if (!ptr.size) throw new Error('Pointer: unsized ptr');\n  return wrap({\n    size: sized ? ptr.size : undefined,\n    encodeStream: function encodeStream(w, value) {\n      var start = w.pos;\n      ptr.encodeStream(w, 0);\n      w.ptrs.push({\n        pos: start,\n        ptr: ptr,\n        buffer: inner.encode(value)\n      });\n    },\n    decodeStream: function decodeStream(r) {\n      var ptrVal = ptr.decodeStream(r);\n      if (ptrVal < r.pos) throw new Error('pointer.decodeStream pointer less than position');\n      r.hasPtr = true;\n      var rChild = new Reader(r.absBytes(ptrVal), r.path, r.fieldPath);\n      return inner.decodeStream(rChild);\n    }\n  });\n}\nexport function base64armor(name, lineLen, inner, checksum) {\n  var markBegin = \"-----BEGIN \".concat(name.toUpperCase(), \"-----\");\n  var markEnd = \"-----END \".concat(name.toUpperCase(), \"-----\");\n  return {\n    encode: function encode(value) {\n      var data = inner.encode(value);\n      var encoded = base.base64.encode(data);\n      var lines = [];\n      for (var i = 0; i < encoded.length; i += lineLen) {\n        var s = encoded.slice(i, i + lineLen);\n        if (s.length) lines.push(\"\".concat(encoded.slice(i, i + lineLen), \"\\n\"));\n      }\n      var body = lines.join('');\n      if (checksum) body += \"=\".concat(base.base64.encode(checksum(data)), \"\\n\");\n      return \"\".concat(markBegin, \"\\n\\n\").concat(body).concat(markEnd, \"\\n\");\n    },\n    decode: function decode(s) {\n      var lines = s.replace(markBegin, '').replace(markEnd, '').trim().split('\\n');\n      lines = lines.map(function (l) {\n        return l.replace('\\r', '').trim();\n      });\n      if (checksum && lines[lines.length - 1].startsWith('=')) {\n        var body = base.base64.decode(lines.slice(0, -1).join(''));\n        var cs = lines[lines.length - 1].slice(1);\n        var realCS = base.base64.encode(checksum(body));\n        if (realCS !== cs) throw new Error(\"Base64Armor: invalid checksum \".concat(cs, \" instead of \").concat(realCS));\n        return inner.decode(body);\n      }\n      return inner.decode(base.base64.decode(lines.join('')));\n    }\n  };\n}\nexport var nothing = magic(bytes(0), EMPTY);\nexport function debug(inner) {\n  if (!isCoder(inner)) throw new Error(\"debug: invalid inner value \".concat(inner));\n  var log = function log(name, rw, value) {\n    console.log(\"DEBUG/\".concat(name, \"(\").concat(rw.fieldPath.join('/'), \"):\"), {\n      type: typeof value,\n      value: value\n    });\n    return value;\n  };\n  return wrap({\n    size: inner.size,\n    encodeStream: function encodeStream(w, value) {\n      return inner.encodeStream(w, log('encode', w, value));\n    },\n    decodeStream: function decodeStream(r) {\n      return log('decode', r, inner.decodeStream(r));\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}