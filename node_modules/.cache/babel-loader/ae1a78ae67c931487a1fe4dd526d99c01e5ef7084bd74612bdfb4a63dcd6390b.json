{"ast":null,"code":"\"use strict\";\n\n//  NOTICE\n//  Copyright 2015 D2L Corporation\n//\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joseToDer = exports.derToJose = void 0;\n// The following code is adapted from https://github.com/Brightspace/node-ecdsa-sig-formatter\nvar base64_js_1 = require(\"base64-js\");\nvar base64Url_1 = require(\"./base64Url\");\nfunction getParamSize(keySize) {\n  return (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);\n}\nvar paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n};\nfunction getParamBytesForAlg(alg) {\n  var paramBytes = paramBytesForAlg[alg];\n  if (paramBytes) {\n    return paramBytes;\n  }\n  throw new Error(\"Unknown algorithm \\\"\".concat(alg, \"\\\"\"));\n}\nvar MAX_OCTET = 0x80;\nvar CLASS_UNIVERSAL = 0;\nvar PRIMITIVE_BIT = 0x20;\nvar TAG_SEQ = 0x10;\nvar TAG_INT = 0x02;\nvar ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;\nvar ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\nfunction signatureAsBytes(signature) {\n  if (signature instanceof Uint8Array) {\n    return signature;\n  } else if ('string' === typeof signature) {\n    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(signature));\n  }\n  throw new TypeError('ECDSA signature must be a Base64 string or a Uint8Array');\n}\nfunction derToJose(signature, alg) {\n  var signatureBytes = signatureAsBytes(signature);\n  var paramBytes = getParamBytesForAlg(alg);\n  // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n  var maxEncodedParamLength = paramBytes + 1;\n  var inputLength = signatureBytes.length;\n  var offset = 0;\n  if (signatureBytes[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"');\n  }\n  var seqLength = signatureBytes[offset++];\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signatureBytes[offset++];\n  }\n  if (inputLength - offset < seqLength) {\n    throw new Error(\"\\\"seq\\\" specified length of \\\"\".concat(seqLength, \"\\\", only \\\"\").concat(inputLength - offset, \"\\\" remaining\"));\n  }\n  if (signatureBytes[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  }\n  var rLength = signatureBytes[offset++];\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(\"\\\"r\\\" specified length of \\\"\".concat(rLength, \"\\\", only \\\"\").concat(inputLength - offset - 2, \"\\\" available\"));\n  }\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(\"\\\"r\\\" specified length of \\\"\".concat(rLength, \"\\\", max of \\\"\").concat(maxEncodedParamLength, \"\\\" is acceptable\"));\n  }\n  var rOffset = offset;\n  offset += rLength;\n  if (signatureBytes[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  }\n  var sLength = signatureBytes[offset++];\n  if (inputLength - offset !== sLength) {\n    throw new Error(\"\\\"s\\\" specified length of \\\"\".concat(sLength, \"\\\", expected \\\"\").concat(inputLength - offset, \"\\\"\"));\n  }\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(\"\\\"s\\\" specified length of \\\"\".concat(sLength, \"\\\", max of \\\"\").concat(maxEncodedParamLength, \"\\\" is acceptable\"));\n  }\n  var sOffset = offset;\n  offset += sLength;\n  if (offset !== inputLength) {\n    throw new Error(\"Expected to consume entire array, but \\\"\".concat(inputLength - offset, \"\\\" bytes remain\"));\n  }\n  var rPadding = paramBytes - rLength;\n  var sPadding = paramBytes - sLength;\n  var dst = new Uint8Array(rPadding + rLength + sPadding + sLength);\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  dst.set(signatureBytes.subarray(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);\n  offset = paramBytes;\n  for (var o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  dst.set(signatureBytes.subarray(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);\n  return (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(dst));\n}\nexports.derToJose = derToJose;\nfunction countPadding(buf, start, stop) {\n  var padding = 0;\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n  var needsSign = buf[start + padding] >= MAX_OCTET;\n  if (needsSign) {\n    --padding;\n  }\n  return padding;\n}\nfunction joseToDer(signature, alg) {\n  signature = signatureAsBytes(signature);\n  var paramBytes = getParamBytesForAlg(alg);\n  var signatureBytes = signature.length;\n  if (signatureBytes !== paramBytes * 2) {\n    throw new TypeError(\"\\\"\".concat(alg, \"\\\" signatures must be \\\"\").concat(paramBytes * 2, \"\\\" bytes, saw \\\"\").concat(signatureBytes, \"\\\"\"));\n  }\n  var rPadding = countPadding(signature, 0, paramBytes);\n  var sPadding = countPadding(signature, paramBytes, signature.length);\n  var rLength = paramBytes - rPadding;\n  var sLength = paramBytes - sPadding;\n  var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n  var shortLength = rsBytes < MAX_OCTET;\n  var dst = new Uint8Array((shortLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  dst[offset++] = ENCODED_TAG_SEQ;\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes;\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET | 1;\n    // length, base 256\n    dst[offset++] = rsBytes & 0xff;\n  }\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = rLength;\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    dst.set(signature.subarray(0, paramBytes), offset);\n    offset += paramBytes;\n  } else {\n    dst.set(signature.subarray(rPadding, paramBytes), offset);\n    offset += paramBytes - rPadding;\n  }\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = sLength;\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    dst.set(signature.subarray(paramBytes), offset);\n  } else {\n    dst.set(signature.subarray(paramBytes + sPadding), offset);\n  }\n  return dst;\n}\nexports.joseToDer = joseToDer;\n//# sourceMappingURL=ecdsaSigFormatter.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}